%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,12pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}

        \usepackage{tocloft}
        \usepackage{tabularx}
        \usepackage{titlesec}
        \usepackage{titling}
        \usepackage{fancyhdr}
        \pagestyle{fancy}
        \usepackage{graphicx}
        \usepackage{fontspec}
        \setmainfont{AdobeClean-Regular}
        \makeatletter
    \fancypagestyle{normal}{
        \fancyhf{}
        \fancyfoot[LE,RO]{{\py@HeaderFamily\thepage}}
        \fancyfoot[LO,RE]{{\textcopyright\ 2021, Adobe Inc.}}
        \fancyhead[LE,RO]{{\py@HeaderFamily \@title\sphinxheadercomma\py@release}}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0.4pt}
    }
    \fancypagestyle{plain}{
        \fancyhf{}
        \fancyfoot[LE,RO]{{\py@HeaderFamily\thepage}}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0.4pt}
        \fancyfoot[LO,RE]{{\textcopyright\ 2021, Adobe Inc.}}
    }
\makeatother
    

\title{Acrobat Plugin Developer Guide}
\date{Apr 20, 2022}
\release{}
\author{unknown}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}

    \begin{titlepage}
        \begin{figure}[h]
        \centering{\includegraphics[scale=1.5]{../images/adobelogo.png}}
        \end{figure}
        \centering
        \vspace*{40mm}
        \textbf{\Huge Acrobat Plugin Developer Guide}

        \vspace{15mm}
        \Large \textbf{{This PDF is programmatically generated: Review copy only}}
        \vfill
        \small \textcopyright\ 2022, Adobe Inc.
    \end{titlepage}
    \clearpage
    \tableofcontents
    \clearpage
    
\pagestyle{plain}

\pagestyle{normal}
\phantomsection\label{\detokenize{toc::doc}}



\chapter{Introduction to Plugin Development}
\label{\detokenize{index:introduction-to-plugin-development}}\label{\detokenize{index::doc}}
You can use the Acrobat SDK to create plugins for Adobe Reader and Acrobat as well as stand\sphinxhyphen{}alone applications that interact with and manipulate PDF documents. The Acrobat SDK contains two libraries: the Acrobat core API and the PDF Library API.

The Acrobat core API contains a set of interfaces that let you develop plugins that integrate with Acrobat and Adobe Reader. The PDF Library API lets you develop applications that interact with and manipulate PDF documents. It overlaps with the Acrobat core API (with the important exception of the AV\sphinxhyphen{}layer, which is only part of the Acrobat core API); however, the PDF Library API also extends the Acrobat core API with a small number of interfaces specific to the PDF Library API.

This chapter introduces the Acrobat core API and PDF Library API. The API descriptions appear in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{About plugins}
\label{\detokenize{index:about-plugins}}
A plugin is an application that uses the resources of Acrobat or Adobe Reader as a host environment. This means that a plugin does not require complex user interface elements. However, it must perform certain basic functions to let Adobe Reader or Acrobat know of its presence.

Plugins are dynamically\sphinxhyphen{}linked extensions to Acrobat or Adobe Reader and are written using the Acrobat core API, which is an ANSI C/C++ library. Plugins add custom functionality and are equivalent to dynamically\sphinxhyphen{}linked libraries (DLLs) on the Microsoft Windows platform; however, the plugin file name extension is.api, not.dll. On Mac OS, the file name extension of a plugin is \sphinxcode{\sphinxupquote{acroplugin}}.

Acrobat and Adobe Reader plugins are grouped in the following categories:
\begin{itemize}
\item {} 
Regular plugins. Most plugins fall under this category.

\item {} 
Reader\sphinxhyphen{}enabled plugins. Reader\sphinxhyphen{}enabled plugins access the limited set of APIs supported by Adobe Reader. These plugins are developed with permission from Adobe and require special processing to load under Adobe Reader. (See \sphinxhref{Plugins\_ReaderPlug.html\#50618405\_11144}{Creating an Adobe Reader plugin}.)

\item {} 
Certified plugins. Certified plugins have undergone extensive testing to ensure that they do not compromise the integrity of the Acrobat security model. There is currently no way for third party plugins to be certified by Adobe. Certified plugins are reserved for Adobe only.

\end{itemize}

To ensure that only certified plugins are loaded with your installation of Acrobat or Adobe Reader, select the “Use only certified plugins” checkbox in the General panel of the Preferences dialog.

For security, DLLs cannot be loaded from subdirectories. Only DLLs located in the “plugins” folder will be loaded.

On the Mac OS platform, the third\sphinxhyphen{}party plugins should be installed in either of these directories:
\begin{itemize}
\item {} 
\textasciitilde{}/Library/Application Support/Adobe/Acrobat/(version)/Plugins

\item {} 
Library/Application Support/Adobe/Acrobat/(version)/Plugins

\end{itemize}


\section{About the Acrobat core API}
\label{\detokenize{index:about-the-acrobat-core-api}}
The Acrobat core API consists of methods that operate on objects located within PDF documents. The Acrobat core API is implemented as a standard ANSI C programming library where methods are C functions and objects are opaque data types that encapsulate their data. The Acrobat core API is supported on Windows (32\sphinxhyphen{} and 64\sphinxhyphen{}bit) and Mac OS.

The following diagram illustrates the hierarchy of the Acrobat core API.

\noindent\sphinxincludegraphics{{coreapi}.png}


\subsection{Acrobat Viewer layer}
\label{\detokenize{index:acrobat-viewer-layer}}
The Acrobat Viewer (AV) layer enables plugins to control Acrobat and modify its user interface. Using AV methods, you can, for example, add menus and menu commands, add buttons to toolbars, open and close files, display simple dialog boxes, and perform many other application\sphinxhyphen{}level tasks.

\begin{sphinxadmonition}{note}{Note:}
AV layer methods are not available through the PDF Library API.
\end{sphinxadmonition}


\subsection{Portable Document layer}
\label{\detokenize{index:portable-document-layer}}
The Portable Document (PD) layer provides access to PDF document components such as pages and annotations. Closely related to the PD layer are two method groups, each of which controls a different aspect of a PDF document:
\begin{itemize}
\item {} 
PDFEdit methods deal with the physical representation of a PDF document. More specifically, PDFEdit methods handle page content as a list of objects whose values and attributes are modifiable. These methods allow your plugin or PDF Library application to read, write, edit, and create page contents and page resources, which may contain fonts, images, and so on.

\item {} 
PDSEdit methods deal with the logical structure of a PDF document. A PDF document’s logical structure is built independent of its physical representation, with pointers from the logical structure to the physical representation, and the reverse. PDSEdit methods store the logical structure information. They enable your plugin or PDF Library application to access PDF files by means of a structure tree. Having logical structure in PDF files facilitates navigating, searching, and extracting data from PDF documents. For example, PDSEdit methods can obtain logically\sphinxhyphen{}ordered content, independently of the drawing order.

\end{itemize}


\subsection{Acrobat Support layer}
\label{\detokenize{index:acrobat-support-layer}}
The Acrobat Support (AS) layer provides a variety of utility methods, including platform\sphinxhyphen{}independent memory allocation and fixed\sphinxhyphen{}point math utilities. In addition, it allows plugins to replace low\sphinxhyphen{}level file system routines used by Acrobat (including read, write, reopen, remove file, rename file, and other directory operations). This enables Acrobat to be used with other file systems, such as on\sphinxhyphen{}line systems.


\subsection{Cos layer}
\label{\detokenize{index:cos-layer}}
The Cos Object System (Cos) layer provides access to the building blocks used to construct PDF documents. Cos methods allow plugins and PDF Library applications to manipulate low\sphinxhyphen{}level data in a PDF file, such as dictionary and data streams. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86959}{Working with Cos Objects}.)


\subsection{Platform\sphinxhyphen{}specific methods}
\label{\detokenize{index:platform-specific-methods}}
In addition to the method groups represented in the previous diagram, the Acrobat core API includes platform\sphinxhyphen{}specific plugin utilities to handle issues that are unique to Windows and Mac OS. For information about these methods, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{Acrobat core API objects}
\label{\detokenize{index:acrobat-core-api-objects}}
Most objects accessible through AV and PD layer methods are opaque. That is, they are neither pointers nor pointers to pointers. They provide equivalent functionality in that they reference an object’s data rather than storing it. If you assign one object to another variable, both variables affect the same internal object.

Objects are typically named using the following conventions:
\begin{itemize}
\item {} 
The name of the concrete definition for a complex type ends in \sphinxcode{\sphinxupquote{Rec}} (for record).

\item {} 
A pointer to a simple or complex type ends in \sphinxcode{\sphinxupquote{P}} (for pointer).

\item {} 
Opaque types do not contain a \sphinxcode{\sphinxupquote{P}} suffix. For example, a \sphinxcode{\sphinxupquote{PDDoc}} object references a PDF document.

\item {} 
Three names identify complex types that provide callback methods:
\begin{itemize}
\item {} 
\sphinxstylestrong{Monitor}: A set of callbacks for an enumeration method.

\item {} 
\sphinxstylestrong{Server}: An implementation of a service added by a plugin.

\item {} 
\sphinxstylestrong{Handler}: An implementation for a subtype of object handled by a plugin

\end{itemize}

\item {} 
Callback method names typically contain the suffix \sphinxcode{\sphinxupquote{Proc}} (for procedure).

\end{itemize}


\subsection{File object interrelationships}
\label{\detokenize{index:file-object-interrelationships}}
The following diagram shows file object interrelationships and how certain objects can be obtained by using other objects.

\noindent\sphinxincludegraphics{{Objects1}.png}


\subsection{Document object interrelationships}
\label{\detokenize{index:document-object-interrelationships}}
The following diagram shows document object interrelationships and how certain objects can be obtained by using other objects.

\noindent\sphinxincludegraphics{{Objects2}.png}


\section{Acrobat core API methods}
\label{\detokenize{index:acrobat-core-api-methods}}
Acrobat core API method names typically conform to the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{layer}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{object}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{verb}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{thing}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{layer}: identifies the method’s layer (for example, AV for Acrobat Viewer layer).

\sphinxstylestrong{object}: identifies the object upon which the method acts (for example, menu).

\sphinxstylestrong{verb}: specifies an action that the method performs (for example, get or set). See the table that follows this list for the most commonly used verbs in method names.

\sphinxstylestrong{thing}: specific to each method, usually an object of the operation. May not always be present.

The following table lists some common verbs that are used in method names and describes their meaning.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Verb
&\sphinxstyletheadfamily 
Description
\\
\hline
Acquire
&
\begin{DUlineblock}{0em}
\item[] Obtains a shareable resource from a parent object or increments a reference counter for an object. The shared object is not destroyed until all acquires have released it.
\item[] Example: \sphinxcode{\sphinxupquote{AVMenuItemAcquire}}
\end{DUlineblock}
\\
\hline
Add
&
\begin{DUlineblock}{0em}
\item[] Adds an object as a child to the current object.
\item[] Example: \sphinxcode{\sphinxupquote{PDBookmarkAddChild}}
\end{DUlineblock}
\\
\hline
AddNew
&
\begin{DUlineblock}{0em}
\item[] Creates a new object using the specified parameters and adds the new object to the current object.
\item[] Example: \sphinxcode{\sphinxupquote{PDBookmarkAddNewChild}}
\end{DUlineblock}
\\
\hline
Close
&
\begin{DUlineblock}{0em}
\item[] Destroys an object that was opened and closes the underlying storage or stream.
\item[] Example: \sphinxcode{\sphinxupquote{ASFileClose}}
\end{DUlineblock}
\\
\hline
Create
&
\begin{DUlineblock}{0em}
\item[] Creates a new object of a given type.
\item[] Example: \sphinxcode{\sphinxupquote{PDDocCreatePage}}.
\end{DUlineblock}
\\
\hline
Delete
&
\begin{DUlineblock}{0em}
\item[] Removes the second object from the current object and destroys the second object.
\item[] Example: \sphinxcode{\sphinxupquote{PDDocDeletePages}}
\end{DUlineblock}
\\
\hline
Destroy
&
\begin{DUlineblock}{0em}
\item[] Destroys the specified object and releases its resources immediately.
\item[] Example: \sphinxcode{\sphinxupquote{PDBookmarkDestroy}}
\end{DUlineblock}
\\
\hline
Enum
&
\begin{DUlineblock}{0em}
\item[] Enumerates the specified descendant objects of the current object.
\item[] Example: \sphinxcode{\sphinxupquote{PDDocEnumFonts}}
\end{DUlineblock}
\\
\hline
Get
&
\begin{DUlineblock}{0em}
\item[] Retrieves a specific object attribute.
\item[] Example: \sphinxcode{\sphinxupquote{AVWindowGetTitle}}
\end{DUlineblock}
\\
\hline
Is
&
\begin{DUlineblock}{0em}
\item[] Retrieves a Boolean attribute of the object.
\item[] Example: \sphinxcode{\sphinxupquote{PDBookmarkIsOpen}}
\end{DUlineblock}
\\
\hline
New
&
\begin{DUlineblock}{0em}
\item[] Creates a new unattached object.
\item[] Example: \sphinxcode{\sphinxupquote{AVMenuNew}}
\end{DUlineblock}
\\
\hline
Open
&
\begin{DUlineblock}{0em}
\item[] Opens an object from storage or a stream.
\item[] Example: \sphinxcode{\sphinxupquote{AVDocOpenFromFile}}
\end{DUlineblock}
\\
\hline
Release
&
\begin{DUlineblock}{0em}
\item[] Releases a shared object.
\item[] Example: \sphinxcode{\sphinxupquote{PDPageRelease}}
\end{DUlineblock}
\\
\hline
Remove
&
\begin{DUlineblock}{0em}
\item[] Removes the second object from the current object but does not destroy it.
\item[] Example: \sphinxcode{\sphinxupquote{AVMenuRemove}}
\end{DUlineblock}
\\
\hline
Set
&
\begin{DUlineblock}{0em}
\item[] Sets an attribute of the object.
\item[] Example: \sphinxcode{\sphinxupquote{PDAnnotSetFlags}}
Note: Cos methods uses the verb Put.
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

While many API method names follow the syntax specified in this section, there are exceptions. For example, conversion methods conform to the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{layer}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{object}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{source\PYGZus{}object}\PYG{o}{\PYGZgt{}}\PYG{n}{to}\PYG{o}{\PYGZlt{}}\PYG{n}{dest\PYGZus{}object}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

An example is the \sphinxcode{\sphinxupquote{AVPageViewPointToDevice}} method. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

Get and Set methods are used for getting and setting object attributes. Each object type has zero or more attributes. For example, an annotation object (\sphinxcode{\sphinxupquote{PDAnnot}} ) contains attributes such as color and date. You can obtain and modify attribute values by using methods such as \sphinxcode{\sphinxupquote{PDAnnotGetColor}} and \sphinxcode{\sphinxupquote{PDAnnotSetDate}}.

In some cases, the return value of a Get method is another object. For example, the \sphinxcode{\sphinxupquote{AVDocGetAVWindow}} method returns an \sphinxcode{\sphinxupquote{AVWindow}} object corresponding to the specified \sphinxcode{\sphinxupquote{AVDoc}} object.

Other methods that return objects have the word Acquire in their name. These methods are always paired with a corresponding Release method, and have the additional side effect of incrementing or decrementing a reference count. The Acrobat core API uses \sphinxcode{\sphinxupquote{Acquire}} and \sphinxcode{\sphinxupquote{Release}} methods to perform various tasks such as determining whether it is safe to free a memory structure representing an object. Failure to match \sphinxcode{\sphinxupquote{Acquire}} and \sphinxcode{\sphinxupquote{Release}} method pairs can result in Acrobat complaining that a document cannot be closed due to non\sphinxhyphen{}zero reference counts. For more information, see \sphinxhref{Plugins\_Pimech.html\#50618406\_68646}{Acquiring and releasing objects}.


\section{Data types}
\label{\detokenize{index:data-types}}
The Acrobat core API consists of the following data types:
\begin{itemize}
\item {} 
Scalar

\item {} 
Simple

\item {} 
Complex

\item {} 
Opaque

\item {} 
Cos

\end{itemize}


\subsection{Scalar types}
\label{\detokenize{index:scalar-types}}
Scalar (non\sphinxhyphen{}pointer) types are based on underlying C language types, but have platform\sphinxhyphen{}independent sizes. They are defined in the header file CoreExpT.h. All scalar types are AS layer types. For portability, enumerated types are defined using a type of known size, such as \sphinxcode{\sphinxupquote{ASEnum16}}. (See \sphinxhref{Plugins\_Introduction.html\#50618410\_20071}{Acrobat Support layer}.)

The following table describes scalar types.


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{index:section-1}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Byte Size
&\sphinxstyletheadfamily 
Description
\\
\hline
ASBool
&
2
&
Boolean
\\
\hline
ASUns8
&
1
&
unsigned char
\\
\hline
ASUns16
&
2
&
unsigned short
\\
\hline
ASUns32
&
4
&
unsigned long
\\
\hline
ASInt8
&
1
&
char
\\
\hline
ASInt16
&
2
&
signed short
\\
\hline
ASInt32
&
4
&
signed long
\\
\hline
ASInt64
&
8
&
signed long
\\
\hline
ASEnum8
&
1
&
enum (127 values)
\\
\hline
ASEnum16
&
2
&
enum (32767 values)
\\
\hline
ASFixed
&
4
&
fixed point integer
\\
\hline
ASSize\_t
&
4
&
size of objects (as in size\_t)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Simple types}
\label{\detokenize{index:simple-types}}
Simple types represent abstractions such as a rectangle or matrix. These objects have fields that do not change. The following are examples of simple data types:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ASFixedRect}}

\item {} 
\sphinxcode{\sphinxupquote{ASFixedMatrix}}

\item {} 
\sphinxcode{\sphinxupquote{AVRect32}}

\end{itemize}


\subsection{Complex types}
\label{\detokenize{index:complex-types}}
Complex types are structures that contain one or more fields. They are used in the following situations:
\begin{itemize}
\item {} 
To transfer a large number of parameters to or from a method. For example, the \sphinxcode{\sphinxupquote{PDFontGetMetrics}} method returns font metrics by filling out a complex structure (\sphinxcode{\sphinxupquote{PDFontMetrics}} ).

\item {} 
To define a data handler or server. For example, your plugin must provide a complex structure populated with callback methods (\sphinxcode{\sphinxupquote{AVAnnotHandlerRec}} ) when it registers an annotation handler.

\end{itemize}


\subsection{Opaque types}
\label{\detokenize{index:opaque-types}}
Many methods hide the concrete C\sphinxhyphen{}language representation of data structures. Most methods accept an object and then perform an action on the object. Examples of opaque objects are \sphinxcode{\sphinxupquote{PDDoc}} and \sphinxcode{\sphinxupquote{AVPageView}} objects.


\subsection{Cos types}
\label{\detokenize{index:cos-types}}
A Cos object refers to its corresponding Cos object in the PDF document. Cos objects are represented as opaque 8\sphinxhyphen{}byte structures. They have subtypes of boolean, integer, real, name, string, array, dict, and stream. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86959}{Working with Cos Objects}.)


\section{About PDF Library and plugin applications}
\label{\detokenize{index:about-pdf-library-and-plugin-applications}}
The Acrobat core API and the PDF Library API let you create plugins and PDF Library applications to enhance and manipulate PDF document content and to customize Acrobat and Adobe Reader to meet your requirements. The PDF Library API is a subset of the Acrobat core API, with some additional functions that are available only in PDF Library.

The following diagram shows the relationship between the PDF Library API and the Acrobat core API.

\noindent\sphinxincludegraphics{{truesdk}.png}

For information about creating an Acrobat core API or project or PDF Library API, see \sphinxhref{Plugins\_CreatingSimplePlug.html\#50618417\_31734}{Creating Plugin and PDF Library Applications}.

\begin{sphinxadmonition}{note}{Note:}
The remaining parts of this section describe tasks that you can perform by using either the Acrobat core API or the PDF Library API and refer you to the corresponding sections located in this guide.
\end{sphinxadmonition}


\subsection{Manipulating Acrobat and Adobe Reader}
\label{\detokenize{index:manipulating-acrobat-and-adobe-reader}}
Plugins can control the Acrobat and Adobe Reader interface. For example, you can create and load new buttons. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_75762}{Attaching a button to a toolbar}.)


\subsection{Displaying a PDF document in an external window}
\label{\detokenize{index:displaying-a-pdf-document-in-an-external-window}}
Plugins can have Acrobat draw into an arbitrary window, allowing plugins to support PDF file viewing within their own user interface. For example, you can view a PDF document in an external window while Acrobat is displaying another PDF document. That way, you can view two separate PDF documents from within the same instance of Acrobat. (See \sphinxhref{Plugins\_Documents.html\#50618416\_74021}{Opening a PDF document in an external window}.)


\subsection{Indexed searching}
\label{\detokenize{index:indexed-searching}}
Indexed searching enables you to catalog, index, search, and highlight text in PDF files. Simple sequential text searching may be too time consuming for long documents, and completely inadequate for searching a large collection of documents. (See \sphinxhref{Plugins\_Words.html\#50618422\_87728}{Working with Words}.)

Text retrieval systems overcome this problem by building a search index containing information on the location of all words in each document in the collection. A search system uses this index to determine which documents—and word locations within those documents—satisfy a given query. The search system then allows a user to browse the found documents, optionally displaying or highlighting the matching items.


\subsection{Modifying file access}
\label{\detokenize{index:modifying-file-access}}
Plugins can provide their own file access procedures that read and write data when requested by the Acrobat core API. Using this capability, a plugin can enable PDF documents to be read from on\sphinxhyphen{}line systems, e–mail, document management, or database programs. (See \sphinxhref{Plugins\_Documents.html\#50618416\_95146}{Accessing non\sphinxhyphen{}PDF files}.)


\subsection{Creating new annotation types}
\label{\detokenize{index:creating-new-annotation-types}}
Plugins can create their own annotation types, including any data they need. A custom annotation type can enable a user to draw (not just type) in an annotation, it can provide support for multiple fonts or text styles, or it can support annotations that can only be viewed by specific users. For example, you can use the Acrobat core API to create 3D annotations. (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_43763}{Creating 3D Annotations}.)


\subsection{Dynamically adding text to PDF documents}
\label{\detokenize{index:dynamically-adding-text-to-pdf-documents}}
You can use the Acrobat core API or the PDF Library API to dynamically modify a PDF document. For example, a plugin or PDF Library application can retrieve data from an enterprise database and insert the data into a PDF document. (See \sphinxhref{Plugins\_Insertext.html\#50618411\_44849}{Inserting Text into PDF Documents}.)


\section{Understanding your target application}
\label{\detokenize{index:understanding-your-target-application}}
Both Acrobat and Adobe Reader accept plugins. Adobe Reader is designed predominantly for viewing and printing PDF documents. Acrobat Pro and Acrobat Pro Extended let you create PDF files, and offer advanced control over document exchange, review, and output. Acrobat Standard also lets you create PDF files and exchange and review comments.


\subsection{Rights\sphinxhyphen{}enabled PDF documents}
\label{\detokenize{index:rights-enabled-pdf-documents}}
PDF documents that are \sphinxstyleemphasis{rights\sphinxhyphen{}enabled} can access specific functionality in Adobe Reader that would otherwise be unavailable. When a PDF document is rights\sphinxhyphen{}enabled, additional APIs become available for plugin development.


\subsection{Adobe Reader plugins}
\label{\detokenize{index:adobe-reader-plugins}}
Adobe Reader only accepts Reader\sphinxhyphen{}enabled plugins. (See \sphinxhref{Plugins\_ReaderPlug.html\#50618405\_11144}{Creating an Adobe Reader plugin}.)

You may want your Reader\sphinxhyphen{}enabled plugin to access APIs that are available when the plugin is running with Acrobat but not when running with Adobe Reader. Use the \sphinxcode{\sphinxupquote{ASGetConfiguration}} method to check whether Acrobat or Adobe Reader is running, and invoke these APIs only if your plugin is running with Acrobat. Failure to do so exposes the user to a variety of error messages. You can display a message to the user by invoking the \sphinxcode{\sphinxupquote{AVAlertNote}} method. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

If Adobe Reader attempts to load a plugin that is not Reader\sphinxhyphen{}enabled, Adobe Reader notifies the user that the plugin cannot function fully and then proceeds in one of these ways:
\begin{itemize}
\item {} 
Does not load the plugin.

\item {} 
Omits toolbar buttons and menu items that enable editing.

\item {} 
Displays dimmed toolbar buttons and menu items that enable editing.

\end{itemize}

Plugins that need to check whether or not they are running under Adobe Reader should do so as early in initialization as possible. Plugins that create and manipulate custom annotations should allow their annotations to be displayed (they cannot be created, deleted, or edited) when running under Adobe Reader.


\section{Registering plugins for use by the plugin finder}
\label{\detokenize{index:registering-plugins-for-use-by-the-plugin-finder}}
You can register your plugin with Adobe to ensure that users are prompted to download and install it when they open PDF documents that require it.

Registering your plugin means that Adobe adds information about your plugin to a list of registered plugins. Each entry in this list associates a PDF dictionary extension and other characteristics with a URL from which users can download and install the plugin that processes that extension. Acrobat and Adobe Reader access the list over the web. The list is not publicly displayed on adobe.com. That is, it cannot be used to advertise the availability of your plugins. If you wish to post on adobe.com information about your plugin, see your Adobe representative.


\subsection{PDF dictionary extensions}
\label{\detokenize{index:pdf-dictionary-extensions}}
PDF documents can include dictionaries that are extensions to the current PDF specification. Such dictionary extensions have names of the form \sphinxcode{\sphinxupquote{prefix\_propertyName}} that associate it with a particular plug\sphinxhyphen{}in developer.

To avoid collisions over company names and company\sphinxhyphen{}specific extension names, Adobe (on behalf of ISO) maintains a prefix name registry. This registry is used to designate a 4\sphinxhyphen{}character, case\sphinxhyphen{}sensitive prefix that identifies a company or other entity. This prefix is used to create second\sphinxhyphen{}class names (dictionary or property names) of the form \sphinxcode{\sphinxupquote{MYCO\_aPropertyName}}.


\chapter{Understanding Plugins}
\label{\detokenize{Plugins_Pimech:understanding-plugins}}\label{\detokenize{Plugins_Pimech::doc}}

\section{Plugin loading and initialization}
\label{\detokenize{Plugins_Pimech:plugin-loading-and-initialization}}
When Acrobat or Adobe Reader is started, it searches the plugins directory (co\sphinxhyphen{}located with the Acrobat executable) to locate and load plugins. In addition, Acrobat or Adobe Reader searches folders that may be located within this folder. This search goes one level deep.

Acrobat and Adobe Reader display a progress message in the bottom line of the splash screen at start\sphinxhyphen{}up. As each plugin is loaded, the progress message shows the plugin name. No plugins are loaded if the Shift key is held down while Acrobat or Adobe Reader start. Also, if Acrobat or Adobe Reader are running in certified mode, no third\sphinxhyphen{}party plugins are loaded.

When creating methods for your plugin, keep the following rule in mind:

Implement \sphinxcode{\sphinxupquote{PluginUnload}} procedure: This procedure frees allocated memory. This routine is invoked if any of the initialization routines returns \sphinxcode{\sphinxupquote{false}}. Under normal conditions, this procedure is not invoked until the user closes Acrobat or Adobe Reader.


\subsection{Handshaking}
\label{\detokenize{Plugins_Pimech:handshaking}}
Acrobat and Adobe Reader perform a handshake with each plugin as it is opened and loaded. During handshaking, the plugin specifies its name, several initialization procedures, and an optional unload procedure.

A plugin must implement the following handshaking function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PIHandshake}\PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{handshakeVersion}\PYG{p}{,} \PYG{n}{void}\PYG{p}{,} \PYG{o}{*}\PYG{n}{hsData}\PYG{p}{)}
\end{sphinxVerbatim}

During handshaking, the plugin receives the \sphinxcode{\sphinxupquote{hsData}} data structure (defined in the PIVersn.h file). Acrobat and Adobe Reader convert all function pointers that are passed in this data structure into callbacks using the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} method. For information about this method, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

The DUCallbacks.h header file declares all callback methods that must be located in your plugin. The following shows the function signatures of these callback methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginExportHFTs}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginImportReplaceAndRegister}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginInit}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginUnload}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

All callbacks return \sphinxcode{\sphinxupquote{true}} if your plugin’s procedure completes successfully or if the callbacks are optional and are not implemented. If your plugin’s procedure fails, it returns \sphinxcode{\sphinxupquote{false}}. If either Acrobat, Adobe Reader, or a plug\sphinxhyphen{}in aborts handshaking, Acrobat or Adobe Reader displays an alert dialog box showing a brief explanation before loading other plugins. At minimum, a plugin must implement the \sphinxcode{\sphinxupquote{PluginInit}} callback.

To ensure your plugin does not hinder Acrobat startup, you must limit code executed in your handshake functions to the minimum.

\begin{sphinxadmonition}{note}{Note:}
The handshaking function is located in the PIMain.c file. This source code located in this file is functional and must not be modified.
\end{sphinxadmonition}

The following example shows how a plugin’s \sphinxcode{\sphinxupquote{PIHandshake}} method specifies the plugin callbacks provided during handshake and initialization. The tasks performed by each function is described in the next sections. For general information about creating callback functions, see \sphinxhref{Plugins\_Pimech.html\#50618406\_20671}{Using callback functions}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PIHandshake}\PYG{p}{(}\PYG{n}{Uns32} \PYG{n}{handshakeVersion}\PYG{p}{,} \PYG{n}{void} \PYG{o}{*}\PYG{n}{handshakeData}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{handshakeVersion} \PYG{o}{==} \PYG{n}{HANDSHAKE\PYGZus{}V0200}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
      \PYG{n}{PIHandshakeData\PYGZus{}V0200} \PYG{o}{*}\PYG{n}{hsData} \PYG{o}{=} \PYG{p}{(}\PYG{n}{PIHandshakeData\PYGZus{}V0200} \PYG{o}{*}\PYG{p}{)}\PYG{n}{handshakeData}\PYG{p}{;}
      \PYG{n}{hsData}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{extensionName} \PYG{o}{=} \PYG{n}{GetExtensionName}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{hsData}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{exportHFTsCallback} \PYG{o}{=}
          \PYG{p}{(}\PYG{n}{void}\PYG{o}{*}\PYG{p}{)}\PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{PIExportHFTsProcType}\PYG{p}{,}
              \PYG{o}{\PYGZam{}}\PYG{n}{PluginExportHFTs}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{hsData}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{importReplaceAndRegisterCallback} \PYG{o}{=}
          \PYG{p}{(}\PYG{n}{void}\PYG{o}{*}\PYG{p}{)}\PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{PIImportReplaceAndRegisterProcType}\PYG{p}{,}
              \PYG{o}{\PYGZam{}}\PYG{n}{PluginImportReplaceAndRegister}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{hsData}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{initCallback} \PYG{o}{=}
          \PYG{p}{(}\PYG{n}{void}\PYG{o}{*}\PYG{p}{)}\PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{PIInitProcType}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{PluginLoad}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{hsData}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{unloadCallback} \PYG{o}{=}
          \PYG{p}{(}\PYG{n}{void}\PYG{o}{*}\PYG{p}{)}\PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{PIUnloadProcType}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{PluginUnload}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Exporting HFTs}
\label{\detokenize{Plugins_Pimech:exporting-hfts}}
A Host Function Table (HFT) is the mechanism through which plugins invoke methods in Adobe Reader or Acrobat, as well as in other plugins. After Acrobat finishes handshaking with all the plugins, it invokes each plug\sphinxhyphen{}in’s \sphinxcode{\sphinxupquote{PluginExportHFTs}} callback procedure.

In the \sphinxcode{\sphinxupquote{PluginExportHFTs}} procedure, a plugin may export any HFTs it intends to make available to other plugins. This callback should only export an HFT, not invoke other Acrobat core API methods. (See \sphinxhref{Plugins\_Hft.html\#50618412\_37928}{Working with Host Function Tables}.)

\begin{sphinxadmonition}{note}{Note:}
The only time a plugin can export an HFT is during execution of its \sphinxcode{\sphinxupquote{PluginExportHFTs}} procedure.
\end{sphinxadmonition}


\subsection{Importing HFTs and registering for notifications}
\label{\detokenize{Plugins_Pimech:importing-hfts-and-registering-for-notifications}}
After Acrobat or Adobe Reader completes invoking each plugin’s \sphinxcode{\sphinxupquote{PluginExportHFTs}} callback method, it invokes each plugin’s \sphinxcode{\sphinxupquote{PluginImportReplaceAndRegister}} callback method. In this method, plugins perform three tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Import any special HFTs they use (the standard Acrobat HFTs are automatically imported). Plugins also may import HFTs any time after this while the plugin is running.

\item {} 
Register for notifications by using the \sphinxcode{\sphinxupquote{AVAppRegisterNotification}} method. Plugins also may register and unregister for notifications while the plugin is running. A plugin may receive a notification any time after it has registered for it, even if the plugin’s initialization callback has not yet been called. This can occur if another plugin initializes first and performs an operation, such as creating a PDF document, which causes a notification to be sent. Plugins must be prepared to correctly handle notifications as soon as they register for them.

\item {} 
Replace any of the Acrobat API’s replaceable HFT methods. (See \sphinxhref{Plugins\_Hft.html\#50618412\_19489}{Replacing HFT methods}.)

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
The only time a plugin may import an HFT or replace a standard API method is within its \sphinxcode{\sphinxupquote{PluginExportHFTs}} callback procedure. Plugins may register for notifications at this time or any time afterward.
\end{sphinxadmonition}


\subsection{Initialization}
\label{\detokenize{Plugins_Pimech:initialization}}
After Acrobat or Adobe Reader completes calling each plugin’s \sphinxcode{\sphinxupquote{PluginImportReplaceAndRegister}} callback method, it invokes each plugin’s \sphinxcode{\sphinxupquote{PluginInit}} procedure. Plugins can use their initialization procedures to hook into Acrobat’s user interface by adding menu items, toolbar buttons, windows, and so on. It is also acceptable to modify Acrobat’s user interface later when the plugin is running.

When creating the initialization portion of a plugin, keep the following rules in mind:

\sphinxstylestrong{Avoid creating dialog boxes:} Do not create a dialog box in your plugin’s initialization or do anything else that may interfere with the successful startup of Acrobat or Adobe Reader. The application may be started by using an interapplication communication (IAC) event, in which case a user would not be present to respond to your dialog box.

\sphinxstylestrong{Avoid invoking methods that cause Acrobat to load non\sphinxhyphen{}critical components:} Here are actions your plugin should avoid, listed in order of importance:
\begin{itemize}
\item {} 
Avoid invoking JavaScript, which loads the EScript plugin and starts the JavaScript engine.

\item {} 
Avoid invoking functions referenced from HFTs exported by Adobe plugins. Adobe plugins are not fully initialized until they are invoked or otherwise triggered.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Non\sphinxhyphen{}Adobe plugins are fully initialized during Acrobat startup. Invoking functions declared in HFTs exported by non\sphinxhyphen{}Adobe plugins will not significantly delay Acrobat startup, unless those plugins violate the principles listed here.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
Avoid invoking system methods that load more system libraries, such as accessing the disk.

\end{itemize}

\sphinxstylestrong{Do create your menu items}: Creating your menu items during initialization ensures that your menu items will be available in any PDF document opened using Acrobat or Adobe Reader.

If your plugin must carry out a task after all plugins are initialized, it should register for the \sphinxcode{\sphinxupquote{AVAppDidInitialize}} notification. This notification is invoked when Acrobat finishes initializing and is about to enter its event loop.


\subsection{Unloading}
\label{\detokenize{Plugins_Pimech:unloading}}
A plugin’s \sphinxcode{\sphinxupquote{PluginUnload}} procedure should free any memory the plugin allocated and remove any user interface changes it made. Acrobat invokes this procedure when it terminates or when any of the other handshaking callbacks return \sphinxcode{\sphinxupquote{false}}. This function should perform the following tasks:
\begin{itemize}
\item {} 
Remove and release all menu items and other user interface elements, HFTs, and HFTServers.

\item {} 
Release any memory or any other allocated resources.

\end{itemize}

Currently, plugins unload only when Acrobat exits.


\subsection{Summarizing a plugin’s life cycle}
\label{\detokenize{Plugins_Pimech:summarizing-a-plugin-s-life-cycle}}
The following steps describe the life cycle of a plugin:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
At startup, Adobe Reader or Acrobat searches its plugin directory for plugin files.

\item {} 
For each plugin file, Adobe Reader or Acrobat attempts to load the file. If the plugin is successfully loaded, Adobe Reader or Acrobat invokes routines in PIMain.c that complete the handshaking process.

\item {} 
Adobe Reader or Acrobat invokes callback functions in this order:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{PluginExportHFTs}}

\item {} 
\sphinxcode{\sphinxupquote{PluginImportReplaceAndRegister}}

\item {} 
\sphinxcode{\sphinxupquote{PluginInit}}

\end{itemize}

\end{enumerate}

This sequence establishes the linkages between the plugin and Acrobat or Adobe Reader, and between the plugin and any other plugins. After all plugins are loaded, Acrobat or Adobe Reader continues its own loading and starts the user interface. It adds plugin tools to the toolbar, and plugin menu items to the menu bar. Then it starts the user session.


\section{Using callback functions}
\label{\detokenize{Plugins_Pimech:using-callback-functions}}
Acrobat or Adobe Reader invokes callback functions that you define to perform a specific task. For example, when a user clicks a button located on a toolbar, a callback method is invoked. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_31936}{Creating toolbar button callback functions}.)

To create a callback function, you can invoke the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}}, \sphinxcode{\sphinxupquote{ASCallbackCreateReplacement}}, and \sphinxcode{\sphinxupquote{ASCallbackCreateNotification}} methods to convert functions into callback functions and to perform type checking. This enables the compiler to determine whether the correct prototypes are used for a specific callback function. For information about these methods, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

Type checking only occurs if the \sphinxcode{\sphinxupquote{DEBUG}} macro is set to 1 at the time your plug\sphinxhyphen{}in is compiled. Be sure to set it appropriately in your development environment and remove it when you build the shipping version of your plugin.

The following code example shows the syntax to create a callback function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVExecuteProc} \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{ExecProcPtr}\PYG{o}{=} \PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{AVExecuteProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ShowMessage}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro returns a callback of the specified type that invokes the user\sphinxhyphen{}defined function whose address is passed as the second argument. In this example, the \sphinxcode{\sphinxupquote{ShowMessage}} function is converted to a callback function (the \sphinxcode{\sphinxupquote{ShowMessage}} function is a user\sphinxhyphen{}defined function that is invoked when a specific action occurs).

The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro returns a pointer to a function that can be invoked by a plugin or by Acrobat or Adobe Reader. Use the \sphinxcode{\sphinxupquote{ASCallbackDestroy}} method to dispose of a callback that is no longer required.

All callbacks must be declared with Pascal calling conventions. To make your code portable between platforms, declare all your callback functions using the \sphinxcode{\sphinxupquote{ACCB1}} and \sphinxcode{\sphinxupquote{ACCB2}} macros:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{ACCB1} \PYG{n}{const} \PYG{n}{char}\PYG{o}{*} \PYG{n}{ACCB2} \PYG{n}{ShowMessage}\PYG{p}{(}\PYG{n}{Thing}\PYG{o}{*} \PYG{n}{foo}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Notifications}
\label{\detokenize{Plugins_Pimech:notifications}}
The Acrobat core API provides a notification mechanism so that plugins can synchronize their actions with Acrobat or Adobe Reader. Notifications enable a plugin to indicate that it has an interest in a specified event, such as an annotation being modified, and to provide a procedure that Acrobat invokes each time that event occurs. (See \sphinxhref{Plugins\_Notification.html\#50618408\_14583}{Registering for Event Notifications}.)


\section{Handling events}
\label{\detokenize{Plugins_Pimech:handling-events}}
You can use the Acrobat core API to handle various types of events.


\subsection{Mouse clicks}
\label{\detokenize{Plugins_Pimech:mouse-clicks}}
Mouse clicks are passed to any procedure registered using the \sphinxcode{\sphinxupquote{AVAppRegisterForPageViewClicks}} method. If all of those procedures return \sphinxcode{\sphinxupquote{false}}, the click is passed to the active tool. If that returns \sphinxcode{\sphinxupquote{false}}, the click is passed to any annotation at the current location.

You can query the state of the mouse buttons in a manner appropriate for drag operations by invoking the \sphinxcode{\sphinxupquote{AVSysTrackMouse}} method. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)


\subsection{Adjust cursor}
\label{\detokenize{Plugins_Pimech:adjust-cursor}}
Adjust cursor events are passed to any procedures registered using the \sphinxcode{\sphinxupquote{AVAppRegisterForPageViewAdjustCursor}} method. If all of those procedures return \sphinxcode{\sphinxupquote{false}}, the event is passed to the active tool. If that returns \sphinxcode{\sphinxupquote{false}}, the event is passed to any annotation at the current location.


\subsection{Key presses}
\label{\detokenize{Plugins_Pimech:key-presses}}
Key presses are first passed to the currently active selection server. If the selection server’s \sphinxcode{\sphinxupquote{AVDocSelectionKeyDownProc}} callback returns \sphinxcode{\sphinxupquote{false}}, Acrobat or Adobe Reader handles special keys (Esc, Page Up, Page Down) or uses the key to select a tool from the toolbar.


\section{Using plugin prefixes}
\label{\detokenize{Plugins_Pimech:using-plugin-prefixes}}
It is important to correctly name all items located in your plugin, such as HFTs, menus, toolbars, and so on, to ensure they function properly. Failure to do so may cause your plugin to produce unpredictable results when your plugin collides with a plugin of another developer who used the same names.

Prevent spaces from being used in tokens you intend to use as names in a PDF file. This can happen, for example, if you allow a user to type a name into the PDF file and your plugin does not check the input before writing it to the file.


\subsection{Obtaining a developer PDF name prefix}
\label{\detokenize{Plugins_Pimech:obtaining-a-developer-pdf-name-prefix}}
In support of ISO 32000, Adobe maintains a list of the prefixes of second class names for PDF. It is freely open to all developers and organizations following the specifications given in Annex E of ISO 32000. For example, Adobe uses ADBE or Acro. This chapter uses ADBE in the examples. Your plugins will use your unique PDF name. Register your name at \sphinxurl{https://github.com/adobe/pdf-names-list}.

\begin{sphinxadmonition}{note}{Note:}
Registering a PDF name ensures that you name is unique. It is up to you to ensure that names are unique among all plugins you or your company write (for example, you must ensure that two of your plugins do not both use ADBE\_save as a menu item name).
\end{sphinxadmonition}


\subsection{Using a developer prefix}
\label{\detokenize{Plugins_Pimech:using-a-developer-prefix}}
Every plugin must use the prefix to name its various elements as well as private data it writes into PDF documents. The following sections describe and provide an example of each element that must use a prefix.


\subsubsection{Plugin name}
\label{\detokenize{Plugins_Pimech:plugin-name}}
\sphinxcode{\sphinxupquote{ExtensionName}}, used in plugin handshaking, must use the following syntax: \sphinxcode{\sphinxupquote{Prefix\_PluginName}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hsData}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{extensionName} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE\PYGZus{}SuperCrop}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Menu prefixes}
\label{\detokenize{Plugins_Pimech:menu-prefixes}}
Menu names must use the following syntax: \sphinxcode{\sphinxupquote{Prefix:MenuName}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SuperCropMenu} \PYG{o}{=} \PYG{n}{AVMenuNew}\PYG{p}{(}\PYG{n}{SuperCrop}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:SuperCropMenu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For information about invoking the \sphinxcode{\sphinxupquote{AVMenuNew}} method, see \sphinxhref{Plugins\_Menu.html\#50618409\_63428}{Adding menu commands to menus}.


\subsubsection{Menu items prefixes}
\label{\detokenize{Plugins_Pimech:menu-items-prefixes}}
Menu item names must use the following syntax: \sphinxcode{\sphinxupquote{Prefix:MenuItem}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SelSuperCropTool} \PYG{o}{=} \PYG{n}{AVMenuItemNew}\PYG{p}{(}\PYG{n}{SuperCrop}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:SuperCropMItem}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,}
 \PYG{n}{false}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{AV\PYGZus{}OPTION}\PYG{p}{,} \PYG{n}{SuperCropIcon}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Tool prefixes}
\label{\detokenize{Plugins_Pimech:tool-prefixes}}
Tools names must use the following syntax: \sphinxcode{\sphinxupquote{Prefix:Tool}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{ACCB1} \PYG{n}{ASAtom} \PYG{n}{ACCB2} \PYG{n}{SuperCropToolGetType}\PYG{p}{(}\PYG{n}{AVTool} \PYG{n}{tool}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
     \PYG{k}{return} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:SuperCropTool}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Toolbar button prefixes}
\label{\detokenize{Plugins_Pimech:toolbar-button-prefixes}}
Toolbar buttons must use the following syntax: \sphinxcode{\sphinxupquote{Prefix:ToolbarButton}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{myButton} \PYG{o}{=} \PYG{n}{AVToolButtonNew}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:HelloWorld}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{void} \PYG{o}{*}\PYG{p}{)}
 \PYG{n}{myBM}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For information about creating a toolbar button, see \sphinxhref{Plugins\_Toolbutton.html\#50618403\_92880}{Creating toolbar buttons}.


\subsubsection{Private data ID’d via second\sphinxhyphen{}class names}
\label{\detokenize{Plugins_Pimech:private-data-id-d-via-second-class-names}}
If you add private data to keys defined in a Cos dictionary and you want the document to be readable to others outside your company, you must identify the data using second\sphinxhyphen{}class names. Such key names use the syntax Prefix\_PrivateDataName, where Prefix identifies the company or other entity that introduces the key, and PrivateDataName identifies the data.

When adding keys that are directly referenced from private keys, it is not necessary to use the developer prefix. In the following example, the keys named \sphinxcode{\sphinxupquote{First}} and \sphinxcode{\sphinxupquote{Second}} cannot be referenced from any object in the PDF file except the private key that uses an appropriate prefix. Therefore, there is no need to use a prefix for the latter two keys.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{n}{ACME\PYGZus{}aName} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{o}{/}\PYG{n}{First} \PYG{l+m+mi}{2} \PYG{o}{/}\PYG{n}{Second} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{o}{/}\PYG{n}{Third} \PYG{p}{[} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{p}{]} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{o}{\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For information about Cos dictionaries, such as the one shown in the previous example, see \sphinxhref{Plugins\_Cos.html\#50618418\_96656}{Working with Cos dictionaries}.
\end{sphinxadmonition}


\subsubsection{Action prefixes}
\label{\detokenize{Plugins_Pimech:action-prefixes}}
Actions must use the following syntax: \sphinxcode{\sphinxupquote{Prefix\_ActionName}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVAppRegisterActionHandler}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{BkmkHandler}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE\PYGZus{}HWAction}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HWAct}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Annotation prefixes}
\label{\detokenize{Plugins_Pimech:annotation-prefixes}}
Annotation prefixes must use the following syntax: \sphinxcode{\sphinxupquote{Prefix\_AnnotType}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{return}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE\PYGZus{}MarkUpAnnot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{HFT prefixes}
\label{\detokenize{Plugins_Pimech:hft-prefixes}}
When your plugin exposes any HFTs of its own, it must use an HFT name that conforms to the following syntax: \sphinxcode{\sphinxupquote{Prefix\_HFTName}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gDebuggWinHFTServer} \PYG{o}{=}
 \PYG{n}{HFTServerNew}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE\PYGZus{}DebugWin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{provideDebugWinHFTCallback}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For information about HFTs, see \sphinxhref{Plugins\_Hft.html\#50618412\_37928}{Working with Host Function Tables}.


\section{Modifying the Acrobat or Adobe Reader user interface}
\label{\detokenize{Plugins_Pimech:modifying-the-acrobat-or-adobe-reader-user-interface}}
This section describes typical operations that a plugin can perform to modify the Acrobat or Adobe Reader user interface. To modify the user interface, you must invoke methods that belong to the Acrobat Viewer Layer. As a result, you cannot modify the Acrobat or Adobe Reader user interface by using the PDF Library API. (See \sphinxhref{Plugins\_Introduction.html\#50618410\_82715}{Acrobat Viewer layer}.)


\subsection{Adding or removing menus and menu items}
\label{\detokenize{Plugins_Pimech:adding-or-removing-menus-and-menu-items}}
You can use the Acrobat core API to add new menus and add commands to existing menus. You can also remove a menu or a menu command.

Menu commands can have shortcuts (keyboard accelerators). Acrobat and Adobe Reader do not ensure that plugins add unique shortcuts, but it is possible to programmatic\sphinxhyphen{}ally check which shortcuts are already in use before adding them.

You are encouraged to have your plugin add its menu commands to the Tools menu. When the plugin starts, Acrobat or Adobe Reader automatically adds this menu, as well as the About Plugins and Plugin Help menus. After Acrobat or Adobe Reader loads all plugins, it checks these three menus and removes any that are empty. (See \sphinxhref{Plugins\_Menu.html\#50618409\_98126}{Creating Menus and Menu Commands}.)


\subsection{Modifying toolbars}
\label{\detokenize{Plugins_Pimech:modifying-toolbars}}
You can add new buttons to the toolbar, although the size and resolution of the user’s monitor can limit the number of tool buttons that are displayed. You can also remove buttons from an existing toolbar. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_37598}{Creating Toolbars and Buttons}.)


\subsection{Controlling the About box and splash screen}
\label{\detokenize{Plugins_Pimech:controlling-the-about-box-and-splash-screen}}
You can set values in the preferences file by invoking the \sphinxcode{\sphinxupquote{AVAppSetPreference}} method to prevent the Acrobat or Adobe Reader About box or splash screen from appearing before displaying the first document. These changes take effect the next time Acrobat or Adobe Reader is started.

About Adobe Plugins is a standard menu command in the Help menu. This menu command contains a submenu. You are encouraged to have your plugin add a menu command to the submenu to bring up its own About box.


\subsection{Creating help files}
\label{\detokenize{Plugins_Pimech:creating-help-files}}
The Help directory that accompanies Acrobat or Adobe Reader provides a standard location for your plug\sphinxhyphen{}in help files. You can place a help file either in the Help directory or in a subdirectory of the Help directory. If, for example, your plugin is localized for Japanese, you may want to place its Japanese help file in a Help\_JPN subdirectory. To help open locale\sphinxhyphen{}specific help files, the Acrobat core API provides the \sphinxcode{\sphinxupquote{AVAppOpenHelpFile}} method. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)


\subsection{User interface guidelines}
\label{\detokenize{Plugins_Pimech:user-interface-guidelines}}
Follow these guidelines when modifying the Acrobat or Adobe Reader user interface:
\begin{itemize}
\item {} 
During time\sphinxhyphen{}consuming operations, provide feedback to the user by using features such as progress monitors, cancel button, hourglass cursor, or status dialog boxes.

\item {} 
If you are adding an authoring tool to a toolbar, make it ignore all annotation types except your own. This way a link or thread will not interfere with the use of your tool. Navigation and selection tools should not ignore annotations. In Acrobat, for example, the Hand, Zoom, and selection tools all follow links. If the user holds down the Shift key, these tools will ignore annotations. All other tools, however, will ignore annotations that are not of the type authored by the tool.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{AVToolBarIsRoomFor}} method to determine if there is room on the toolbar to accommodate a new button. If there is not sufficient room, then do not attach the button to the toolbar. Because space is limited, add a menu command for each button you add to a toolbar. This provides a way for users to access a plugin’s functionality, and also enables users to access functionality by using a shortcut key (if the menu command contains one).

\end{itemize}


\section{Acquiring and releasing objects}
\label{\detokenize{Plugins_Pimech:acquiring-and-releasing-objects}}
Ensure that calls to \sphinxcode{\sphinxupquote{Acquire}} and \sphinxcode{\sphinxupquote{Release}} methods match. Objects obtained by \sphinxcode{\sphinxupquote{Acquire}} methods must ultimately be released. If they are not released, Acrobat or Adobe Reader raises exceptions when a non\sphinxhyphen{}zero reference count is discovered. An exception can occur when Acrobat or Adobe Reader quits or when a document is closed.

When allocating memory to objects, follow these guidelines:
\begin{itemize}
\item {} 
Use \sphinxcode{\sphinxupquote{ASmalloc}} and \sphinxcode{\sphinxupquote{ASfree}} instead of \sphinxcode{\sphinxupquote{malloc}} and \sphinxcode{\sphinxupquote{free}}, or you risk memory leaks.

\item {} 
Ensure that \sphinxcode{\sphinxupquote{ASmalloc}} and \sphinxcode{\sphinxupquote{ASfree}} pairs match or you will create memory leaks.

\item {} 
Use \sphinxcode{\sphinxupquote{ASmalloc}} to allocate memory for methods that state that Acrobat or Adobe Reader free the memory for you.

\item {} 
It is best to have your C++ classes derive from a base class which overrides \sphinxcode{\sphinxupquote{new}}, such as the class \sphinxcode{\sphinxupquote{CSafeAlloc}}, found in SafeAlloc.h.

\end{itemize}

If you use an \sphinxcode{\sphinxupquote{Acquire}} method to obtain an object, you must subsequently use a \sphinxcode{\sphinxupquote{Release}} method to correctly update the reference counter, as shown in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDDoc} \PYG{n}{doc}\PYG{p}{;}
\PYG{n}{PDPage} \PYG{n}{page}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Acquire} \PYG{n}{a} \PYG{n}{page} \PYG{k+kn}{from} \PYG{n+nn}{a} \PYG{n}{PDF} \PYG{n}{document}
\PYG{n}{doc} \PYG{o}{=} \PYG{n}{PDDocOpenFromASFile}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myPDF.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{null}\PYG{p}{,} \PYG{n}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{page} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{doc}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Perform} \PYG{n}{a} \PYG{n}{task} \PYG{n}{using} \PYG{n}{the} \PYG{n}{page}
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Release} \PYG{n}{the} \PYG{n}{page}
\PYG{n}{PDPageRelease} \PYG{p}{(}\PYG{n}{page}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Notice that the \sphinxcode{\sphinxupquote{PDPage}} object is acquired by invoking the \sphinxcode{\sphinxupquote{PDDocAcquirePage}} method and is released by invoking the \sphinxcode{\sphinxupquote{PDPageRelease}} method. For information about working with pages, see \sphinxhref{Plugins\_Pages.html\#50618407\_48762}{Working with Page Views and Contents}.


\section{Debugging plugins}
\label{\detokenize{Plugins_Pimech:debugging-plugins}}
When debugging your plugin, consider the following points:
\begin{itemize}
\item {} 
Include the \sphinxcode{\sphinxupquote{\#define DEBUG 1}} statement to ensure that parameter type checking is performed by macros such as \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} and to enable the debug exception\sphinxhyphen{}handling macros.

\item {} 
The \sphinxcode{\sphinxupquote{AVSysBeep}} method provides a simple way to add an audible indication that a certain point has been reached in a plugin’s code. Likewise, the \sphinxcode{\sphinxupquote{AVAlertNote}} method displays a message box that indicates whether a certain point of code is reached.

\item {} 
Creating a log file is very helpful when tracing large sections of code or checking values of a number of variables. Use C library calls such as \sphinxcode{\sphinxupquote{printf}} or platform\sphinxhyphen{}specific code to create a log file containing whatever information is useful for the particular situation.

\end{itemize}


\section{Page view layers}
\label{\detokenize{Plugins_Pimech:page-view-layers}}
Acrobat and Adobe Reader drawing and mouse click processing rely on the concept of page view layers, which are numbers of type \sphinxcode{\sphinxupquote{ASFixed}} that are associated with the document itself and each annotation type.

The following table shows the predefined layers used by Acrobat and Adobe Reader.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Layer
&\sphinxstyletheadfamily 
Item
\\
\hline
0
&
Page contents
\\
\hline
LINK\_LAYER (1)
&
Links
\\
\hline
NOTE\_LAYER (3)
&
Annotations, open and closed. Open annotations are drawn above closed annotations.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

These layers are used in the following situations:

\sphinxstylestrong{Drawing}: The layers are drawn from lowest to highest. As indicated in the table, the page contents are drawn first, followed by links, closed annotations, and finally open annotations. As a result, open annotations are drawn over any closed annotations that they overlap.

\sphinxstylestrong{Mouse click processing}: Occurs from highest layer to lowest layer. When a mouse click occurs, it is first passed to any open text note at the mouse click’s location, then any closed text note, then any link, and finally to the page view itself. However, mouse clicks are passed to a lower layer only if a higher layer declines to handle the mouse click by returning \sphinxcode{\sphinxupquote{false}} from its \sphinxcode{\sphinxupquote{DoClick}} callback. (See \sphinxhref{Plugins\_Handlers.html\#50618413\_51937}{Tool callbacks}.)

Annotation handlers provided by plugins can reside in any layer. For example, a plugin could choose for its annotations to be between the page contents and links, such as in layer 0.5 (because layers are numbers of type \sphinxcode{\sphinxupquote{ASFixed}} ).

An annotation handler’s \sphinxcode{\sphinxupquote{AVAnnotHandlerGetLayerProc}} callback is called during screen updates and mouse clicks to return its layer. Using a callback rather than a constant value allows an annotation’s layer to change. For example, Acrobat’s built\sphinxhyphen{}in text annotation changes its layer, allowing open text annotations to receive mouse clicks before closed annotations, if both are at the mouse click location (on the other hand, Acrobat’s built\sphinxhyphen{}in link annotation does not change its layer).

\begin{sphinxadmonition}{note}{Note:}
Acrobat and Adobe Reader do not invoke \sphinxcode{\sphinxupquote{AVAnnotHandlerGetLayerProc}} callbacks for changes in value, so be sure to invalidate the page rectangle of an annotation when its layer changes.
\end{sphinxadmonition}

For information about page views, see \sphinxhref{Plugins\_Pages.html\#50618407\_48762}{Working with Page Views and Contents}.


\section{Minimizing screen redrawing}
\label{\detokenize{Plugins_Pimech:minimizing-screen-redrawing}}
Minimize screen redrawing by using the \sphinxcode{\sphinxupquote{AVPageViewBeginOperation}} and \sphinxcode{\sphinxupquote{AVPageViewEndOperation}} methods to bracket any sequence of view changes you may perform. For example, the sequence of changing to another page, scrolling, and zooming would normally redraw the screen three times. But, by invoking the \sphinxcode{\sphinxupquote{AVPageViewBeginOperation}} method before the sequence and the \sphinxcode{\sphinxupquote{AVPageViewEndOperation}} method after it, only one redraw occurs.


\section{Storing private data in PDF files}
\label{\detokenize{Plugins_Pimech:storing-private-data-in-pdf-files}}
Plugins can store private data in PDF files, although private data must be stored in such a way that the file can still be drawn by Acrobat. Adobe maintains a registry of private PDF dictionary key names to reduce the possibility of a plugin’s key names conflicting with names belonging to other plugins. For information about dictionaries, see \sphinxhref{Plugins\_Cos.html\#50618418\_96656}{Working with Cos dictionaries}.

Private dictionary keys exist in the following categories:
\begin{itemize}
\item {} 
Specific keys that are proposed by third parties but are generally useful. Adobe maintains a registry of these names.

\item {} 
Keys registered by third parties as well as keys whose prefix is registered that are applicable only to a limited set of users. Adobe maintains a registry of these names and prefixes.

\item {} 
Keys that begin with a special prefix reserved by Adobe for private extensions. These keys are intended for use in files that are never seen by other third parties, since these keys may conflict with keys defined by others.

\end{itemize}


\section{Exporting data from PDF document objects}
\label{\detokenize{Plugins_Pimech:exporting-data-from-pdf-document-objects}}
Using the Acrobat core API, you can export data from PDF document objects to XML files. Object data contain property\sphinxhyphen{}value pairs. For example, consider a PDF document object that contains the following XML elements:


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{Plugins_Pimech:section-1}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Node
&\sphinxstyletheadfamily 
Name
\\
\hline
nodeTag
&
xyz\_Node
\\
\hline
nodeNameTag
&
xyz\_NodeName
\\
\hline
propTag
&
xyz\_Property
\\
\hline
propNameTag
&
xyz\_PropertyName
\\
\hline
propValTag
&
xyz\_Value
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

After you export the data from this object into an XML file, the data would appear as shown in the following diagram.

\noindent\sphinxincludegraphics{{ExtractXML}.png}

To retrieve data from a PDF document object, invoke the \sphinxcode{\sphinxupquote{PDDocExportUserProperties}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} object that represents a PDF document that contains the object from which data is extracted. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\item {} 
A \sphinxcode{\sphinxupquote{PDSElement}} instance that represents PDF structural elements.

\item {} 
An \sphinxcode{\sphinxupquote{ASStm}} object that represents XML content converted from information from labels.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether to save object data of the specified element (\sphinxcode{\sphinxupquote{false}} ) or the whole subtree (\sphinxcode{\sphinxupquote{true}} ).

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether to include hidden content of the element.

\item {} 
An instance of the \sphinxcode{\sphinxupquote{PDUserPropertiesXMLLabels}} data structure that specifies information for converting object data to XML. For information about this data structure, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\end{itemize}


\chapter{Creating Plugin and PDF Library Applications}
\label{\detokenize{Plugins_CreatingSimplePlug:creating-plugin-and-pdf-library-applications}}\label{\detokenize{Plugins_CreatingSimplePlug::doc}}
Use the Acrobat SDK and the Adobe PDF Library SDK to create plugin applications as well as stand\sphinxhyphen{}alone applications that interact with PDF documents.


\section{Working with platform\sphinxhyphen{}specific techniques}
\label{\detokenize{Plugins_CreatingSimplePlug:working-with-platform-specific-techniques}}
The Acrobat API is nearly platform\sphinxhyphen{}independent. By using the memory allocation and file system APIs provided by Acrobat or Adobe Reader, many parts of a plugin are highly portable across platforms. While this chapter contains platform\sphinxhyphen{}specific development information for Windows and Mac, the guidelines here should help you plugins more portable among the various supported platforms.


\subsection{About platform\sphinxhyphen{}dependent data}
\label{\detokenize{Plugins_CreatingSimplePlug:about-platform-dependent-data}}
The following are platform\sphinxhyphen{}specific data types that appear explicitly in the Acrobat core API:
\begin{itemize}
\item {} 
\sphinxstylestrong{platform data structures}: Data structures such as the Win32 data structure that represents a window.

\item {} 
\sphinxstylestrong{platform path values}: The data structure that represents the path to a file.

\item {} 
\sphinxstylestrong{platform event}: The data structure that represents mouse clicks, key presses, window activation, and so on.

\item {} 
\sphinxstylestrong{Return value}: Constants that indicate, for example, that a file could not be opened because it was not found.

\end{itemize}

The following are platform\sphinxhyphen{}specific data types that do not appear explicitly in the API, but are used by Acrobat, Adobe Reader, or plugins:
\begin{itemize}
\item {} 
\sphinxstylestrong{Cursors}: Data structures representing a cursor.

\item {} 
\sphinxstylestrong{Toolbar button icons}: Pixmaps that appear in the Acrobat or Adobe Reader toolbar.

\item {} 
\sphinxstylestrong{Menu item icons}: Icons that some platforms let you display adjacent to a menu item.

\item {} 
\sphinxstylestrong{Menu items}: Remember that not all Acrobat or Adobe Reader implementations have the same menu items.

\end{itemize}


\subsection{Portability techniques}
\label{\detokenize{Plugins_CreatingSimplePlug:portability-techniques}}
The following techniques can improve your plugin’s portability:
\begin{itemize}
\item {} 
Use predefined types instead of short and long.

\item {} 
Use Acrobat API methods wherever possible instead of platform\sphinxhyphen{}specific APIs.

\item {} 
Use \sphinxcode{\sphinxupquote{\#if}} around platform\sphinxhyphen{}specific code such as dialog boxes and use the predefined platform constants (\sphinxcode{\sphinxupquote{MAC\_PLATFORM}}, \sphinxcode{\sphinxupquote{WIN\_PLATFORM}}, and so forth) to test what platform you are compiling for.

\item {} 
Place platform\sphinxhyphen{}specific code in separate files from the main portion of the plugin, so that you can easily recognize and rewrite platform\sphinxhyphen{}dependent sections.

\end{itemize}


\subsection{Windows techniques}
\label{\detokenize{Plugins_CreatingSimplePlug:windows-techniques}}

\subsubsection{Developing Windows plugins}
\label{\detokenize{Plugins_CreatingSimplePlug:developing-windows-plugins}}
You can put your plugins in the default Acrobat plugin location the plugins folder (in the same directory as the Acrobat executable).

You are encouraged to use the plugin samples BasicUI and Starter as a basis for developing plugins. These samples have all of the appropriate project settings. The Starter sample only builds a loadable plugin while the BasicUI sample adds menu items.


\subsubsection{Locating and loading plugins}
\label{\detokenize{Plugins_CreatingSimplePlug:locating-and-loading-plugins}}
When Acrobat or Adobe Reader starts, it scans the plugins folder (in the same directory as the Acrobat executable) for DLLs with the extension.API. Acrobat or Adobe Reader also searches nested directories, allowing you to group plugins in folders. When it locates a file with the extension.API, it looks for the \sphinxcode{\sphinxupquote{PlugInMain}} exported symbol, which specifies the entry point for your plugin. Acrobat or Adobe Reader loads the plugin by invoking the \sphinxcode{\sphinxupquote{LoadLibrary}} function and then calls the function referenced by the \sphinxcode{\sphinxupquote{PlugInMain}} symbol.

The \sphinxcode{\sphinxupquote{LoadLibrary}} function calls your plugin’s \sphinxcode{\sphinxupquote{DLLMain}} entry point with the parameter \sphinxcode{\sphinxupquote{DLL\_PROCESS\_ATTACH}} passed. Your plugin can run some initialization code in DLLMain, such as allocating memory, before its \sphinxcode{\sphinxupquote{PluginMain}} function is called by Acrobat or Adobe Reader.

If you allocate memory in your plugin’s \sphinxcode{\sphinxupquote{DLLMain}} entry point, it must deallocate that memory when \sphinxcode{\sphinxupquote{DLLMain}} is called with \sphinxcode{\sphinxupquote{DLL\_PROCESS\_DETACH}}. If your plugin relies on its implementation of the \sphinxcode{\sphinxupquote{PluginUnload}} function to deallocate memory, it could fail if Acrobat or Adobe Reader unloads the plugin immediately without calling the plugin’s handshaking callbacks. This would happen in the following situations:
\begin{itemize}
\item {} 
If the plugin is not Adobe\sphinxhyphen{}certified and the user has specified the Certified Plugins Only option in the Preferences settings.

\item {} 
If the plugin is running under Adobe Reader, but it is not enabled for Adobe Reader. This could potentially cause a crash when Acrobat or Adobe Reader closes.

\end{itemize}


\subsubsection{Why a plugin might not load}
\label{\detokenize{Plugins_CreatingSimplePlug:why-a-plugin-might-not-load}}
There are several reasons why a plugin may not load successfully:
\begin{itemize}
\item {} 
The plugin’s filename extension was not changed from.dll to.api.

\item {} 
Too many plugins are being loaded by either Acrobat or Adobe Reader. The number of plugins that can be loaded at any one time depends on the code generation settings of all loaded plugins.

\item {} 
The plugin attempts to register with the same \sphinxcode{\sphinxupquote{extensionName}} as another plugin that has already loaded. In this case, Acrobat or Adobe Reader displays an error message indicating the problem.

\item {} 
You cloned your project from an existing plugin project that uses a.def file and forgot to change the \sphinxcode{\sphinxupquote{LIBRARY}} entry in the.def file.

\item {} 
The DLL is bad. This can occur even if the plugin compiled and linked without errors. Generally, rebuilding the plugin completely (doing a Rebuild All) solves the problem.

\end{itemize}


\subsubsection{Macros and project settings}
\label{\detokenize{Plugins_CreatingSimplePlug:macros-and-project-settings}}
The following macros must be defined or set in your preprocessor definitions:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{WIN\_ENV}}

\item {} 
\sphinxcode{\sphinxupquote{WIN\_PLATFORM (preferred)}}

\item {} 
\sphinxcode{\sphinxupquote{WIN32}}

\item {} 
\sphinxcode{\sphinxupquote{WINDOWS}}

\end{itemize}

For a plugin to be loaded, it must export the symbol \sphinxcode{\sphinxupquote{PlugInMain}}. This task can be accomplished by including a.def file in the project for the plugin or by including the line \sphinxcode{\sphinxupquote{/EXPORT:PlugInMain}} in the project settings for the plugin. If you are developing an Adobe Reader plugin, you also must define a macro to access HFTs available to Adobe Reader. (See \sphinxhref{Plugins\_ReaderPlug.html\#50618405\_11144}{Creating an Adobe Reader plugin}.)


\subsubsection{Interapplication communication}
\label{\detokenize{Plugins_CreatingSimplePlug:interapplication-communication}}
Plugins can add their own DDE messages to those supported by Acrobat or Adobe Reader by registering to receive DDE messages directly. The DDEClnt sample in the Acrobat SDK shows how to do this.

A plugin cannot implement OLE automation or be an ActiveX server through the use of MFC. This is because Acrobat or Adobe Reader uses MFC to implement its OLE automation and there cannot be two MFC\sphinxhyphen{}based OLE automation servers in the same process. OLE or ActiveX server plugins must be implemented using the ActiveX Template Library. Plugins should use the DDEML library to handle DDE messages. Problems may arise if they do not.


\subsubsection{Debugging}
\label{\detokenize{Plugins_CreatingSimplePlug:debugging}}
Generally, the debugger built into Visual C++ is adequate to debug plugins. Debugging a Windows plugin compiled with Visual C++ is quite simple if you remember a few things:
\begin{itemize}
\item {} 
Specify the Acrobat plugin directory under the link | output tab in the Project Settings dialog box.

\item {} 
Specify the Acrobat or Adobe Reader executable under the executable for debug session in the Project Settings dialog box.

\item {} 
The first time you build a plugin, do a Rebuild All.

\item {} 
Set breakpoints in your source code by selecting the line and clicking the hand icon or pressing the F9 key.

\item {} 
After setting breakpoints, press the F5 key to have Microsoft Visual Studio start Acrobat or Adobe Reader.

\end{itemize}

Two common reasons why breakpoints may not be hit are:
\begin{itemize}
\item {} 
You started Acrobat or Adobe Reader from the File Manager or Program Manager. Acrobat or Adobe Reader must be started from within Microsoft Visual Studio to debug plugins.

\item {} 
You copied your plugin into Acrobat’s plugin directory, instead of specifying the plugin directory in the Link | Output dialog box.

\end{itemize}


\subsubsection{Handling the thread local storage (TLS) limit}
\label{\detokenize{Plugins_CreatingSimplePlug:handling-the-thread-local-storage-tls-limit}}
There is a limit to the number of plugins that Acrobat or Adobe Reader can load at any given time. This is due to a limitation of the multi\sphinxhyphen{}threading model used by the Win32 API and is dependent on the code generation settings of the plugins being loaded.

The following information can help maximize the ability of Acrobat and Adobe Reader to load plugins.

When a process is created, an array of bit flags is allocated for the management of thread\sphinxhyphen{}specific data. In the current Win32 implementation, this array is limited to 64 members or TLS slots. Every DLL/plugin that uses thread local storage is allocated at least one slot when loaded using LoadLibrary. This includes system DLLs, plugins, and all the DLLs they load. When all of the TLS slots have been occupied for a process, LoadLibrary will fail for any DLL requiring a TLS slot.

The following guidelines will minimize the TLS slots occupied by plugins:
\begin{itemize}
\item {} 
Plugins that are not multi\sphinxhyphen{}threaded should only link with the single\sphinxhyphen{}threaded run\sphinxhyphen{}time libraries that do not occupy a TLS slot.

\item {} 
If your plugin is multi\sphinxhyphen{}threaded, consider linking it with the multi\sphinxhyphen{}threaded DLL run\sphinxhyphen{}time library. Both the DLL and static versions of the run\sphinxhyphen{}time libraries occupy a TLS slot. However, many plugins shipped with Acrobat or Adobe Reader use the DLL version so the run\sphinxhyphen{}time DLL does not occupy another TLS slot after it is loaded by the process.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Acrobat and Adobe Reader do not currently generate an error when a plugin fails to load due to the TLS limit.
\end{sphinxadmonition}


\subsubsection{Using modal dialog boxes}
\label{\detokenize{Plugins_CreatingSimplePlug:using-modal-dialog-boxes}}
If you write plugins that contain modal dialog boxes on the Windows platform, you need to perform the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
When you are creating your dialog box, get the parent \sphinxcode{\sphinxupquote{HWND}} of the dialog box using the \sphinxcode{\sphinxupquote{WinAppGetModalParent}} method. Then use this \sphinxcode{\sphinxupquote{HWND}} when creating the dialog box.

\end{enumerate}

Ensure that you get the mouse capture before putting up your dialog box so that Acrobat or Adobe Reader does not receive the mouse clicks. After your dialog box returns, set the mouse capture back.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HWND} \PYG{n}{CapturehWnd}\PYG{p}{,} \PYG{n}{hParent}\PYG{p}{;}
 \PYG{n}{CapturehWnd} \PYG{o}{=} \PYG{n}{GetCapture}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
 \PYG{k}{if} \PYG{p}{(} \PYG{n}{CapturehWnd} \PYG{o}{!=} \PYG{n}{NULL} \PYG{p}{)}
     \PYG{n}{ReleaseCapture}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{hParent} \PYG{o}{=} \PYG{n}{WinAppGetModalParent}\PYG{p}{(}\PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{nRetVal} \PYG{o}{=} \PYG{n}{DialogBox}\PYG{p}{(}\PYG{n}{gHINSTANCE}\PYG{p}{,} \PYG{n}{MAKEINTRESOURCE}\PYG{p}{(}\PYG{n}{IDD\PYGZus{}PROPS}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hParent}\PYG{p}{,}
 \PYG{n}{PropsDialogProc}\PYG{p}{)}\PYG{p}{;}
 \PYG{k}{if} \PYG{p}{(} \PYG{n}{CapturehWnd} \PYG{o}{!=} \PYG{n}{NULL} \PYG{p}{)}
     \PYG{n}{SetCapture}\PYG{p}{(} \PYG{n}{CapturehWnd} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
As soon as you have an \sphinxcode{\sphinxupquote{HWND}} for the dialog box itself, usually in response to the \sphinxcode{\sphinxupquote{WM\_INITDIALOG}} message, you should acquire a new \sphinxcode{\sphinxupquote{AVWindow}} using the \sphinxcode{\sphinxupquote{AVWindowNewFromPlatformThing}} method. Save this \sphinxcode{\sphinxupquote{AVWindow}} in some place where you can access it when the dialog box is destroyed. Then pass the \sphinxcode{\sphinxupquote{AVWindow}} to the \sphinxcode{\sphinxupquote{AVAppBeginModal}} method.

\end{enumerate}

Here is code that is called in response to a \sphinxcode{\sphinxupquote{WM\_INITDIALOG}} message:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{AVWindow} \PYG{n}{sAVWin}\PYG{p}{;}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{o}{/}\PYG{o}{/} \PYG{n}{hWnd} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{window} \PYG{n}{handle} \PYG{n}{of} \PYG{n}{the} \PYG{n}{dialog} \PYG{n}{box} \PYG{n}{window}
 \PYG{n}{sAVWin} \PYG{o}{=} \PYG{n}{AVWindowNewFromPlatformThing}\PYG{p}{(}\PYG{n}{AVWLmodal}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,}
 \PYG{n}{gExtensionID}\PYG{p}{,} \PYG{n}{hWnd}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{AVAppBeginModal}\PYG{p}{(}\PYG{n}{sAVWin}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
At the time the dialog box is destroyed, usually in response to a \sphinxcode{\sphinxupquote{WM\_DESTROY}} message, end the modal operations using \sphinxcode{\sphinxupquote{AVAppEndModal}}. If you are not using MFC, destroy the AVWindow for which you saved the handle with \sphinxcode{\sphinxupquote{AVWindowDestroy}}. Here is a section of code called in response to a \sphinxcode{\sphinxupquote{WM\_DESTROY}} message:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVAppEndModal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVWindowDestroy}\PYG{p}{(}\PYG{n}{sAVWin}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If you are using MFC to put up your dialog box, do not call \sphinxcode{\sphinxupquote{AVWindowDestroy}} in the \sphinxcode{\sphinxupquote{WM\_DESTROY}} message. MFC will cause Acrobat or Adobe Reader to destroy the AVWindow automatically.


\subsection{Mac OS techniques}
\label{\detokenize{Plugins_CreatingSimplePlug:mac-os-techniques}}

\subsubsection{Developing a Mac OS plugin}
\label{\detokenize{Plugins_CreatingSimplePlug:developing-a-mac-os-plugin}}
Apple Xcode 9.2is the currently\sphinxhyphen{}supported development environment for developing plugins. Apple developer tools contain the correct frameworks and libraries in addition to extensive documentation on making plugins (and applications) Mach\sphinxhyphen{}O and Carbon compliant.

With macOS 10.14.5 and macOS 10.15 Catalina, Apple has mandated notarization of all applications. Conforming to this requirement, October 2019 updates for both Adobe Acrobat and Adobe Acrobat Reader applications on DC and 2017 tracks are notarized. Adobe recommends that third\sphinxhyphen{}party plug\sphinxhyphen{}in developers should get their plug\sphinxhyphen{}ins notarized by Apple. Without notarization, your plug\sphinxhyphen{}ins will fail to load in Adobe Acrobat and Adobe Acrobat Reader on macOS 10.14.5 and above.

For more information on the Apple Notarization process, see \sphinxhref{https://developer.apple.com/documentation/security/notarizing\_your\_app\_before\_distribution}{Notarizing Your App Before Distribution}.

\begin{sphinxadmonition}{note}{Note:}
Acrobat SDK samples are built against the MacOSX10.11 as universal binaries.
\end{sphinxadmonition}


\subsubsection{Using the samples}
\label{\detokenize{Plugins_CreatingSimplePlug:using-the-samples}}
You are encouraged to use the Starter plugin sample as a basis for developing your plugins. This sample contains the appropriate project settings as defined in the supplied Xcode project configuration files. The Starter sample does nothing other than build a loadable plugin. In addition, other plugins that could be useful as a starting point for developing plugins are available.

The Info.plist file contains a list of properties used by the package. Adobe provides a common info.plist file. It uses project settings to define properties appropriately for each plugin.


\subsubsection{Establishing Carbon or Cocoa compliance}
\label{\detokenize{Plugins_CreatingSimplePlug:establishing-carbon-or-cocoa-compliance}}
Carbon and Cocoa are application environments of the Mac OS X operating system. Each includes programming interfaces that include header files, a library, and a runtime.

Acrobat 9.0 uses property lists (Info.plists), which are stored with the executable files and resources that make up an application, known as an application bundle. For more information about converting existing Mac OS applications into Carbon, see \sphinxurl{http://developer.apple.com/documentation/Carbon/Conceptual/carbon\_porting\_guide/}.

\begin{sphinxadmonition}{note}{Note:}
To prevent problems with older style event handling, plugins must replace calls to \sphinxcode{\sphinxupquote{WaitNextEvent}} with calls to \sphinxcode{\sphinxupquote{RunCurrentEventQueue}} or \sphinxcode{\sphinxupquote{ReceiveNextEvent}}.
\end{sphinxadmonition}


\subsubsection{Xcode configuration files}
\label{\detokenize{Plugins_CreatingSimplePlug:xcode-configuration-files}}
Mac OS plugin sample build settings are defined in SDK and project\sphinxhyphen{}level configuration files and not within the projects themselves. Xcode configuration files include lists of build settings definitions that can be applied to multiple projects and/or multiple targets.

The configuration files and settings have a hierarchical structure modeled after \sphinxhref{http://developer.apple.com/documentation/DeveloperTools/Conceptual/XcodeUserGuide/Contents/Resources/en.lproj/05\_05\_build\_configs/chapter\_33\_section\_6.html}{Apple Developer documentation}

Each project is based on a project\sphinxhyphen{}level build settings file(s) that includes SDK\sphinxhyphen{}level settings.

At the SDK level, there are separate configuration files for SDK plugin settings (Default.xcconfig), environmental variables (Environment.xcconfig) and resource settings (Resources.xcconfig). Global target settings for \_debug and \_release targets are stored in Debug.xcconfig and Release.xcconfig, respectively.

At the project level, there are four configuration files:
\begin{itemize}
\item {} 
ProjectDefault.xcconfig

\item {} 
ProjectResources.xcconfig

\item {} 
Project\_debug.xcconfig

\item {} 
Project\_release.xcconfig.

\end{itemize}

Each project level configuration file includes the settings from its related (parent) SDK configuration file (for example, ProjectDefault.xconfig includes Default.xcconfig and ProjectResources.xcconfig includes Resources.xcconfig). Generally, SDK\sphinxhyphen{}level setting definitions are not included directly, but rather are included through project\sphinxhyphen{}level configuration files.

Each SDK plugin project includes a single (Default) configuration based on the ProjectDefault.xcconfig build settings which include the SDK\sphinxhyphen{}level Default.xcconfig build settings. Each project has two targets: a \_debug target and a \_release target. The targets’ build settings are based on Project\_debug.xcconfig and Project\_release.xconfig, respectively. Similar to the project configuration files, each target configuration settings include its parent SDK configuration file; for instance, Project\_debug includes Debug.xcconfig settings.

Project\sphinxhyphen{}level configuration files whose names begins with Project are the default project settings included with most SDK plugin samples. Project\sphinxhyphen{}level configuration files that are prefixed with a specific sample’s name include settings specific to that sample. The build settings for most SDK projects are extremely similar with most definitions residing in the SDK configuration files.


\subsubsection{Using SetGWorld rather than SetPort}
\label{\detokenize{Plugins_CreatingSimplePlug:using-setgworld-rather-than-setport}}
With the move to carbonization and double buffering, you should use GetGWorld rather than the toolbox call SetPort. Using both calls in the same plugin can cause the current port to get out of sync with the current device. Using only GetGWorld maintains the correct port and device settings.

In all cases, you should pass \sphinxcode{\sphinxupquote{GetMainDevice}} unless you have a particular device in mind or you are restoring the GWorld to its original state. The following code is an example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{foo}\PYG{p}{(}\PYG{n}{AVPageView} \PYG{n}{pageView}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
     \PYG{n}{CGrafPtr} \PYG{n}{oldGWorld}\PYG{p}{,} \PYG{n}{pagePort} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
     \PYG{n}{GDHandle} \PYG{n}{oldDevice}\PYG{p}{;}
     \PYG{n}{pagePort} \PYG{o}{=} \PYG{p}{(}\PYG{n}{CGrafPtr}\PYG{p}{)}\PYG{n}{AVPageViewAcquireMachinePort}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}
     \PYG{k}{if} \PYG{p}{(}\PYG{n}{pagePort}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{GetGWorld}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{oldGWorld}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{oldDevice}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{SetGWorld}\PYG{p}{(}\PYG{n}{pagePort}\PYG{p}{,} \PYG{n}{GetMainDevice}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
         \PYG{o}{/}\PYG{o}{/}\PYG{n}{Draw} \PYG{n}{to} \PYG{n}{the} \PYG{n}{port} \PYG{n}{here}
         \PYG{n}{SetGWorld}\PYG{p}{(}\PYG{n}{oldGWorld}\PYG{p}{,} \PYG{n}{oldDevice}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{AVPageViewReleaseMachinePort}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{,} \PYG{n}{pagePort}\PYG{p}{)}\PYG{p}{;}
     \PYG{p}{\PYGZcb{}}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Locating and loading a plugin}
\label{\detokenize{Plugins_CreatingSimplePlug:locating-and-loading-a-plugin}}\label{\detokenize{Plugins_CreatingSimplePlug:locating-and-loading-plugins-1}}
When Acrobat or Adobe Reader starts, it scans the plugin folder to locate and load plugins with the acroplugin file extension. PowerPC plugins must have creator \sphinxcode{\sphinxupquote{CARO}} (CFBundleSignature) and type \sphinxcode{\sphinxupquote{XTND}} (CFBundlePackageType). Each plugin exports a single main entry point, \sphinxcode{\sphinxupquote{AcroPluginMain}}. When loading a plugin, Acrobat or Adobe Reader jumps to the plugin’s entry point to begin handshaking. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_89824}{Handshaking}.)


\subsubsection{Using memory}
\label{\detokenize{Plugins_CreatingSimplePlug:using-memory}}
The Acrobat or Adobe Reader memory allocator gets its memory from the system and not from the application’s memory partition. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_68646}{Acquiring and releasing objects}.)

Memory allocation guidelines are particularly important in Mac OS to ensure that memory is allocated from the system rather than from the application partition. Otherwise, your plugin is very likely to cause Acrobat or Adobe Reader to run out of memory.


\subsubsection{Resource file considerations}
\label{\detokenize{Plugins_CreatingSimplePlug:resource-file-considerations}}
Acrobat or Adobe Reader open a plugin’s resource file with read\sphinxhyphen{}only permissions. In addition, plugins cannot assume that their resource file is on top of the resource chain each time they are entered by using an \sphinxcode{\sphinxupquote{ASCallback}}. Plugins must explicitly move their resource file to the top of the resource chain before accessing resources in it. As a result, all code that directly or indirectly invokes \sphinxcode{\sphinxupquote{GetResource}} must be modified. This can be accomplished either directly or by using the SafeResources routines in the Acrobat SDK.


\subsubsection{Using SafeResources}
\label{\detokenize{Plugins_CreatingSimplePlug:using-saferesources}}
The recommended way to access resources in the plugin file is to use the functions declared in the header file SafeResources.h in the SDK. These functions are direct replacements for each Toolbox function that directly or indirectly calls \sphinxcode{\sphinxupquote{GetResource}}. The replacement functions automatically place the plugin file on top of the resource chain before accessing the resource, and restore the old resource chain after accessing the resource.


\subsubsection{Manipulating the resource chain directly}
\label{\detokenize{Plugins_CreatingSimplePlug:manipulating-the-resource-chain-directly}}
If you choose to manipulate the resource chain directly, you must modify all code that directly or indirectly calls GetResource. The list of such Toolbox calls can be determined from SafeResources.h, by removing the prefix Safe from the names of the calls. Before calling each such Toolbox function, you must put the plugin’s resource file on top of the resource chain, and after such calls, you must restore the old resource chain. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DialogPtr} \PYG{n}{myDialog} \PYG{o}{=} \PYG{n}{GetNewDialog}\PYG{p}{(}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{p}{(}\PYG{n}{Ptr}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

must be rewritten as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{short} \PYG{n}{oldResFile}\PYG{p}{;}
 \PYG{n}{DialogPtr} \PYG{n}{myDialog}\PYG{p}{;}
 \PYG{n}{oldResFile} \PYG{o}{=} \PYG{n}{CurResFile}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{UseResFile}\PYG{p}{(}\PYG{n}{gResFile}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{myDialog} \PYG{o}{=} \PYG{n}{GetNewDialog}\PYG{p}{(}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{p}{(}\PYG{n}{Ptr}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{useResFile}\PYG{p}{(}\PYG{n}{oldResFile}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The global variable \sphinxcode{\sphinxupquote{gResFile}} is automatically set up during handshaking and is declared in PICommon.h.


\subsubsection{Macros}
\label{\detokenize{Plugins_CreatingSimplePlug:macros}}
The following macros must be defined:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{POWER\_PC}} must be defined

\item {} 
\sphinxcode{\sphinxupquote{PLATFORM}} must be defined as MacPlatform.h

\item {} 
\sphinxcode{\sphinxupquote{PRODUCT}} must be defined as Plugin.h

\end{itemize}

These macros are automatically defined correctly for the platform and development environment by the header file PIPrefix.h. You are encouraged to use this header file.


\subsubsection{Mac OS\sphinxhyphen{}only methods}
\label{\detokenize{Plugins_CreatingSimplePlug:mac-os-only-methods}}
Plugins should not use the \sphinxcode{\sphinxupquote{ASPathFromPlatformPath}} method in Mac OS. Instead, they should invoke \sphinxcode{\sphinxupquote{ASFileSysCreatePathName}}. The \sphinxcode{\sphinxupquote{AVAppDidOrWillSwitchForDialog}} method is only useful to plugins in Mac OS.


\subsubsection{Inter application communication}
\label{\detokenize{Plugins_CreatingSimplePlug:inter-application-communication}}\label{\detokenize{Plugins_CreatingSimplePlug:interapplication-communication-1}}
Plugins can add their own Apple events to those supported by Acrobat or Adobe Reader by hooking into the Apple event handling loop for Acrobat or Adobe Reader. This is done by replacing the \sphinxcode{\sphinxupquote{AVAppHandleAppleEvent}} method in the API. If the plugin receives an Apple event it does not want to handle, it should invoke the implementation of the method it replaced, allowing other plugins or Acrobat or Adobe Reader the opportunity to handle the Apple event.


\section{Creating a sample plugin}
\label{\detokenize{Plugins_CreatingSimplePlug:creating-a-sample-plugin}}
When you start a new Acrobat plugin for the Windows platform, it is recommended that you use the Starter sample plugin as a starting point. On Windows, the project file is named Starter.sln and can be found in the following directories:
\begin{itemize}
\item {} 
C:Acrobat SDKPluginSupportSamplesStarterwin32

\item {} 
C:Acrobat SDKPluginSupportSamplesStarterwin64

\end{itemize}

However, to improve your understanding of creating plugins, the remaining parts of this section discuss what tasks you must perform when creating a plugin from a blank project. When using the Starter sample plugin, it is not necessary to perform some of the tasks discussed in this section. For example, you do not need to start a new project, include header files, or add the PIMain source file. However, you still have to add application logic, compile, and build your project.

If you are developing on Windows using Visual Studio, you can use the Plugin Wizard tool to set up your plugin project. This tool includes the Acrobat SDK header files required for specific types of plugin solutions, and it adds the PIMain source file. The Wizard creates classes that uses \sphinxcode{\sphinxupquote{ToDo}} markers to identify logic you must supply. You must still compile and build your plugin, as described in this section. See the \sphinxhref{../SamplesGuide/book/Samples\_Tools.html\#96791}{Plugin Wizard, see}.

For information on developing an Adobe Reader plugin, see \sphinxhref{Plugins\_ReaderPlug.html\#50618405\_11144}{Creating an Adobe Reader plugin}.

To create a plugin:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Start a new C project.

\item {} 
Include Acrobat SDK header files.

\item {} 
Add the PIMain source file to your project.

\item {} 
Add application logic to meet your business requirements.

\item {} 
Compile and build your plugin.

\end{enumerate}


\subsection{Including Acrobat SDK library files}
\label{\detokenize{Plugins_CreatingSimplePlug:including-acrobat-sdk-library-files}}
To create a plugin, you must include Acrobat SDK library files, such as header files, into your project. You can link to these library files from within your development environment. For more information, see the documentation that accompanies your development environment.

The Acrobat SDK library files are separated into the following categories:
\begin{itemize}
\item {} 
Header files that are common to most plugins and generally referenced from PIMain.c.

\item {} 
Header files specific to core and extended APIs.

\end{itemize}

You can find these header files in  Acrobat SDKPluginSupportHeaders


\subsection{Adding the PIMain source file}
\label{\detokenize{Plugins_CreatingSimplePlug:adding-the-pimain-source-file}}
You must add the PIMain.c file to your project in order to create a plugin. This source file contains application logic such as handshaking methods, that are required by plugins. You can find this file in Acrobat SDKPluginSupportHeadersAPI

After you add this file, you can add application logic to your project.

\begin{sphinxadmonition}{note}{Note:}
As a plugin developer, you will never have to create the application logic that is located in the PIMain.c file or modify this file. However, you must include this file in your project.
\end{sphinxadmonition}


\subsection{Adding application logic}
\label{\detokenize{Plugins_CreatingSimplePlug:adding-application-logic}}
You must add a source file to your project that contains the following methods:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{PluginExportHFTs}}

\item {} 
\sphinxcode{\sphinxupquote{PluginImportReplaceAndRegister}}

\item {} 
\sphinxcode{\sphinxupquote{PluginInit}}

\item {} 
\sphinxcode{\sphinxupquote{PluginUnload}}

\item {} 
\sphinxcode{\sphinxupquote{GetExtensionName}}

\item {} 
\sphinxcode{\sphinxupquote{PIHandshake}}

\end{itemize}

You can copy the source code that is located in the StartInit.cpp file (located in the Starter plugin) and paste it. For information about these methods, see \sphinxhref{Plugins\_Pimech.html\#50618406\_58810}{About plugin initialization}.

The entry point to a plugin is the \sphinxcode{\sphinxupquote{PluginInit}} method. For example, if you add the following line of code to this method, an alert box is displayed when Adobe Reader or Acrobat is started:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is your first plugin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can add an application to the \sphinxcode{\sphinxupquote{PluginInit}} method to meet your business requirements. You can invoke other user\sphinxhyphen{}defined functions that you create or you can add application logic to this method that performs a specific task. For example, you can add application logic to this method that adds a new menu item to Adobe Reader or Acrobat. (See \sphinxhref{Plugins\_Menu.html\#50618409\_98126}{Creating Menus and Menu Commands}.)


\subsection{Compiling and building your plugin}
\label{\detokenize{Plugins_CreatingSimplePlug:compiling-and-building-your-plugin}}
You must compile your plugin to build the API file. As stated earlier in this guide, plugins are equivalent to Windows DLLs; however, the file extension is.api, not.dll. Once you create an API file, you must add it to Program FilesAdobeAcrobatplugins.

After you add the plugin to this directory, you must restart Acrobat for the plugin to take effect.


\section{Creating a sample PDF Library application}
\label{\detokenize{Plugins_CreatingSimplePlug:creating-a-sample-pdf-library-application}}
A PDF Library application does not have the same overhead as a plugin. That is, unlike a plugin, a PDF Library project does not require handshaking and initialization methods. A PDF Library application is a standard C/C++ project with PDF Library files included.

\begin{sphinxadmonition}{note}{Note:}
For a detailed discussion about using the PDF Library API, see \sphinxhref{Plugins\_Insertext.html\#50618411\_44849}{Inserting Text into PDF Documents}.
\end{sphinxadmonition}


\subsection{Contents of the PDF Library SDK}
\label{\detokenize{Plugins_CreatingSimplePlug:contents-of-the-pdf-library-sdk}}
The Adobe PDF Library SDK consists of the following components:
\begin{itemize}
\item {} 
Core libraries that provide PDF Library functionality

\item {} 
Header files that provide access to the libraries

\item {} 
Fonts used in the library’s basic operations

\item {} 
Sample applications and code snippets showing how to use the library for a variety of purposes

\item {} 
Documentation discussing development techniques and the PDF Library APIs.

\end{itemize}


\subsubsection{Including library files}
\label{\detokenize{Plugins_CreatingSimplePlug:including-library-files}}
The following components are shipped with the PDF Library SDK:
\begin{itemize}
\item {} 
\sphinxstylestrong{Acrobat PDF Library}: These are DLLs on the Windows platform and a shared object library Mac OS. In Windows, an interface library must be included in your Microsoft Visual Studio project. The following are the file names of these libraries:

\item {} 
\sphinxstylestrong{AdobePDFL.lib}: The interface library for the Windows PDF Library DLL.

\item {} 
\sphinxstylestrong{AdobePDFL.dll}: The Windows PDF Library DLL.

\item {} 
\sphinxstylestrong{libpdfl.so}: The shared object library for supported UNIX platforms (deprecated).

\item {} 
\sphinxstylestrong{AdobePDFL framework}: The framework for Mac OS.

\item {} 
PDF Library SDK header files: The PDF Library SDK include directory contains headers for accessing the API methods. You can link to these library files from within your development environment. Consult the documentation that accompanies your development environment for information about linking to library files.

These files perform the same task in the PDF Library SDK as in the Acrobat SDK. For example, the PDCalls.h provides HFT functionality for PD layer functions. (See \sphinxhref{Plugins\_CreatingSimplePlug.html\#50618417\_78469}{Including Acrobat SDK library files}.)

\end{itemize}


\subsubsection{Sample code}
\label{\detokenize{Plugins_CreatingSimplePlug:sample-code}}
Samples are provided for the Windows and Mac OS in two forms:
\begin{itemize}
\item {} 
Stand\sphinxhyphen{}alone sample programs\sphinxhyphen{}  mi

\item {} 
The SnippetRunner, an environment and infrastructure for code snippets that illustrate specific functions or techniques.

\end{itemize}

Sample code is intended to demonstrate the use of the PDF Library API and is not necessarily robust enough for a final implementation. The sample code itself is platform\sphinxhyphen{}independent, as is the majority of the PDF Library API; the only difference between the sample source code for different platforms is the line\sphinxhyphen{}endings.

The Mac OS samples are provided as application packages. This format is normal for double\sphinxhyphen{}clickable applications, but they can also be run from the command line. To run them from the command line, you can either specify the command line arguments in the Xcode project file and execute within the IDE, or you can target the actual executable, which is in the Contents/MacOS folder inside the package. For example, from the Terminal window:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd helowrld.app/Contents/MacOS/
\PYGZdl{} helowrld
\end{sphinxVerbatim}

The MT (multi\sphinxhyphen{}threading) samples require command line arguments (a default set is added to the project files). Therefore, execution from within the IDE is preferred. Also, for those samples you must use absolute paths for the command line arguments.


\paragraph{Stand\sphinxhyphen{}alone samples}
\label{\detokenize{Plugins_CreatingSimplePlug:stand-alone-samples}}
The following table lists the stand\sphinxhyphen{}alone sample applications that accompany the PDF Library SDK.


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{Plugins_CreatingSimplePlug:section-1}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Sample application
&\sphinxstyletheadfamily 
Description
\\
\hline
addelem
&
Shows how to modify existing pages in a PDF file. It adds a footer to each page and shifts the first line of each text run.
\\
\hline
all
&
Used to compile all samples at the same time. Available for Windows and Mac OS only.
\\
\hline
CreatePattern
&
Shows how to create tiling patterns in a PDF document.
\\
\hline
Decryption
&
Shows how to programmatic\sphinxhyphen{}ally decrypt a PDF document encrypted with Acrobat standard security options.
\\
\hline
drawtomemory
&
Shows how to render a page to memory using the \sphinxcode{\sphinxupquote{PDPageDrawContentsToMemory}} PDF Library method, and creates a PDF file with a bitmap image rendered on the page.
\\
\hline
fontembd
&
Shows font enumeration and font embedding.
\\
\hline
helowrld
&
Shows the basics of creating a PDF document.
\\
\hline
JPXEncode
&
Re\sphinxhyphen{}encodes PDF embedded images with the JPX filter and writes out a new PDF file with the re\sphinxhyphen{}encoded images embedded.
\\
\hline
mergepdf
&
Shows how to merge two PDF files.
\\
\hline
MTInMemFS
&
Demonstrates use of an in\sphinxhyphen{}memory file system for a simple workflow within a multi\sphinxhyphen{}threaded context.
\\
\hline
MTSerialNums
&
Demonstrates creation of multiple threads to simultaneously generate multiple PDFs.
\\
\hline
MTTextExtract
&
Demonstrates multiple threads concurrently processing multiple PDF documents.
\\
\hline
Peddler
&
Shows how to add hyperlinking (specifically targeting URIs) capabilities to an existing PDF document.
\\
\hline
printpdf
&
Shows how to print a PDF file to a printer or to a file using the PDF Library method PDFLPrintDoc.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{SnippetRunner application}
\label{\detokenize{Plugins_CreatingSimplePlug:snippetrunner-application}}
SnippetRunner allows you to quickly prototype code containing PDF Library API calls without the overhead of writing and verifying a complete application. It provides an infrastructure and utility functions to support execution and testing of code snippets, which are small but complete portions of PDF Library application code.

SnippetRunner consists of these major components:
\begin{itemize}
\item {} 
An application that acts as a back\sphinxhyphen{}end server and that provides the basic functionality, including a parameter input mechanism, debug support, and exception handling.

\item {} 
A graphical user interface that acts as a client to the back\sphinxhyphen{}end server. (This user interface, called the Common User Interface, is also provided with the Acrobat SDK, which uses an Acrobat plugin for its back end.)

\end{itemize}

For more information about SnippetRunner, see the ` <../SnippetRunnerCookbook/Snippet\_SnippetRunnerCookbook.html\#38527>`\_\_.


\subsection{Developing applications with the Adobe PDF Library}
\label{\detokenize{Plugins_CreatingSimplePlug:developing-applications-with-the-adobe-pdf-library}}
This section details the compiler environment variables (macros) required to build applications against the Adobe PDF Library. On all platforms, you must define the PRODUCT macro for the preprocessor.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PRODUCT}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HFTLibrary.h}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

This macro is used as a trigger for conditional compilation and allows the same headers to be used for both the Acrobat core API and the Adobe PDF Library.


\subsubsection{Windows}
\label{\detokenize{Plugins_CreatingSimplePlug:windows}}
The following macros must also be defined in the IDE project settings for applications to compile correctly on the Windows platform:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{WIN\_ENV}}

\item {} 
\sphinxcode{\sphinxupquote{WIN32}}

\item {} 
\sphinxcode{\sphinxupquote{WIN\_PLATFORM}}

\end{itemize}

The Adobe PDF Library is compiled with code generation set to Multithreaded. Applications linking with the Adobe PDF Library must have code generation settings that match or there will be conflicts between the Microsoft libraries \sphinxcode{\sphinxupquote{MSVCRT}} and \sphinxcode{\sphinxupquote{LIBCMT}}.

In Visual Studio, the Ignore Libraries settings (click Project Settings > Link > Input > Ignore libraries) should not ignore LIBCMT (other versions of PDF Library do ignore it).

The Adobe PDF Library is distributed as an interface library (AdobePDFL.lib) and matching DLL (AdobePDFL.dll). You should link the interface library into your application.

The operating system must be able to access the Adobe PDF Library at runtime. It does so by searching the paths specified by the PATH environment variable, as well as the folder in which the application was launched.


\subsubsection{Mac OS}
\label{\detokenize{Plugins_CreatingSimplePlug:mac-os}}
The Mac OS libraries use a precompiled header and prefix file to define the appropriate macros. See Precompile.pch in the Samples:utils directory of the Adobe PDF Library SDK for the macros required to successfully compile the samples.


\subsection{Initialization and termination}
\label{\detokenize{Plugins_CreatingSimplePlug:initialization-and-termination}}
Applications must initialize and terminate the Adobe PDF Library appropriately:
\begin{itemize}
\item {} 
Call \sphinxcode{\sphinxupquote{PDFLInit}} to set up internal data structures, locate required resources such as fonts, and perform initialization (such as setting client\sphinxhyphen{}provided memory allocation routines). Calling most library functions without successfully initializing the library results in error conditions. The rest of this section provides details on using PDFLInit.

\item {} 
Call \sphinxcode{\sphinxupquote{PDFLTerm}} to clean up before an application terminates or when access to PDF Library functionality is no longer needed.

\end{itemize}

Since the PDF Library supports thread\sphinxhyphen{}safety (since version 6.1.2), initialization and termination are handled on a per\sphinxhyphen{}thread basis.

The \sphinxcode{\sphinxupquote{PDFLInit}} function takes as a parameter a \sphinxcode{\sphinxupquote{PDFLData}} structure, defined in the API header file PDFInit.h. You must provide valid values for the following members of the structure before passing it to \sphinxcode{\sphinxupquote{PDFLInit}} :
\begin{itemize}
\item {} 
size denotes the size of the structure and can be obtained with \sphinxcode{\sphinxupquote{sizeof(PDFLDataRec)}}.

\item {} 
listLen is the number of directories listed in dirList.

\item {} 
dirList is an array of directories that contain font resources. The following discussion explains how to use this member on each of the supported platforms.

\end{itemize}

In Windows and Mac OS, the PDF Library searches for fonts in the default system and in their subdirectories (to 99 levels). You can specify additional font directories to search (also to 99 levels) in the dirList array. (Note that this can affect performance.)

Here is an example showing how to pass the font paths to dirList for Windows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pdflLibData}\PYG{o}{.}\PYG{n}{dirList}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{=} \PYG{n}{strdup}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:MyfontfolderCMap}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{pdflLibData}\PYG{o}{.}\PYG{n}{dirList}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=} \PYG{n}{strdup}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:MyfontfolderCIDFont}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{pdflLibData}\PYG{o}{.}\PYG{n}{dirList}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{=} \PYG{n}{strdup}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:MyfontfolderFont}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The paths can be either full paths or paths relative to the directory from which the executable linking in the Adobe PDF Library was started. You can set the value \sphinxcode{\sphinxupquote{kPDFLInitIgnoreDefaultDirectories}} in the flags field of the \sphinxcode{\sphinxupquote{PDFLData}} structure to indicate that the default font directories should not be searched but only the directories provided in dirList.

For more details, see the functions \sphinxcode{\sphinxupquote{PDFLGetDirList\_Win}} and \sphinxcode{\sphinxupquote{PDFLGetDirList\_Mac}} in the MyPDFLibUtils.cpp file in the \sphinxcode{\sphinxupquote{Samples/utils}} directory.


\subsection{Multithreading}
\label{\detokenize{Plugins_CreatingSimplePlug:multithreading}}
When using the thread\sphinxhyphen{}safe PDF Library, initialization and termination now additionally need to be performed for each thread that calls into the library, as well as at the process level. The interfaces for per\sphinxhyphen{}thread initialization/termination are the same as before.

Since each thread acquires an independent PDF Library memory context, you should not share PDF Library data and resources among threads. This includes sharing the same PDF file.

The Adobe PDF libraries are thread\sphinxhyphen{}safe. To use threads, simply make the appropriate system call (\sphinxcode{\sphinxupquote{beginthreadex}} on Windows). Multiple threads cannot share PDF Library data types. However, they share the same process heap; therefore, an application can share generic data types between threads. Multiple threads can open the same file read\sphinxhyphen{}only; however, multiple threads should not attempt to write to the same PDF document.

In Windows, \sphinxcode{\sphinxupquote{CreateThread}} is not recommended if the application is using most stdio.h\sphinxhyphen{}defined functions, including file I/O and string manipulation. It is best to \sphinxcode{\sphinxupquote{use \_beginthreadex}} on Windows, which performs extra bookkeeping to ensure thread safety.


\section{Upgrading existing plugins}
\label{\detokenize{Plugins_CreatingSimplePlug:upgrading-existing-plugins}}
This section discusses how to upgrade an existing Acrobat plugin to work with a newer version of Acrobat.

Refer to the Release Notes.


\subsection{Detecting supported APIs}
\label{\detokenize{Plugins_CreatingSimplePlug:detecting-supported-apis}}
Acrobat Pro and Acrobat Pro Extended support the full set of APIs. For Acrobat Standard and Adobe Reader, if you try to use an API that is not supported, nothing will happen. The same HFT version numbers are used across products, so all APIs are callable on all products, but some APIs simply do not work on certain products.

Additionally, the Extended APIs provided by plugins do not work if an Acrobat product does not support the use of those APIs. The HFTs do not load, so you must check whether the HFT was successfully imported.

It is possible to determine in your code whether the HFT you are expecting is in fact the one that you are importing, and whether it imported at all: simply check for a \sphinxcode{\sphinxupquote{NULL}} return value. For example, a \sphinxcode{\sphinxupquote{NULL}} will be returned in the following call if \sphinxcode{\sphinxupquote{AcroColorHFTNAME}} with the specified version is not available:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gAcroColorHFT} \PYG{o}{=} \PYG{n}{ASExtensionMgrGetHFT}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{n}{AcroColorHFTNAME}\PYG{p}{)}\PYG{p}{,}
 \PYG{n}{PI\PYGZus{}ACROCOLOR\PYGZus{}VERSION}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Plugins that use new HFTs introduced with the current Acrobat version do not run on earlier Acrobat versions. Whether or not an attempt to load these HFTs forces the plugin to fail is controlled by flags in PIMain.c of the form \sphinxcode{\sphinxupquote{PI\_HFT\_OPTIONAL}}. By default, these flags are undefined, so if your plugin attempts to load HFT and cannot, initialization fails. If you define \sphinxcode{\sphinxupquote{PI\_HFT\_OPTIONAL}} with some value (preferably 1) and the load is not successful, initialization continues.

Use the \sphinxcode{\sphinxupquote{ASGetConfiguration}} method to determine the configuration on which the plugin is running. Use conditional logic in your code so that it makes calls only to APIs that are supported on that particular configuration. In any case, your code should check for \sphinxcode{\sphinxupquote{NULL}} HFTs so that it does not call APIs that are not supported on the current configuration.

Under Adobe Reader, when a rights\sphinxhyphen{}enabled PDF file is opened, a flag is set that allows a plugin to use APIs that become enabled as a result of loading the rights\sphinxhyphen{}enabled PDF. Familiarize yourself with the features available on the different configurations of Acrobat to ensure that you install plugin menus and toolbars appropriately at initialization. Ensure that you make calls only to APIs supported on the platform detected.


\section{Migrating PDFL apps to Xcode}
\label{\detokenize{Plugins_CreatingSimplePlug:migrating-pdfl-apps-to-xcode}}
For the PDF Library, the supported Mac OS X development environment is Xcode (formerly the supported environment was Metrowerks CodeWarrior). With this change comes a new set of headers, frameworks and libraries that may or may not be compatible with existing plugin code and with existing CodeWarrior projects.

You can migrate a PDF Library application that was created using CodeWarrior to Xcode. As a starting point, it is recommended that you read the information that is located at the following URL: \sphinxurl{http://developer.apple.com/documentation/DeveloperTools/Conceptual/MovingProjectsToXcode/index.html}.

The PDF Library SDK samples have debug and release targets that are built against the MacOSX10.4u.sdk SDK. These are carbon applications that create universal binaries linked to universal Adobe libraries. For a complete list of compatible application build settings, see the MacSDKConfiguration Xcode configuration files and ProjectConfigurations files included in the PDF Library SDK.


\chapter{Inserting Text into PDF Documents}
\label{\detokenize{Plugins_Insertext:inserting-text-into-pdf-documents}}\label{\detokenize{Plugins_Insertext::doc}}
As stated earlier in this guide, the PDF Library API is a subset of the Acrobat core API that enables your application to interact and manipulate PDF documents. The PDF Library API is not used to create plugins for Adobe Reader or Acrobat. It is also not used to modify the user interface of Adobe Reader or Acrobat, such as by adding a toolbar or menu item.

You can use the PDF Library API to programmatically insert text into a PDF document. This functionality is useful for dynamically updating a PDF document with information obtained during run\sphinxhyphen{}time. You can insert text into a PDF document by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a new PDF document.

\item {} 
Create a new page and insert it into the PDF document.

\item {} 
Create a container for the page content.

\item {} 
Acquire a font and set its attributes.

\item {} 
Insert the text element into page content.

\item {} 
Convert content into resource and content objects.

\item {} 
Place resource and content objects onto the page.

\item {} 
Save the PDF document.

\item {} 
Release all objects.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
Assume that all code examples specified in this chapter are located in an entry function named \sphinxcode{\sphinxupquote{MainProc}}.
\end{sphinxadmonition}


\section{Creating a new PDF document}
\label{\detokenize{Plugins_Insertext:creating-a-new-pdf-document}}
You can programmatic\sphinxhyphen{}ally create a new PDF document by invoking the \sphinxcode{\sphinxupquote{PDDocCreate}} method. This method returns a \sphinxcode{\sphinxupquote{PDDoc}} object that only contains one COS object, which is a Catalog. For information about COS objects, see \sphinxhref{Plugins\_Cos.html\#50618418\_86959}{Working with Cos Objects}.

The following code example creates a \sphinxcode{\sphinxupquote{PDDoc}} object by invoking \sphinxcode{\sphinxupquote{PDDocCreate}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDDoc} \PYG{n}{pdDoc} \PYG{p}{;}
\PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{DDocCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Creating a new page}
\label{\detokenize{Plugins_Insertext:creating-a-new-page}}
You can create a new page by invoking the \sphinxcode{\sphinxupquote{PDDocCreatePage}} method. However, before invoking this method, set the page size by creating an \sphinxcode{\sphinxupquote{ASFixedRect}} object, which represents a rectangle region that specifies the page size. After you declare an \sphinxcode{\sphinxupquote{ASFixedRect}} object, you can specify the page size by setting the \sphinxcode{\sphinxupquote{ASFixedRect}} object’s \sphinxcode{\sphinxupquote{left}}, \sphinxcode{\sphinxupquote{top}}, \sphinxcode{\sphinxupquote{right}}, and \sphinxcode{\sphinxupquote{bottom}} attributes.

Next, invoke the \sphinxcode{\sphinxupquote{PDDocCreatePage}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} object that was created.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that specifies the page number after which the new page is inserted. Specify \sphinxcode{\sphinxupquote{PDBeforeFirstPage}} to insert the new page at the beginning of the PDF document.

\item {} 
An \sphinxcode{\sphinxupquote{ASFixedRect}} object that specifies the page size.

\end{itemize}

This method returns a \sphinxcode{\sphinxupquote{PDPage}} object. The following code example creates a new page, sets it size, and inserts it into the PDF document represented by the \sphinxcode{\sphinxupquote{PDDoc}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDPage} \PYG{n}{pdPage}\PYG{p}{;}
\PYG{n}{ASFixedRect} \PYG{n}{mediaBox}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n}{page} \PYG{n}{size}
\PYG{n}{mediaBox}\PYG{o}{.}\PYG{n}{left} \PYG{o}{=} \PYG{n}{fixedZero}\PYG{p}{;}
\PYG{n}{mediaBox}\PYG{o}{.}\PYG{n}{top} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mediaBox}\PYG{o}{.}\PYG{n}{right} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mediaBox}\PYG{o}{.}\PYG{n}{bottom} \PYG{o}{=} \PYG{n}{fixedZero}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{page} \PYG{o+ow}{and} \PYG{n}{insert} \PYG{n}{it} \PYG{k}{as} \PYG{n}{the} \PYG{n}{first} \PYG{n}{page}
\PYG{n}{PDPagepdPage} \PYG{o}{=} \PYG{n}{PDDocCreatePage}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{PDBeforeFirstPage}\PYG{p}{,} \PYG{n}{mediaBox}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Creating a container}
\label{\detokenize{Plugins_Insertext:creating-a-container}}
To insert text into a PDF document, you must create a PDF container. A container contains the modifiable contents of a PDF page. To create a PDF container, invoke the \sphinxcode{\sphinxupquote{PDPageAcquirePDEContent}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDPage}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASExtension}} object that represents the caller. If you invoke this method from a PDF Library project, you can pass \sphinxcode{\sphinxupquote{NULL}}. In contrast, if you invoke this method from a plugin, you would pass the \sphinxcode{\sphinxupquote{gExtensionID}} extension.

\end{itemize}

The \sphinxcode{\sphinxupquote{PDPageAcquirePDEContent}} method returns a \sphinxcode{\sphinxupquote{PDEContent}} object, as shown in the following code example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDEContent} \PYG{n}{pdeContent}\PYG{p}{;}
\PYG{n}{pdeContent} \PYG{o}{=} \PYG{n}{PDPageAcquirePDEContent}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Acquiring fonts}
\label{\detokenize{Plugins_Insertext:acquiring-fonts}}
You must acquire the font that you will use to insert text into a PDF document. You can reference a font that is installed on the host computer by creating a \sphinxcode{\sphinxupquote{PDSysFont}} object and use this object to create a \sphinxcode{\sphinxupquote{PDEFont}} object, which represents the font that is used to draw text on a page. To acquire a font, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{PDEFontAttrs}} object.

\item {} 
Allocate the size of the \sphinxcode{\sphinxupquote{PDEFontAttrs}} object’s buffer by using the \sphinxcode{\sphinxupquote{memset}} method.

\item {} 
Set the \sphinxcode{\sphinxupquote{PDEFontAttrs}} object’s \sphinxcode{\sphinxupquote{name}} and \sphinxcode{\sphinxupquote{type}} attributes. The \sphinxcode{\sphinxupquote{name}} attribute defines the font name. For example, you can specify \sphinxcode{\sphinxupquote{CourierStd}}. The \sphinxcode{\sphinxupquote{type}} attribute defines the font subtype. For example, you can specify \sphinxcode{\sphinxupquote{Type1}}, which is a Type 1 PostScript font. For information about valid font subtype values, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDSysFont}} object by invoking the \sphinxcode{\sphinxupquote{PDFindSysFont}} method and passing the following arguments:
\begin{itemize}
\item {} 
The address of the \sphinxcode{\sphinxupquote{PDEFontAttrs}} object.

\item {} 
Size of the \sphinxcode{\sphinxupquote{PDEFontAttrs}} object in bytes.

\item {} 
A value that specifies a \sphinxcode{\sphinxupquote{PDSysFontMatchFlags}} value. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

\end{itemize}

\item {} 
Create a \sphinxcode{\sphinxupquote{PDEFont}} object that represents the font to use within a PDF document by invoking the \sphinxcode{\sphinxupquote{PDEFontCreateFromSysFont}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDSysFont}} object that references a system font.

\item {} 
An \sphinxcode{\sphinxupquote{ASUnit32}} value that indicates whether to embed the font or whether to subset the font. You can pass \sphinxcode{\sphinxupquote{kPDEFontDoNotEmbed}} to this argument. For information about other values, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\end{itemize}

\end{enumerate}

The following code example acquires a font that is used to draw text on a page.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDSysFont} \PYG{n}{sysFont}\PYG{p}{;}
\PYG{n}{PDEFont} \PYG{n}{pdeFont}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n}{size} \PYG{n}{of} \PYG{n}{the} \PYG{n}{PDSysFont} \PYG{o+ow}{and} \PYG{n+nb}{set} \PYG{n}{its} \PYG{n}{attributes}
\PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdeFontAttrs}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{pdeFontAttrs}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pdeFontAttrs}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CourierStd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pdeFontAttrs}\PYG{o}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Type1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{system} \PYG{n}{font}
\PYG{n}{sysFont} \PYG{o}{=} \PYG{n}{PDFindSysFont}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdeFontAttrs}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{PDEFontAttrs}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{font} \PYG{n}{that} \PYG{o+ow}{is} \PYG{n}{used} \PYG{n}{to} \PYG{n}{draw} \PYG{n}{text} \PYG{n}{on} \PYG{n}{a} \PYG{n}{page}
\PYG{n}{pdeFont} \PYG{o}{=} \PYG{n}{PDEFontCreateFromSysFont}\PYG{p}{(}\PYG{n}{sysFont}\PYG{p}{,} \PYG{n}{kPDEFontDoNotEmbed}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Creating a PDEGraphicState object}
\label{\detokenize{Plugins_Insertext:creating-a-pdegraphicstate-object}}
You must create a \sphinxcode{\sphinxupquote{PDEGraphicState}} object that is used to define attributes of the \sphinxcode{\sphinxupquote{PDEText}} object. After you create a \sphinxcode{\sphinxupquote{PDEGraphicState}} object, set the following attributes:
\begin{itemize}
\item {} 
\sphinxstylestrong{strokeColorSpec}: The stroke color specification. The default value is \sphinxcode{\sphinxupquote{DeviceGray}}.

\item {} 
\sphinxstylestrong{miterLimit}: The miter limit, corresponding to the M (setmiterlimit) operator. The default value is \sphinxcode{\sphinxupquote{fixedTen}}.

\item {} 
\sphinxstylestrong{flatness}: The line flatness corresponding to the i (setflat) operator. The default value is \sphinxcode{\sphinxupquote{fixedZero}}.

\item {} 
\sphinxstylestrong{lineWidth}: The line width corresponding to the w (setlinewidth) operator. The default value is \sphinxcode{\sphinxupquote{fixedOne}}.

\end{itemize}

For more information about attributes that belong to this object, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

The following code example creates a \sphinxcode{\sphinxupquote{PDEGraphicState}} object and sets it attributes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{DEGraphicState} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n+nb}{set} \PYG{n}{its} \PYG{n}{attributes}
\PYG{n}{PDEGraphicState} \PYG{n}{gState}\PYG{p}{;}
\PYG{n}{PDEColorSpace} \PYG{n}{pdeColorSpace} \PYG{o}{=} \PYG{n}{PDEColorSpaceCreateFromName}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DeviceGray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{gState}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{PDEGraphicState}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gState}\PYG{o}{.}\PYG{n}{strokeColorSpec}\PYG{o}{.}\PYG{n}{space} \PYG{o}{=} \PYG{n}{gState}\PYG{o}{.}\PYG{n}{fillColorSpec}\PYG{o}{.}\PYG{n}{space} \PYG{o}{=} \PYG{n}{pdeColorSpace}\PYG{p}{;}
\PYG{n}{gState}\PYG{o}{.}\PYG{n}{miterLimit} \PYG{o}{=} \PYG{n}{fixedTen}\PYG{p}{;}
\PYG{n}{gState}\PYG{o}{.}\PYG{n}{flatness} \PYG{o}{=} \PYG{n}{fixedOne}\PYG{p}{;}
\PYG{n}{gState}\PYG{o}{.}\PYG{n}{lineWidth} \PYG{o}{=} \PYG{n}{fixedOne}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Creating an ASFixedMatrix object}
\label{\detokenize{Plugins_Insertext:creating-an-asfixedmatrix-object}}
Create an \sphinxcode{\sphinxupquote{ASFixedMatrix}} object that represents the transformation matrix for the text. By creating this object, you can set text properties such as the font size and the width and height of the text. The following code example creates an \sphinxcode{\sphinxupquote{ASFixedMatrix}} object and sets its attributes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASFixedMatrix} \PYG{n+nb}{object}
\PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{textMatrix}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{textMatrix}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{Set} \PYG{n}{the} \PYG{n}{buffer} \PYG{n}{size} \PYG{o}{*}\PYG{o}{/}
\PYG{n}{textMatrix}\PYG{o}{.}\PYG{n}{a} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{;}     \PYG{o}{/}\PYG{o}{*} \PYG{n}{Set} \PYG{n}{font} \PYG{n}{width} \PYG{o+ow}{and} \PYG{n}{height} \PYG{o}{*}\PYG{o}{/}
\PYG{n}{textMatrix}\PYG{o}{.}\PYG{n}{d} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{;}     \PYG{o}{/}\PYG{o}{*} \PYG{n}{to} \PYG{l+m+mi}{24} \PYG{n}{point} \PYG{n}{size}       \PYG{o}{*}\PYG{o}{/}
\PYG{n}{textMatrix}\PYG{o}{.}\PYG{n}{h} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}   \PYG{o}{/}\PYG{o}{*} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y} \PYG{n}{coordinate} \PYG{n}{on} \PYG{n}{page} \PYG{o}{*}\PYG{o}{/}
\PYG{n}{textMatrix}\PYG{o}{.}\PYG{n}{v} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}   \PYG{o}{/}\PYG{o}{*} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{case}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ x 2}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{o}{*}\PYG{o}{/}
\end{sphinxVerbatim}


\section{Inserting text}
\label{\detokenize{Plugins_Insertext:inserting-text}}
You can insert text into the PDF document by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{PDEText}} object by invoking the \sphinxcode{\sphinxupquote{PDETextCreate}} method. This method does not require arguments.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{PDETextAdd}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDEText}} object that you created.

\item {} 
A \sphinxcode{\sphinxupquote{PDETextFlags}} value that specifies the type of text to add. Specify \sphinxcode{\sphinxupquote{kPDETextRun}} for a text run.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that specifies the index after which to add the text run. You can specify \sphinxcode{\sphinxupquote{0}} to add the text run to the beginning.

\item {} 
A character pointer that specifies the text to insert into the PDF document.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that specifies the length of the text run.

\item {} 
The \sphinxcode{\sphinxupquote{PDEFont}} object that you created. (See \sphinxhref{Plugins\_Insertext.html\#50618411\_68991}{Acquiring fonts}.)

\item {} 
The address of the \sphinxcode{\sphinxupquote{PDEGraphicState}} object that you created. (See \sphinxhref{Plugins\_Insertext.html\#50618411\_19751}{Creating a PDEGraphicState object}.)

\item {} 
The size of the \sphinxcode{\sphinxupquote{PDEGraphicState}} object. You can use the \sphinxcode{\sphinxupquote{sizeof}} method to get this information.

\item {} 
The address of the \sphinxcode{\sphinxupquote{PDETextState}} object. You can pass \sphinxcode{\sphinxupquote{NULL}}.

\item {} 
The size of the \sphinxcode{\sphinxupquote{PDETextState}} object.

\item {} 
The address of the \sphinxcode{\sphinxupquote{ASFixedMatrix}} object that you created. (See \sphinxhref{Plugins\_Insertext.html\#50618411\_76571}{Creating an ASFixedMatrix object}.)

\item {} 
The address of the \sphinxcode{\sphinxupquote{ASFixedMatrix}} object that holds the matrix for the line width when stroking text. It is recommended that you pass \sphinxcode{\sphinxupquote{NULL}}.

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Insert text into the page content by invoking the \sphinxcode{\sphinxupquote{PDEContentAddElem}} method and passing the following arguments:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{PDEContent}} object that you created. (See \sphinxhref{Plugins\_Insertext.html\#50618411\_53549}{Creating a container}.)

\item {} 
The location to where the text is added. Pass \sphinxcode{\sphinxupquote{kPDEAfterLast}} to add the text to the end of the \sphinxcode{\sphinxupquote{PDEContent}} object.

\item {} 
The \sphinxcode{\sphinxupquote{PDEText}} object and cast this object to \sphinxcode{\sphinxupquote{PDEElement}}.

\end{itemize}

\item {} 
Set the page’s \sphinxcode{\sphinxupquote{PDEContent}} back into the page by invoking the \sphinxcode{\sphinxupquote{PDPageSetPDEContent}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDPage}} object that you created. (See \sphinxhref{Plugins\_Insertext.html\#50618411\_72186}{Creating a new page}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASExtension}} object that represents the caller. If you invoke this method from a PDF Library project, you can pass \sphinxcode{\sphinxupquote{NULL}}. In contrast, if you invoke this method from a plugin, you would pass the \sphinxcode{\sphinxupquote{gExtensionID}} extension.

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDEText} \PYG{n+nb}{object}
\PYG{n}{pdeText} \PYG{o}{=} \PYG{n}{PDETextCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{character} \PYG{n}{pointer}
\PYG{n}{char} \PYG{o}{*}\PYG{n}{HelloWorldStr} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello There}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{new} \PYG{n}{text} \PYG{n}{run}
\PYG{n}{PDETextAdd}\PYG{p}{(}\PYG{n}{pdeText}\PYG{p}{,}          \PYG{o}{/}\PYG{o}{/}\PYG{n}{Text} \PYG{n}{container} \PYG{n}{to} \PYG{n}{add} \PYG{n}{to}
      \PYG{n}{kPDETextRun}\PYG{p}{,}            \PYG{o}{/}\PYG{o}{/} \PYG{n}{kPDETextRun}
      \PYG{l+m+mi}{0}\PYG{p}{,}                       \PYG{o}{/}\PYG{o}{/} \PYG{n}{index}
      \PYG{n}{HelloWorldStr}\PYG{p}{,}         \PYG{o}{/}\PYG{o}{/} \PYG{n}{Text} \PYG{n}{to} \PYG{n}{add}
      \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{HelloWorldStr}\PYG{p}{)}\PYG{p}{,}\PYG{o}{/}\PYG{o}{/} \PYG{n}{Length} \PYG{n}{of} \PYG{n}{text}
      \PYG{n}{pdeFont}\PYG{p}{,}                 \PYG{o}{/}\PYG{o}{/} \PYG{n}{Font} \PYG{n}{to} \PYG{n}{apply} \PYG{n}{to} \PYG{n}{text}
      \PYG{o}{\PYGZam{}}\PYG{n}{gState}\PYG{p}{,}                 \PYG{o}{/}\PYG{o}{/}\PYG{n}{Address} \PYG{n}{of} \PYG{n}{PDEGraphicState} \PYG{n+nb}{object}
      \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{gState}\PYG{p}{)}\PYG{p}{,}               \PYG{o}{/}\PYG{o}{/}\PYG{n}{Size} \PYG{n}{of} \PYG{n}{graphic} \PYG{n}{state} \PYG{n}{to} \PYG{n}{apply} \PYG{n}{to} \PYG{n}{text}
      \PYG{n}{NULL}\PYG{p}{,}
      \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{o}{\PYGZam{}}\PYG{n}{textMatrix}\PYG{p}{,}             \PYG{o}{/}\PYG{o}{/}\PYG{n}{Transformation} \PYG{n}{matrix} \PYG{k}{for} \PYG{n}{text}
      \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}                    \PYG{o}{/}\PYG{o}{/}\PYG{n}{Stroke} \PYG{n}{matrix}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Insert} \PYG{n}{text} \PYG{n}{into} \PYG{n}{page} \PYG{n}{content}
\PYG{n}{PDEContentAddElem}\PYG{p}{(}\PYG{n}{pdeContent}\PYG{p}{,} \PYG{n}{kPDEAfterLast}\PYG{p}{,} \PYG{p}{(}\PYG{n}{PDEElement}\PYG{p}{)} \PYG{n}{pdeText}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Saving the PDF document}
\label{\detokenize{Plugins_Insertext:saving-the-pdf-document}}
You can save the PDF document by invoking the \sphinxcode{\sphinxupquote{PDDocSave}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} object that represents the PDF document.

\item {} 
A \sphinxcode{\sphinxupquote{PDSaveFlags}} object that specifies save options. For example, you can pass \sphinxcode{\sphinxupquote{PDSaveFull}} to this argument, which results in the entire document being saved. For more information about this parameter, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\item {} 
An \sphinxcode{\sphinxupquote{ASPathName}} object that represents the path to which the file is saved.

\item {} 
An \sphinxcode{\sphinxupquote{ASFileSys}} object that represents the file system. (See \sphinxhref{Plugins\_Unicode.html\#50618402\_67382}{Creating an ASFileSys object}.)

\item {} 
A progress monitor value. Invoke the \sphinxcode{\sphinxupquote{AVAppGetDocProgressMonitor}} method to obtain the default. You can pass \sphinxcode{\sphinxupquote{NULL}}, in which case no progress monitor is used.

\item {} 
The address of a \sphinxcode{\sphinxupquote{progMonClientData}} object that contains user\sphinxhyphen{}supplied data to pass to \sphinxcode{\sphinxupquote{progMon}} each time it is called. Pass \sphinxcode{\sphinxupquote{NULL}} if the previous argument (progMon) is \sphinxcode{\sphinxupquote{NULL}}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Save} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{document}
\PYG{c+c1}{\PYGZsh{}if !MAC\PYGZus{}ENV}
  \PYG{n}{PDDocSave}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{PDSaveFull} \PYG{o}{|} \PYG{n}{PDSaveLinearized}\PYG{p}{,}\PYG{n}{ASPathFromPlatformPath}

\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{out.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}else}
  \PYG{n}{ASPathName} \PYG{n}{macPath} \PYG{o}{=} \PYG{n}{GetMacPath}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{out.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{PDDocSave}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{PDSaveFull} \PYG{o}{|} \PYG{n}{PDSaveLinearized}\PYG{p}{,} \PYG{n}{macPath}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ASFileSysReleasePath}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,}\PYG{n}{macPath}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Examining a PDFL app source file}
\label{\detokenize{Plugins_Insertext:examining-a-pdfl-app-source-file}}
This section shows the entire source file that is responsible for importing text into a PDF document.

The following image shows the PDF that is created when this source file is executed.

\noindent\sphinxincludegraphics{{inserttext}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}ifdef MAC\PYGZus{}ENV}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}Carbon/Carbon.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}else}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}sys/types.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}sys/stat.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}endif}

\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}fcntl.h\PYGZgt{}}

\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}PDFInit.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}CosCalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}CorCalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}ASCalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}PDCalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}PSFCalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}PERCalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}PEWCalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}PIExcept.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}PagePDECntCalls.h\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{}ifdef MAC\PYGZus{}ENV}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}macUtils.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}endif}

\PYG{n}{void} \PYG{n}{MainProc}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{char} \PYG{n}{buf}\PYG{p}{[}\PYG{l+m+mi}{256}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{ASInt32} \PYG{n}{i}\PYG{p}{;}
  \PYG{n}{ASBool} \PYG{n}{b}\PYG{p}{;}
  \PYG{n}{PDDoc} \PYG{n}{pdDoc}\PYG{p}{;}               \PYG{o}{/}\PYG{o}{*} \PYG{n}{Reference} \PYG{n}{to} \PYG{n}{a} \PYG{n}{PDF} \PYG{n}{document}  \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDPage} \PYG{n}{pdPage}\PYG{p}{;}             \PYG{o}{/}\PYG{o}{*} \PYG{n}{Reference} \PYG{n}{to} \PYG{n}{a} \PYG{n}{page} \PYG{o+ow}{in} \PYG{n}{doc} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDEContent} \PYG{n}{pdeContent}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{Container} \PYG{k}{for} \PYG{n}{page} \PYG{n}{content} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{ASFixedRect} \PYG{n}{mediaBox}\PYG{p}{;}     \PYG{o}{/}\PYG{o}{*} \PYG{n}{Dimensions} \PYG{n}{of} \PYG{n}{page} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDSysFont} \PYG{n}{sysFont}\PYG{p}{;}              \PYG{o}{/}\PYG{o}{*} \PYG{n}{Used} \PYG{n}{by} \PYG{n}{PDEFont} \PYG{n}{creation} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDEFont} \PYG{n}{pdeFont}\PYG{p}{;}           \PYG{o}{/}\PYG{o}{*} \PYG{n}{Reference} \PYG{n}{to} \PYG{n}{a} \PYG{n}{font} \PYG{n}{used} \PYG{n}{on} \PYG{n}{a} \PYG{n}{page} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDEFontAttrs} \PYG{n}{pdeFontAttrs}\PYG{p}{;} \PYG{o}{/}\PYG{o}{*} \PYG{n}{Font} \PYG{n}{attributes}    \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDEText} \PYG{n}{pdeText}\PYG{p}{;}            \PYG{o}{/}\PYG{o}{*} \PYG{n}{Container} \PYG{k}{for} \PYG{n}{text} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{ASFixedMatrix} \PYG{n}{textMatrix}\PYG{p}{;}  \PYG{o}{/}\PYG{o}{*} \PYG{n}{Transformation} \PYG{n}{matrix} \PYG{k}{for} \PYG{n}{text} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDEColorSpace} \PYG{n}{pdeColorSpace}\PYG{p}{;} \PYG{o}{/}\PYG{o}{*} \PYG{n}{ColorSpace} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDEGraphicState} \PYG{n}{gState}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{Graphic} \PYG{n}{state} \PYG{n}{to} \PYG{n}{apply} \PYG{n}{to} \PYG{n}{operation} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{char} \PYG{o}{*}\PYG{n}{HelloWorldStr} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello There}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{Text} \PYG{n}{to} \PYG{n}{write} \PYG{n}{to} \PYG{n}{the} \PYG{n}{PDF}
\PYG{c+c1}{\PYGZsh{}ifdef MAC\PYGZus{}ENV}
  \PYG{n}{ASPathName} \PYG{n}{macPath}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}


\PYG{o}{/}\PYG{o}{*}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{*}
                  \PYG{n}{Create} \PYG{n}{the} \PYG{n}{doc}\PYG{p}{,} \PYG{n}{page}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{content} \PYG{n}{container}
\PYG{o}{*}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{*}\PYG{o}{/}

\PYG{n}{DURING}

  \PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{PDDocCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                    \PYG{o}{/}\PYG{o}{*} \PYG{n}{Create} \PYG{n}{new} \PYG{n}{document}  \PYG{o}{*}\PYG{o}{/}

  \PYG{n}{mediaBox}\PYG{o}{.}\PYG{n}{left}   \PYG{o}{=} \PYG{n}{fixedZero}\PYG{p}{;}              \PYG{o}{/}\PYG{o}{*} \PYG{n}{Dimensions} \PYG{n}{of} \PYG{n}{page}   \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{mediaBox}\PYG{o}{.}\PYG{n}{top}    \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{In} \PYG{n}{this} \PYG{n}{case} \PYG{l+m+mi}{5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ x 4}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{mediaBox}\PYG{o}{.}\PYG{n}{right}  \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{mediaBox}\PYG{o}{.}\PYG{n}{bottom} \PYG{o}{=} \PYG{n}{fixedZero}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{page} \PYG{k}{with} \PYG{n}{those} \PYG{n}{dimensions} \PYG{o+ow}{and} \PYG{n}{insert} \PYG{n}{it} \PYG{k}{as} \PYG{n}{the} \PYG{n}{first} \PYG{n}{page}
  \PYG{n}{pdPage} \PYG{o}{=} \PYG{n}{PDDocCreatePage}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{PDBeforeFirstPage}\PYG{p}{,} \PYG{n}{mediaBox}\PYG{p}{)}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{/}\PYG{n}{Acquire} \PYG{n}{a} \PYG{n}{PDEContent} \PYG{n}{container} \PYG{k}{for} \PYG{n}{the} \PYG{n}{page}
  \PYG{n}{pdeContent} \PYG{o}{=} \PYG{n}{PDPageAcquirePDEContent}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{*}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{*}
      \PYG{n}{Acquire} \PYG{n}{a} \PYG{n}{font}\PYG{p}{,} \PYG{n}{add} \PYG{n}{text}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{insert} \PYG{n}{into} \PYG{n}{page} \PYG{n}{content} \PYG{n}{container}
\PYG{o}{*}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{*}\PYG{o}{/}

  \PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n}{size} \PYG{n}{of} \PYG{n}{the} \PYG{n}{PDSysFont} \PYG{o+ow}{and} \PYG{n+nb}{set} \PYG{n}{its} \PYG{n}{attributes}
  \PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdeFontAttrs}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{pdeFontAttrs}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{pdeFontAttrs}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CourierStd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{pdeFontAttrs}\PYG{o}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Type1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{sysFont} \PYG{o}{=} \PYG{n}{PDFindSysFont}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdeFontAttrs}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{PDEFontAttrs}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{pdeFont} \PYG{o}{=} \PYG{n}{PDEFontCreateFromSysFont}\PYG{p}{(}\PYG{n}{sysFont}\PYG{p}{,} \PYG{n}{kPDEFontDoNotEmbed}\PYG{p}{)}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{*} \PYG{n}{The} \PYG{n}{following} \PYG{n}{code} \PYG{n}{sets} \PYG{n}{up} \PYG{n}{the} \PYG{n}{default} \PYG{n}{graphics} \PYG{n}{state}\PYG{o}{.}  \PYG{n}{We} \PYG{n}{do} \PYG{n}{this} \PYG{n}{so} \PYG{n}{that}
   \PYG{o}{*} \PYG{n}{we} \PYG{n}{can} \PYG{n}{free} \PYG{n}{the} \PYG{n}{PDEColorSpace} \PYG{n}{objects}
   \PYG{o}{*}\PYG{o}{/}

  \PYG{o}{/}\PYG{o}{/}\PYG{n}{PDEColorSpace} \PYG{n}{pdeColorSpace}\PYG{p}{;} \PYG{o}{/}\PYG{o}{*} \PYG{n}{ColorSpace} \PYG{o}{*}\PYG{o}{/}
  \PYG{o}{/}\PYG{o}{/}\PYG{n}{PDEGraphicState} \PYG{n}{gState}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{Graphic} \PYG{n}{state} \PYG{n}{to} \PYG{n}{apply} \PYG{n}{to} \PYG{n}{operation} \PYG{o}{*}\PYG{o}{/}

  \PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDEGraphicState} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n+nb}{set} \PYG{n}{its} \PYG{n}{attributes}
  \PYG{n}{pdeColorSpace} \PYG{o}{=} \PYG{n}{PDEColorSpaceCreateFromName}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DeviceGray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{gState}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{PDEGraphicState}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{gState}\PYG{o}{.}\PYG{n}{strokeColorSpec}\PYG{o}{.}\PYG{n}{space} \PYG{o}{=} \PYG{n}{gState}\PYG{o}{.}\PYG{n}{fillColorSpec}\PYG{o}{.}\PYG{n}{space} \PYG{o}{=} \PYG{n}{pdeColorSpace}\PYG{p}{;}
  \PYG{n}{gState}\PYG{o}{.}\PYG{n}{miterLimit} \PYG{o}{=} \PYG{n}{fixedTen}\PYG{p}{;}
  \PYG{n}{gState}\PYG{o}{.}\PYG{n}{flatness} \PYG{o}{=} \PYG{n}{fixedOne}\PYG{p}{;}
  \PYG{n}{gState}\PYG{o}{.}\PYG{n}{lineWidth} \PYG{o}{=} \PYG{n}{fixedOne}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASFixedMatrix} \PYG{n+nb}{object}
  \PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{textMatrix}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{textMatrix}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{Set} \PYG{n}{the} \PYG{n}{buffer} \PYG{n}{size} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{textMatrix}\PYG{o}{.}\PYG{n}{a} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{;}     \PYG{o}{/}\PYG{o}{*} \PYG{n}{Set} \PYG{n}{font} \PYG{n}{width} \PYG{o+ow}{and} \PYG{n}{height} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{textMatrix}\PYG{o}{.}\PYG{n}{d} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{;}     \PYG{o}{/}\PYG{o}{*} \PYG{n}{to} \PYG{l+m+mi}{24} \PYG{n}{point} \PYG{n}{size}       \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{textMatrix}\PYG{o}{.}\PYG{n}{h} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}   \PYG{o}{/}\PYG{o}{*} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y} \PYG{n}{coordinate} \PYG{n}{on} \PYG{n}{page} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{textMatrix}\PYG{o}{.}\PYG{n}{v} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}   \PYG{o}{/}\PYG{o}{*} \PYG{n}{In} \PYG{n}{this} \PYG{n}{case}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ x 2}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{o}{*}\PYG{o}{/}

  \PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDEText} \PYG{n+nb}{object}
  \PYG{n}{pdeText} \PYG{o}{=} \PYG{n}{PDETextCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}           \PYG{o}{/}\PYG{o}{*} \PYG{n}{Create} \PYG{n}{new} \PYG{n}{text} \PYG{n}{run}    \PYG{o}{*}\PYG{o}{/}

  \PYG{n}{PDETextAdd}\PYG{p}{(}\PYG{n}{pdeText}\PYG{p}{,}       \PYG{o}{/}\PYG{o}{*} \PYG{n}{Text} \PYG{n}{container} \PYG{n}{to} \PYG{n}{add} \PYG{n}{to}  \PYG{o}{*}\PYG{o}{/}
      \PYG{n}{kPDETextRun}\PYG{p}{,}          \PYG{o}{/}\PYG{o}{*} \PYG{n}{kPDETextRun}\PYG{p}{,} \PYG{n}{kPDETextChar} \PYG{o}{*}\PYG{o}{/}
      \PYG{l+m+mi}{0}\PYG{p}{,}                    \PYG{o}{/}\PYG{o}{*} \PYG{n}{Index} \PYG{o}{*}\PYG{o}{/}
      \PYG{n}{HelloWorldStr}\PYG{p}{,}        \PYG{o}{/}\PYG{o}{*} \PYG{n}{Text} \PYG{n}{to} \PYG{n}{add}    \PYG{o}{*}\PYG{o}{/}
      \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{HelloWorldStr}\PYG{p}{)}\PYG{p}{,}\PYG{o}{/}\PYG{o}{*} \PYG{n}{Length} \PYG{n}{of} \PYG{n}{text} \PYG{o}{*}\PYG{o}{/}
      \PYG{n}{pdeFont}\PYG{p}{,}              \PYG{o}{/}\PYG{o}{*} \PYG{n}{Font} \PYG{n}{to} \PYG{n}{apply} \PYG{n}{to} \PYG{n}{text} \PYG{o}{*}\PYG{o}{/}
      \PYG{o}{\PYGZam{}}\PYG{n}{gState}\PYG{p}{,}
      \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{gState}\PYG{p}{)}\PYG{p}{,}        \PYG{o}{/}\PYG{o}{*} \PYG{n}{Graphic} \PYG{n}{state} \PYG{n}{to} \PYG{n}{apply} \PYG{n}{to} \PYG{n}{text}  \PYG{o}{*}\PYG{o}{/}
      \PYG{n}{NULL}\PYG{p}{,}
      \PYG{l+m+mi}{0}\PYG{p}{,}                     \PYG{o}{/}\PYG{o}{*} \PYG{n}{Text} \PYG{n}{state} \PYG{o+ow}{and} \PYG{n}{size} \PYG{n}{of} \PYG{n}{structure}\PYG{o}{*}\PYG{o}{/}
      \PYG{o}{\PYGZam{}}\PYG{n}{textMatrix}\PYG{p}{,}           \PYG{o}{/}\PYG{o}{*} \PYG{n}{Transformation} \PYG{n}{matrix} \PYG{k}{for} \PYG{n}{text}  \PYG{o}{*}\PYG{o}{/}
      \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}                 \PYG{o}{/}\PYG{o}{*} \PYG{n}{Stroke} \PYG{n}{matrix}  \PYG{o}{*}\PYG{o}{/}

  \PYG{o}{/}\PYG{o}{*} \PYG{n}{Insert} \PYG{n}{text} \PYG{n}{into} \PYG{n}{the} \PYG{n}{page} \PYG{n}{content} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{PDEContentAddElem}\PYG{p}{(}\PYG{n}{pdeContent}\PYG{p}{,} \PYG{n}{kPDEAfterLast}\PYG{p}{,} \PYG{p}{(}\PYG{n}{PDEElement}\PYG{p}{)} \PYG{n}{pdeText}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{*}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{*}
          \PYG{n}{Convert} \PYG{n}{to} \PYG{n}{objects}\PYG{p}{,} \PYG{n}{add} \PYG{n}{to} \PYG{n}{page}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{release} \PYG{n}{resources}
\PYG{o}{*}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{*}\PYG{o}{/}

  \PYG{o}{/}\PYG{o}{*} \PYG{n}{Set} \PYG{n}{the} \PYG{n}{PDEContent} \PYG{k}{for} \PYG{n}{the} \PYG{n}{page} \PYG{o}{*}\PYG{o}{/}
  \PYG{n}{b} \PYG{o}{=} \PYG{n}{PDPageSetPDEContent}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

  \PYG{o}{/}\PYG{o}{*} \PYG{n}{Save} \PYG{n}{document} \PYG{n}{to} \PYG{n}{a} \PYG{n}{file} \PYG{o}{*}\PYG{o}{/}
\PYG{c+c1}{\PYGZsh{}if !MAC\PYGZus{}ENV}
  \PYG{n}{PDDocSave}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{PDSaveFull} \PYG{o}{|} \PYG{n}{PDSaveLinearized}\PYG{p}{,}\PYG{n}{ASPathFromPlatformPath}

\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{out.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}else}
  \PYG{n}{macPath} \PYG{o}{=} \PYG{n}{GetMacPath}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{out.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{PDDocSave}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{PDSaveFull} \PYG{o}{|} \PYG{n}{PDSaveLinearized}\PYG{p}{,} \PYG{n}{macPath}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ASFileSysReleasePath}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,}\PYG{n}{macPath}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}


  \PYG{o}{/}\PYG{o}{/}\PYG{n}{Release} \PYG{n+nb}{all} \PYG{n}{objects}
  \PYG{n}{PDERelease}\PYG{p}{(}\PYG{p}{(}\PYG{n}{PDEObject}\PYG{p}{)} \PYG{n}{pdeFont}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{PDERelease}\PYG{p}{(}\PYG{p}{(}\PYG{n}{PDEObject}\PYG{p}{)} \PYG{n}{pdeText}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{i} \PYG{o}{=} \PYG{n}{PDPageReleasePDEContent}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{PDERelease}\PYG{p}{(}\PYG{p}{(}\PYG{n}{PDEObject}\PYG{p}{)}\PYG{n}{pdeColorSpace}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{PDPageRelease}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{PDDocRelease}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{HANDLER}
  \PYG{n}{ASGetErrorString}\PYG{p}{(}\PYG{n}{ERRORCODE}\PYG{p}{,} \PYG{n}{buf}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error code: }\PYG{l+s+si}{\PYGZpc{}ld}\PYG{l+s+s2}{, Error Message: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ERRORCODE}\PYG{p}{,} \PYG{n}{buf}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{exit} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{END\PYGZus{}HANDLER}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{}define INCLUDE\PYGZus{}MYPDFLIBAPP\PYGZus{}CPP   1}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}MyPDFLibApp.cpp\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}undef INCLUDE\PYGZus{}MYPDFLIBAPP\PYGZus{}CPP}
\end{sphinxVerbatim}


\chapter{Working with Documents and Files}
\label{\detokenize{Plugins_Documents:working-with-documents-and-files}}\label{\detokenize{Plugins_Documents::doc}}
You can use the Acrobat core API to perform operations on PDFs and files, including opening a PDF in an external window. When working with documents and files, use the following typedefs:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVDoc}} typedef (from the AV layer) represents a document as a window in Acrobat or Adobe Reader. A single \sphinxcode{\sphinxupquote{AVDoc}} object exists for each displayed document. Operations on \sphinxcode{\sphinxupquote{AVDoc}} objects are usually visual modifications to the document’s view.

\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} typedef (from the PD layer) represents a document as a PDF file. You work with \sphinxcode{\sphinxupquote{PDDoc}} objects to make changes to a document’s contents. Using a \sphinxcode{\sphinxupquote{PDDoc}} object, you can access components, such as a \sphinxcode{\sphinxupquote{PDPage}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASFile}} typedef (from the AS layer) represents a document as an open file.

\end{itemize}


\section{Opening PDFs}
\label{\detokenize{Plugins_Documents:opening-pdfs}}
You can use the Acrobat core API to create application logic that opens a PDF in Acrobat or Adobe Reader. The method that opens a PDF file is \sphinxcode{\sphinxupquote{AVDocOpenFromFile}}. Before you invoke this method, you must create an \sphinxcode{\sphinxupquote{ASPathName}} object, which is a platform\sphinxhyphen{}independent path value that specifies the PDF file to open.

With Acrobat or Adobe Reader 8.0 and later, you can open PDFs that are based on Unicode\sphinxhyphen{}named files. (See \sphinxhref{Plugins\_Unicode.html\#50618402\_14583}{Working with Unicode Paths}.)

You can create an \sphinxcode{\sphinxupquote{ASPathName}} object by using different techniques. This section describes how to create an \sphinxcode{\sphinxupquote{ASPathName}} object by invoking the \sphinxcode{\sphinxupquote{ASFileSysCreatePathName}} method to convert a platform specific path name to an \sphinxcode{\sphinxupquote{ASPathName}} object. This method requires the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASFileSys}} object that represents the file system in which you are creating an \sphinxcode{\sphinxupquote{ASPathName}} object. (See \sphinxhref{Plugins\_Unicode.html\#50618402\_67382}{Creating an ASFileSys object}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that specifies the data type of the third argument. You can specify \sphinxcode{\sphinxupquote{Cstring}}, which is accepted by the default file system on all platforms. In Windows, the path can be absolute (\sphinxcode{\sphinxupquote{C:folderfile.pdf}} ) or relative (\sphinxcode{\sphinxupquote{...folderfile.pdf}} ). In Mac OS, it must be an absolute path separated by colons (\sphinxcode{\sphinxupquote{VolumeName:Folder:file.pdf}} ). For information about additional supported values, see the \sphinxcode{\sphinxupquote{ASFileSysCreatePathName}} method in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\item {} 
A null\sphinxhyphen{} terminated character that specifies the PDF file on which the \sphinxcode{\sphinxupquote{ASPathName}} object is based.

\item {} 
A null\sphinxhyphen{} terminated character that specifies additional data that you can use. You can pass \sphinxcode{\sphinxupquote{NULL}}. For more information, see the \sphinxcode{\sphinxupquote{ASFileSysCreatePathName}} method in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\end{itemize}

The \sphinxcode{\sphinxupquote{ASFileSysCreatePathName}} method returns an \sphinxcode{\sphinxupquote{ASPathName}} object. You can also create an \sphinxcode{\sphinxupquote{ASPathName}} object by displaying an open dialog box. (See \sphinxhref{Plugins\_Documents.html\#50618416\_57499}{Displaying an open dialog box}.)

To programmatic\sphinxhyphen{}ally open a PDF file in Acrobat or Adobe Reader, invoke the \sphinxcode{\sphinxupquote{AVDocOpenFromFile}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASPathName}} object that specifies the PDF file to open.

\item {} 
An \sphinxcode{\sphinxupquote{ASFileSys}} object that represents the file system in which the PDF file is located. (See \sphinxhref{Plugins\_Unicode.html\#50618402\_67382}{Creating an ASFileSys object}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASText}} object that specifies a string value to display in the Adobe Reader or Acrobat title bar.

\end{itemize}

The following code example opens a PDF that is based on a file named PurchaseOrder.pdf.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Specify} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{file} \PYG{n}{to} \PYG{n+nb}{open} \PYG{p}{(}\PYG{n}{host} \PYG{n}{encoded} \PYG{n}{names} \PYG{n}{only}\PYG{p}{)}
   \PYG{n}{const} \PYG{n}{char}\PYG{o}{*} \PYG{n}{myPath} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:PurchaseOrder.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
   \PYG{n}{ASAtom} \PYG{n}{pathType} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cstring}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASText} \PYG{n+nb}{object}
   \PYG{n}{ASText} \PYG{n}{titleText} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASTextSetPDText}\PYG{p}{(}\PYG{n}{titleText}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This PDF was opened by using the Acrobat SDK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASPathName} \PYG{n+nb}{object}
   \PYG{n}{ASFileSys} \PYG{n}{fileSys} \PYG{o}{=} \PYG{n}{ASGetDefaultFileSysForPath}\PYG{p}{(}\PYG{n}{pathType}\PYG{p}{,} \PYG{n}{myPath}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASPathName} \PYG{n}{pathName} \PYG{o}{=} \PYG{n}{ASFileSysCreatePathName}\PYG{p}{(}\PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{pathType}\PYG{p}{,} \PYG{n}{myPath}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Open} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{file}
   \PYG{n}{AVDoc} \PYG{n}{myDoc} \PYG{o}{=} \PYG{n}{AVDocOpenFromFile}\PYG{p}{(}\PYG{n}{pathName}\PYG{p}{,} \PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{titleText}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Do} \PYG{n}{some} \PYG{n}{clean} \PYG{n}{up}

   \PYG{n}{ASFileSysReleasePath}\PYG{p}{(}\PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{pathName}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASTextDestroy}\PYG{p}{(}\PYG{n}{titleText}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Opening a PDF in an external window}
\label{\detokenize{Plugins_Documents:opening-a-pdf-in-an-external-window}}
You can use the Acrobat core API to open a PDF in an external window. For example, from within Adobe Reader or Acrobat, you can let a user select a PDF file and then display the PDF in an external window. This lets a user view two separate PDFs at the same time.

The following image shows a PDF displayed in an external window.

\noindent\sphinxincludegraphics{{ExterWin}.png}

In addition to using the typedefs introduced in this chapter, you must also use the following typedefs to open a PDF in an external window:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{AVDocOpenParamsRec}} \sphinxhyphen{} defines required parameters for opening a PDF in a window. This typedef lets you control the external window’s size, location, and visibility.

\item {} 
\sphinxcode{\sphinxupquote{ExternalDocServerCreationDataRec}} \sphinxhyphen{} defines data that is used in conjunction with an \sphinxcode{\sphinxupquote{AVDoc}} object that is displayed in an external window.

\end{itemize}

To open a PDF in an external window, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a new window.

\item {} 
Create an \sphinxcode{\sphinxupquote{AVDocOpenParamsRec}} object.

\item {} 
Create a \sphinxcode{\sphinxupquote{ExternalDocServerCreationDataRec}} object.

\item {} 
Display an open dialog box to enable a user to retrieve a PDF file to open.

\item {} 
Display the PDF that the user selected within a window.

\end{enumerate}


\subsection{Creating a Window}
\label{\detokenize{Plugins_Documents:creating-a-window}}
You must programmatic\sphinxhyphen{}ally create the external window in which to display a PDF. To create a window, you invoke standard platform C functions and not the Acrobat core API. For example, if you are creating your plugin in Windows, you can use the Win32 API to create a window. In this situation, part of the process of creating a window is to register the window class and define the window procedure. After you perform these tasks, you can obtain a handle to the window by invoking the \sphinxcode{\sphinxupquote{CreateWindow}} function. For information about this function, see the MSDN online help at \sphinxurl{http://msdn.microsoft.com/library/default.asp}.

\begin{sphinxadmonition}{note}{Note:}
Application logic that creates a window is shown in \sphinxhref{Plugins\_Documents.html\#50618416\_11768}{Opening a PDF in an external window}.
\end{sphinxadmonition}


\subsection{Defining the parameters for an external window}
\label{\detokenize{Plugins_Documents:defining-the-parameters-for-an-external-window}}
You must create an \sphinxcode{\sphinxupquote{AVDocOpenParamsRec}} object in order to open and display a PDF in an external window. This object defines required parameters for opening a PDF within an external window. After you create an \sphinxcode{\sphinxupquote{AVDocOpenParamsRec}} object, allocate its buffer size and set the following attributes:
\begin{itemize}
\item {} 
\sphinxstylestrong{size}: The size of the data structure. This attribute must be set to \sphinxcode{\sphinxupquote{sizeof(AVDocOpenParamsRec)}}.

\item {} 
\sphinxstylestrong{useFrame}: If \sphinxcode{\sphinxupquote{true}}, the \sphinxcode{\sphinxupquote{frame}} attribute specifies the size and location of the window in which the PDF is displayed. If \sphinxcode{\sphinxupquote{false}}, the \sphinxcode{\sphinxupquote{frame}} attribute is ignored and a default frame is used.

\item {} 
\sphinxstylestrong{frame}: An \sphinxcode{\sphinxupquote{AVRect}} object specifying the size and location of the window in which the PDF is displayed. In the Windows operating system, the coordinates are MDI client coordinates. In Mac OS, the coordinates are global screen coordinates. This attribute is ignored if the \sphinxcode{\sphinxupquote{useFrame}} attribute is \sphinxcode{\sphinxupquote{false}}.

\item {} 
\sphinxstylestrong{useVisible}: If \sphinxcode{\sphinxupquote{true}}, the \sphinxcode{\sphinxupquote{visible}} attribute determines whether the window is visible after the PDF is opened. If this attribute is \sphinxcode{\sphinxupquote{false}}, then the \sphinxcode{\sphinxupquote{visible}} attribute is ignored.

\item {} 
\sphinxstylestrong{visible}: Specifies the window’s visibility. If this attribute is \sphinxcode{\sphinxupquote{false}} and the \sphinxcode{\sphinxupquote{useVisible}} attribute is \sphinxcode{\sphinxupquote{true}}, then the \sphinxcode{\sphinxupquote{frame}} attribute is ignored regardless of the value of the \sphinxcode{\sphinxupquote{useFrame}} attribute.

\end{itemize}

If you are using the Windows operating system and this attribute is \sphinxcode{\sphinxupquote{true}}, the PDF is opened in a visible window. If this attribute is false, the PDF is opened in a minimized window. This attribute is ignored if the \sphinxcode{\sphinxupquote{useVisible}} attribute is \sphinxcode{\sphinxupquote{false}}.
\begin{itemize}
\item {} 
\sphinxstylestrong{useServerType}: An \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether the \sphinxcode{\sphinxupquote{serverType}} and \sphinxcode{\sphinxupquote{serverCreationData}} attributes are used.

\item {} 
\sphinxstylestrong{serverType}: The name of the \sphinxcode{\sphinxupquote{AVDoc}} server for this \sphinxcode{\sphinxupquote{AVDoc}} object. Specify \sphinxcode{\sphinxupquote{EXTERNAL}} for an external window.

\item {} 
\sphinxstylestrong{serverCreationData}: Platform\sphinxhyphen{}dependent server data to associate with the \sphinxcode{\sphinxupquote{AVDoc}} server. If the \sphinxcode{\sphinxupquote{serverType}} attribute is \sphinxcode{\sphinxupquote{EXTERNAL}}, this attribute must be assigned the address of the \sphinxcode{\sphinxupquote{ExternalDocServerCreationData}} object.

\item {} 
\sphinxstylestrong{useViewType}: An \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether the \sphinxcode{\sphinxupquote{viewType}} attribute is used.

\item {} 
\sphinxstylestrong{viewType}: Specifies the appearance of the window that contains the PDF. The following values are valid:
\begin{itemize}
\item {} 
\sphinxstylestrong{AVPageView}: Displays only the page view of the document. User interface components such as display scrollbars, toolbars, bookmarks, and thumbnails panes are not displayed. Annotations, such as links, are active.

\item {} 
\sphinxstylestrong{AVDocView}: Displays the page view of the document as well as scroll bars, bookmarks, and the thumbnails pane. Annotations, such as links, are active.

\item {} 
\sphinxstylestrong{AVExternalView}: Displays the page view of the document as well as scroll bars, toolbars, bookmarks, and the thumbnails pane. Annotations, such as links, are active.

\item {} 
\sphinxstylestrong{AVEmbeddedView}: Embeds the PDF file in an external document such as an HTML file. The first page of the PDF is displayed; however, user\sphinxhyphen{}interface component such as scroll bars, toolbars, bookmarks, and the thumbnails pane are not displayed. Annotations, such as links, are not displayed or active.

\end{itemize}

\item {} 
\sphinxstylestrong{useReadOnly}: An \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether the \sphinxcode{\sphinxupquote{ReadOnly}} attribute is used.

\item {} 
\sphinxstylestrong{readOnly}: An \sphinxcode{\sphinxupquote{ASBool}} value that opens the document in read\sphinxhyphen{}only mode if set to \sphinxcode{\sphinxupquote{true}}.

\item {} 
\sphinxstylestrong{useSourceDoc}: An \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether the \sphinxcode{\sphinxupquote{SourceDoc}} attribute is used.

\item {} 
\sphinxstylestrong{sourceDoc}: An \sphinxcode{\sphinxupquote{AVDoc}} whose window is taken over by the new PDF.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Application logic that creates an \sphinxcode{\sphinxupquote{AVDocOpenParamsRec}} object is shown in \sphinxhref{Plugins\_Documents.html\#50618416\_11768}{Opening a PDF in an external window}.
\end{sphinxadmonition}


\subsection{Creating a handler for an external window}
\label{\detokenize{Plugins_Documents:creating-a-handler-for-an-external-window}}
You must create an \sphinxcode{\sphinxupquote{ExternalDocServerCreationDataRec}} object in order to open a PDF in an external window. This object contains callback functions that implement a window handler. After you create an \sphinxcode{\sphinxupquote{ExternalDocServerCreationDataRec}} object, allocate its buffer size and set the following attributes:
\begin{itemize}
\item {} 
\sphinxstylestrong{size}: The size of the data structure. This attribute must be set to \sphinxcode{\sphinxupquote{sizeof(ExternalDocServerCreationDataRec)}}.

\item {} 
\sphinxstylestrong{platformWindow}: A platform\sphinxhyphen{}dependent structure of type \sphinxcode{\sphinxupquote{ExternalDocWindowData}} representing a window. This is a platform specific value:
\begin{itemize}
\item {} 
\sphinxstylestrong{Windows}: use a \sphinxcode{\sphinxupquote{HWND}} value cast as \sphinxcode{\sphinxupquote{ExternalDocWindowData}}

\item {} 
\sphinxstylestrong{Mac OS}: use an \sphinxcode{\sphinxupquote{ExternalDocWindowData}} object

\end{itemize}

\item {} 
\sphinxstylestrong{acrobatProc}: An \sphinxcode{\sphinxupquote{AVExecuteProc}} callback that is invoked when the Acrobat button (if present) is clicked in an external application. This attribute is optional.

\item {} 
\sphinxstylestrong{acrobatProcData}: Client specific data that is used in the \sphinxcode{\sphinxupquote{AVExecuteProc}} callback. This attribute is optional.

\end{itemize}

For a complete list of attributes that belong to an \sphinxcode{\sphinxupquote{ExternalDocServerCreationDataRec}} object, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\begin{sphinxadmonition}{note}{Note:}
Application logic that creates an \sphinxcode{\sphinxupquote{ExternalDocServerCreationDataRec}} object is shown in \sphinxhref{Plugins\_Documents.html\#50618416\_11768}{Opening a PDF in an external window}.
\end{sphinxadmonition}


\subsection{Displaying an open dialog box}
\label{\detokenize{Plugins_Documents:displaying-an-open-dialog-box}}
You can display an open dialog box that enables a user to select a PDF to open. In addition to describing how to create an open dialog box, this section also describes how to use a dialog box to create an \sphinxcode{\sphinxupquote{ASPathName}} object and an \sphinxcode{\sphinxupquote{ASFileSys}} object, which are both used to open a PDF.

The Acrobat core API has a typedef named \sphinxcode{\sphinxupquote{AVOpenSaveDialogParamsRec}} that you use to display an open dialog box. The \sphinxcode{\sphinxupquote{AVOpenSaveDialogParamsRec}} typedef contains the following attributes that you programmatic\sphinxhyphen{}ally set:
\begin{itemize}
\item {} 
\sphinxstylestrong{size}: The size of the \sphinxcode{\sphinxupquote{AVOpenSaveDialogParamsRec}} object’s buffer.

\item {} 
\sphinxstylestrong{flags}: An \sphinxcode{\sphinxupquote{AVOpenSaveDialogFlags}} value that specifies the dialog box’s appearance. The following values are valid:
\begin{itemize}
\item {} 
\sphinxstylestrong{kAVOpenSaveAllowAllFlag}: Specifies \sphinxcode{\sphinxupquote{All Files}} \sphinxcode{\sphinxupquote{(*.*)}} for the dialog box. This value is only applicable for an open dialog box.

\item {} 
\sphinxstylestrong{kAVOpenSaveAllowMultiple}: Allows multiple files to be opened through the dialog box. This value is only applicable for an open dialog box.

\item {} 
\sphinxstylestrong{kAVOpenSaveAllowForeignFileSystems}: Allows file systems other than the default to be used to open the files. You need to select this value to open Unicode\sphinxhyphen{}named files. This value is only applicable for an open dialog box.

\item {} 
\sphinxstylestrong{kAVOpenSaveAllowSettingsButton}: Adds a settings button to the dialog box. This value is applicable to both open and save dialog boxes.

\item {} 
\sphinxstylestrong{kAVOpenSaveMergeTogetherPassedFilters}: Meaningful only for open dialog boxes with more than one filter.

\end{itemize}

\item {} 
\sphinxstylestrong{parentWindow}: An \sphinxcode{\sphinxupquote{AVWindow}} object that specifies the parent window for the dialog box. This attribute is ignored on Mac OS.

\item {} 
\sphinxstylestrong{windowTitle}: An \sphinxcode{\sphinxupquote{ASText}} object that specifies the title for the dialog box. This attribute can be \sphinxcode{\sphinxupquote{NULL}}, in which case the default title is used.

\item {} 
\sphinxstylestrong{actionButtonTitle}: An \sphinxcode{\sphinxupquote{ASText}} object that specifies the title of the action button. This attribute can be \sphinxcode{\sphinxupquote{NULL}}, in which case the default title is used.

\item {} 
\sphinxstylestrong{cancelButtonTitle}: An \sphinxcode{\sphinxupquote{ASText}} object that specifies the title of the cancel button. This attribute can be \sphinxcode{\sphinxupquote{NULL}}, in which case the default title is used.

\item {} 
\sphinxstylestrong{initialFileSys}: An \sphinxcode{\sphinxupquote{ASFileSys}} object that specifies the default file system. This value can be \sphinxcode{\sphinxupquote{NULL}} if the \sphinxcode{\sphinxupquote{flags}} attribute does not contain \sphinxcode{\sphinxupquote{kAVOpenSaveAllowForeignFileSystems}}.

\item {} 
\sphinxstylestrong{initialPathName}: An \sphinxcode{\sphinxupquote{ASPathName}} object that specifies an initial path location. This value can be \sphinxcode{\sphinxupquote{NULL}}.

\item {} 
\sphinxstylestrong{initialFileName}: Specifies an initial file to save. This value is ignored for an open dialog box.

\item {} 
\sphinxstylestrong{fileFilters}: An array of pointers to addresses of \sphinxcode{\sphinxupquote{AVFileFilterRec}} objects that act as a file filter (this attribute is set in the example that is described in this section).

\item {} 
\sphinxstylestrong{numFileFilters}: Specifies the number of \sphinxcode{\sphinxupquote{AVFileFilterRec}} pointers assigned to the \sphinxcode{\sphinxupquote{fileFilters}} attribute.

\end{itemize}

To display an open dialog box, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an \sphinxcode{\sphinxupquote{AVOpenSaveDialogParamsRec}} object.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVOpenSaveDialogParamsRec} \PYG{n}{dialogParams}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Create an \sphinxcode{\sphinxupquote{AVFileFilterRec}} object used to store a series of file type descriptors that define a file filter for an open or save dialog box. Secondly, create a pointer to an \sphinxcode{\sphinxupquote{AVFileFilterRec}}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVFileFilterRec} \PYG{n}{filterRec}\PYG{p}{,}\PYG{o}{*}\PYG{n}{filterRecP}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Create an \sphinxcode{\sphinxupquote{AVFileDescRec}} object used to store file extensions in an open dialog box.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVFileDescRec} \PYG{n}{descRec}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Set the \sphinxcode{\sphinxupquote{AVFileDescRec}} object’s \sphinxcode{\sphinxupquote{extension}} attribute with the value \sphinxcode{\sphinxupquote{PDF}}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{strcpy} \PYG{p}{(}\PYG{n}{descRec}\PYG{o}{.}\PYG{n}{extension}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Allocate the size of the \sphinxcode{\sphinxupquote{AVFileFilterRec}} object’s buffer by using the \sphinxcode{\sphinxupquote{memset}} method. Next, set the \sphinxcode{\sphinxupquote{AVFileFilterRec}} object’s \sphinxcode{\sphinxupquote{fileDescs}} and \sphinxcode{\sphinxupquote{numFileDescs}} attributes. The \sphinxcode{\sphinxupquote{fileDescs}} attribute defines file type and extension information. You can assign the address of the \sphinxcode{\sphinxupquote{AVFileDescRec}} object to the \sphinxcode{\sphinxupquote{fileDescs}} attribute. The \sphinxcode{\sphinxupquote{numFileDescs}} attribute specifies the number of \sphinxcode{\sphinxupquote{AVFileDescRecs}} objects assigned to the \sphinxcode{\sphinxupquote{fileDescs}} attribute.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{memset} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{filterRec}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{AVFileFilterRec}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{filterRec}\PYG{o}{.}\PYG{n}{fileDescs} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{descRec}\PYG{p}{;}
 \PYG{n}{filterRec}\PYG{o}{.}\PYG{n}{numFileDescs} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Assign the \sphinxcode{\sphinxupquote{AVFileFilterRec}} pointer with the address of the \sphinxcode{\sphinxupquote{AVFileFilterRec}} object (this pointer is used to set an attribute that belongs to the \sphinxcode{\sphinxupquote{AVOpenSaveDialogParamsRec}} object).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{filterRecP} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{filterRec}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
Set attributes that belong to the \sphinxcode{\sphinxupquote{AVOpenSaveDialogParamsRec}} object. In this example, the \sphinxcode{\sphinxupquote{size}}, \sphinxcode{\sphinxupquote{fileFilters}}, and \sphinxcode{\sphinxupquote{numFileFilters}} attributes are set. Assign the \sphinxcode{\sphinxupquote{fileFilters}} attribute with the address of the pointer that points to \sphinxcode{\sphinxupquote{AVFileFilterRec}}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{memset} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{dialogParams}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof} \PYG{p}{(}\PYG{n}{AVOpenSaveDialogParamsRec}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{dialogParams}\PYG{o}{.}\PYG{n}{size} \PYG{o}{=} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{AVOpenSaveDialogParamsRec}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{dialogParams}\PYG{o}{.}\PYG{n}{fileFilters} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{filterRecP}\PYG{p}{;}
 \PYG{n}{dialogParams}\PYG{o}{.}\PYG{n}{numFileFilters} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
Set the \sphinxcode{\sphinxupquote{AVFileFilterRec}} object’s \sphinxcode{\sphinxupquote{filterDescription}} attribute by invoking the \sphinxcode{\sphinxupquote{ASTextSetEncoded}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASText}} object that is used to store the string value.

\item {} 
A pointer to a \sphinxcode{\sphinxupquote{char}} data type.

\item {} 
An \sphinxcode{\sphinxupquote{ASHostEncoding}} value that specifies an encoding type.

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{filterRec}\PYG{o}{.}\PYG{n}{filterDescription} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{ASTextSetEncoded} \PYG{p}{(}\PYG{n}{filterRec}\PYG{o}{.}\PYG{n}{filterDescription}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Adobe PDF Files}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{n}{ASScriptToHostEncoding}\PYG{p}{(}\PYG{n}{kASRomanScript}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{8}
\item {} 
Set the \sphinxcode{\sphinxupquote{AVOpenSaveDialogParamsRec}} object’s \sphinxcode{\sphinxupquote{windowTitle}} attribute by invoking the \sphinxcode{\sphinxupquote{ASTextSetEncoded}} method (see step 8 for a description of this method).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dialogParams}\PYG{o}{.}\PYG{n}{windowTitle} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{ASTextSetEncoded} \PYG{p}{(}\PYG{n}{dialogParams}\PYG{o}{.}\PYG{n}{windowTitle}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Select A PDF}
 \PYG{n}{To} \PYG{n}{Open}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}
 \PYG{n}{ASScriptToHostEncoding}\PYG{p}{(}\PYG{n}{kASRomanScript}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{9}
\item {} 
Display the open dialog box by invoking the \sphinxcode{\sphinxupquote{AVAppOpenDialog}} method and passing the following arguments:

\end{enumerate}
\begin{itemize}
\item {} 
The address of an \sphinxcode{\sphinxupquote{AVOpenSaveDialogParams}} object that represents the dialog box to open.

\item {} 
The address of an \sphinxcode{\sphinxupquote{ASFileSys}} object. This method will populate the \sphinxcode{\sphinxupquote{ASFileSys}} object with the file system in which the file that the user selects is located. This argument can be \sphinxcode{\sphinxupquote{NULL}} if \sphinxcode{\sphinxupquote{kAVOpenSaveAllowForeignFileSystems}} is not set as the \sphinxcode{\sphinxupquote{flags}} value.

\item {} 
The address of a pointer that points to an \sphinxcode{\sphinxupquote{ASPathName}} typedef. This argument is populated with the file that was select by the user.

\item {} 
The address of an \sphinxcode{\sphinxupquote{AVArraySize}} object. This value can be NULL if \sphinxcode{\sphinxupquote{kAVOpenSaveAllowMultiple}} is not set as the \sphinxcode{\sphinxupquote{flags}} value.

\item {} 
The address of an \sphinxcode{\sphinxupquote{AVFilterIndex}} object. This value can be NULL.

\end{itemize}

The \sphinxcode{\sphinxupquote{AVAppOpenDialog}} method returns \sphinxcode{\sphinxupquote{true}} if the user clicks the action button (for example, the Open button). If the user clicks the Cancel button, the method returns \sphinxcode{\sphinxupquote{false}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASPathName} \PYG{o}{*} \PYG{n}{pathName} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{ASBool} \PYG{n}{bSelected} \PYG{o}{=} \PYG{n}{AVAppOpenDialog}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{dialogParams}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,}\PYG{p}{(}\PYG{n}{ASPathName}\PYG{o}{*}\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{pathName}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{10}
\item {} 
Release existing \sphinxcode{\sphinxupquote{ASText}} objects by invoking the \sphinxcode{\sphinxupquote{ASTextDestroy}} method.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASTextDestroy} \PYG{p}{(}\PYG{n}{filterRec}\PYG{o}{.}\PYG{n}{filterDescription}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{ASTextDestroy} \PYG{p}{(}\PYG{n}{dialogParams}\PYG{o}{.}\PYG{n}{windowTitle}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
This application logic is shown in \sphinxhref{Plugins\_Documents.html\#50618416\_11768}{Opening a PDF in an external window}.
\end{sphinxadmonition}


\subsection{Displaying a PDF in a window}
\label{\detokenize{Plugins_Documents:displaying-a-pdf-in-a-window}}
Before you attempt to display a PDF in an external window, you must programmatic\sphinxhyphen{}ally create the window. (See \sphinxhref{Plugins\_Documents.html\#50618416\_99182}{Creating a Window}.)

To display a PDF within an external window, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Open a PDF file by invoking the \sphinxcode{\sphinxupquote{ASFileSysOpenFile}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASFileSys}} object that represents the file system in which the PDF file is located. (See \sphinxhref{Plugins\_Unicode.html\#50618402\_67382}{Creating an ASFileSys object}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASPathName}} object that represents the path in which the PDF file is located.

\item {} 
An \sphinxcode{\sphinxupquote{ASFileMode}} object that represents the mode in which to open the file. For example, specify \sphinxcode{\sphinxupquote{ASFILE\_READ}} to open the PDF in read mode.

\item {} 
The address of an \sphinxcode{\sphinxupquote{ASFile}} object. This method populates this argument with the file that was opened (file information is obtained from the \sphinxcode{\sphinxupquote{ASPathName}} object).

\end{itemize}

\end{enumerate}

If the \sphinxcode{\sphinxupquote{ASFileSysOpenFile}} method is successful, then \sphinxcode{\sphinxupquote{0}} is returned. Otherwise, an error value is returned.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Display the PDF within the window by invoking the \sphinxcode{\sphinxupquote{AVDocOpenFromASFileWithParams}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASFile}} object that specifies a PDF file to display (you can use the same \sphinxcode{\sphinxupquote{ASFile}} object whose address was passed to the \sphinxcode{\sphinxupquote{ASFileSysOpenFile}} method).

\item {} 
An \sphinxcode{\sphinxupquote{ASText}} object that specifies the text to display in the window’s title bar. Create an \sphinxcode{\sphinxupquote{ASText}} object by invoking the \sphinxcode{\sphinxupquote{ASTextFromScriptText}} method.

\item {} 
The address of the \sphinxcode{\sphinxupquote{AVDocOpenParamsRec}} object that you created. (See \sphinxhref{Plugins\_Documents.html\#50618416\_64706}{Defining the parameters for an external window}.)

\end{itemize}

\end{enumerate}

The following code example opens a PDF in an external window. The application logic that is located within the \sphinxcode{\sphinxupquote{OpenExternalWindow}} user\sphinxhyphen{}defined function creates the window and displays a PDF within the window. A structure named \sphinxcode{\sphinxupquote{gDocInfo}} that stores information such as the file to open is also defined.

This code example contains a user\sphinxhyphen{}defined method named \sphinxcode{\sphinxupquote{AVWndProc}} that acts as a window procedure and another user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{InitializeWindowHandler}} that registers the windows class that is specified as an argument to \sphinxcode{\sphinxupquote{CreateWindow}}.

Also shown in this code example is application logic that displays an open dialog box that enables a user to select a PDF file to open. This application logic is located within a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{OpenPDFFile}}. (See \sphinxhref{Plugins\_Documents.html\#50618416\_57499}{Displaying an open dialog box}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   struct t\PYGZus{}ExternDocInfo
   \PYGZob{}
      AVDoc doc;
      ASFile file;
   \PYGZcb{} gDocInfo;

//Create a function that opens a PDF in an external window
   ACCB1 void ACCB2 OpenExternalWindow (void * data)

   \PYGZob{}

//Declare local variables
   ASPathName pathName;
   ASInt32 retVal;
   ASFileSys myFileSys;
   bool bWindowIsOpen = false;

//Create an AVDocOpenParamsRec object
   AVDocOpenParamsRec params;


//Declare an ExternalDocServerCreationDataRec object
   ExternalDocServerCreationDataRec creationData;

//Invoke CreateWindow to obtain a handle to a window
   HWND externHWnd = CreateWindow (\PYGZdq{}ExternalWindow\PYGZdq{}, \PYGZdq{}PDFViewer\PYGZdq{},
   WS\PYGZus{}OVERLAPPEDWINDOW,50, 50, 500, 500, 0, 0, gHINSTANCE, NULL);
   if (externHWnd)
   \PYGZob{}

//Set attributes that belong to the AVDocOpenParamsRec object
   memset(\PYGZam{}params, 0, sizeof(AVDocOpenParamsRec));
   params.size = sizeof(AVDocOpenParamsRec);
   params.useFrame = false;
   params.useVisible = true;
   params.visible = true;
   params.useServerType = true;
   params.serverType = \PYGZdq{}EXTERNAL\PYGZdq{};
   params.serverCreationData = (void*) \PYGZam{}creationData;
   params.useViewType = true;
   params.viewType = \PYGZdq{}AVDocView\PYGZdq{};
   params.useReadOnly = true;
   params.readOnly = true;
   params.useSourceDoc = false;
   params.useViewDef = false;

//Set attributes that belong to the ExternalDocServerCreationDataRec object

   memset(\PYGZam{}creationData, 0, sizeof(ExternalDocServerCreationDataRec));
   creationData.size = sizeof(ExternalDocServerCreationDataRec);
   creationData.platformWindow = (ExternalDocWindowData)externHWnd;
   creationData.acrobatProc = NULL;
   creationData.crossDocLinkWithDestData = (void *)externHWnd;

//Invoke OpenPDFFile to display an open dialog box that
//enables a user to select a PDF file
//Pass the address of the ASFileSys object
   pathName = OpenPDFFile(\PYGZam{}myFileSys);

//If PathName is valid
   if (pathName) \PYGZob{}

//Open the file specified in the file system
   retVal = ASFileSysOpenFile (myFileSys, pathName, ASFILE\PYGZus{}READ,
   \PYGZam{}gDocInfo.file);

   if (retVal ==0) \PYGZob{}

//Create a ASText object used to display in the new window
      ASText title = ASTextFromScriptText (\PYGZdq{}PDF Viewer\PYGZdq{}, kASRomanScript);

//Opens and displays a document from a file, using the specified

//parameters to control the window\PYGZsq{}s size, location, and visibility

      AVDocOpenFromASFileWithParams (gDocInfo.file, title, \PYGZam{}params);
         ASTextDestroy(title);
         bWindowIsOpen = true;
   \PYGZcb{} else
         AVAlertNote(\PYGZdq{}Failed to open document.\PYGZdq{});
   \PYGZcb{}
   \PYGZcb{}
   \PYGZcb{}

//Define the AVWndProc function
   LRESULT CALLBACK AVWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)

   \PYGZob{}
   if (msg == WM\PYGZus{}DESTROY)
   memset (\PYGZam{}gDocInfo, 0, sizeof(gDocInfo));
   return DefWindowProc (hwnd, msg, wParam, lParam);
   \PYGZcb{}

//Define the InitializeWindowHandler function
   ASBool InitializeWindowHandler (void)
   \PYGZob{}
   WNDCLASS wndClass ;

//This is the window class used to display the PDF
   wndClass.cbClsExtra     = 0;
   wndClass.hInstance      = gHINSTANCE;
   wndClass.style               = CS\PYGZus{}DBLCLKS;
   wndClass.hCursor          = (HCURSOR)NULL;
   wndClass.hbrBackground  = (HBRUSH)NULL;
   wndClass.lpfnWndProc    = AVWndProc;
   wndClass.hIcon               = (HICON)NULL;
   wndClass.lpszMenuName   = NULL;
   wndClass.cbWndExtra     = 0;
   wndClass.lpszClassName  = \PYGZdq{}ExternalWindow\PYGZdq{};

   if (!RegisterClass(\PYGZam{}wndClass))
   return false;
   return true;
   \PYGZcb{}


//Display an open dialog box that enables a user to select a PDF file
   ASPathName OpenPDFFile(ASFileSys * ASF)

   \PYGZob{}

//Declare an AVOpenSaveDialogParamsRec object
   AVOpenSaveDialogParamsRec dialogParams;

//Create local variables
   AVFileFilterRec filterRec,*filterRecP ;
   AVFileDescRec descRec;
   ASPathName * pathName = NULL;
   ASFileSys fileSys = NULL;
   ASBool bSelected = false;
   char errorBuf[256];

//Set up the PDF file filter description
   strcpy (descRec.extension, \PYGZdq{}pdf\PYGZdq{});
   descRec.macFileType = \PYGZsq{}PDF \PYGZsq{};
   descRec.macFileCreator = \PYGZsq{}CARO\PYGZsq{};

//Set attributes that belong to the AVFileFilterRec object
   memset (\PYGZam{}filterRec, 0, sizeof(AVFileFilterRec));
   filterRec.fileDescs = \PYGZam{}descRec;
   filterRec.numFileDescs = 1;
   filterRecP = \PYGZam{}filterRec;

//Set attributes that belong to the AVOpenSaveDialogParamsRec object
   memset (\PYGZam{}dialogParams, 0, sizeof (AVOpenSaveDialogParamsRec));
   dialogParams.size = sizeof(AVOpenSaveDialogParamsRec);
   dialogParams.fileFilters = \PYGZam{}filterRecP;
   dialogParams.numFileFilters = 1;

   DURING
//Set the AVFileFilterRec object\PYGZsq{}s filterDescription attribute
   filterRec.filterDescription = ASTextNew();
   ASTextSetEncoded (filterRec.filterDescription, \PYGZdq{}Adobe PDF Files\PYGZdq{},
   ASScriptToHostEncoding(kASRomanScript));

//Set the AVOpenSaveDialogParamsRec object\PYGZsq{}s windowTitle attribute
   dialogParams.windowTitle = ASTextNew();
   ASTextSetEncoded (dialogParams.windowTitle, \PYGZdq{}Select A PDF To

   Open\PYGZdq{},ASScriptToHostEncoding(kASRomanScript));

//Display the Open dialog box \PYGZhy{} pass the address of the ASFileSys object
   bSelected = AVAppOpenDialog(\PYGZam{}dialogParams, \PYGZam{}fileSys, (ASPathName**)\PYGZam{}pathName, NULL, NULL);

   HANDLER
//Display an error message to the user
   ASGetErrorString (ASGetExceptionErrorCode(), errorBuf, 256);
   AVAlertNote (errorBuf);
   END\PYGZus{}HANDLER

//Destroy the ASText object then return
   ASTextDestroy (filterRec.filterDescription);
   ASTextDestroy (dialogParams.windowTitle);

//Point the ASFileSys argument to the address of the ASFileSys object
   *ASF = fileSys;

   return bSelected ? *pathName : NULL;
   \PYGZcb{}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{OpenExternalWindow}} function can be invoked from an Adobe Reader or Acrobat user interface component, such as a toolbar button or a menu command. Ensure that the \sphinxcode{\sphinxupquote{InitializeWindowHandler}} method is invoked before the \sphinxcode{\sphinxupquote{OpenExternalWindow}} method; otherwise, the window class is not registered and the PDF file is not displayed in the external window.
\end{sphinxadmonition}


\section{Determining the PDF version}
\label{\detokenize{Plugins_Documents:determining-the-pdf-version}}
All PDFs contain PDF version information in the header, such as 1.7. Additionally, PDF files that conform to ISO 32000 can include PDF version extension information that indicates that the PDF may contain PDF extensions added by third\sphinxhyphen{}party developers.

The Acrobat API provides methods that let you obtain the PDF version and the PDF version extension information.


\subsection{PDF version}
\label{\detokenize{Plugins_Documents:pdf-version}}
The \sphinxcode{\sphinxupquote{PDDocGetVersion}} method lets you obtain the PDF version of a PDF. This PDF version indicates the PDF specification to which the document conforms, such as 1.4 or 1.7.


\subsection{PDF version extensions}
\label{\detokenize{Plugins_Documents:pdf-version-extensions}}
Acrobat 8.1 and later add extensions to the PDF specification. These extensions are specified in the \sphinxstyleemphasis{Adobe Supplement to ISO 32000}. Each extension in that supplement is associated with a base version and an extension level. The \sphinxcode{\sphinxupquote{Extensions}} dictionary located in the \sphinxcode{\sphinxupquote{Catalog}} dictionary specifies PDF extensions added by Adobe or others.

For example, Acrobat 8.1 added a PDF extension to 3D annotations that enabled support for the PRC format, a highly compressed 3D representation. If a PDF contains a 3D annotation that specifies a PRC file, the PDF also contains an \sphinxcode{\sphinxupquote{Extensions}} dictionary in the \sphinxcode{\sphinxupquote{Catalog}} dictionary that specifies a base version of 1.7 and an extension level of “1” or greater. The following PDF segment shows the appearance of such an \sphinxcode{\sphinxupquote{Extensions}} dictionary.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{n}{PDF} \PYG{l+m+mf}{1.7}
\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{/}\PYG{n}{Type} \PYG{o}{/}\PYG{n}{Catalog}
  \PYG{o}{/}\PYG{n}{Extensions}
  \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{/}\PYG{n}{ADBE}
      \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{o}{/}\PYG{n}{BaseVersion} \PYG{o}{/}\PYG{l+m+mf}{1.7} \PYG{o}{/}\PYG{n}{ExtensionLevel} \PYG{l+m+mi}{3} \PYG{o}{\PYGZgt{}\PYGZgt{}}
  \PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{o}{\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Setting the extension level of a document}
\label{\detokenize{Plugins_Documents:setting-the-extension-level-of-a-document}}
When you add PDF extensions specified by Adobe or others, you must ensure that the \sphinxcode{\sphinxupquote{Catalog}} dictionary contains an \sphinxcode{\sphinxupquote{Extensions}} dictionary that describes the greatest extension level that can appear in the PDF. The \sphinxcode{\sphinxupquote{Extensions}} dictionary can contain one dictionary for each company or other entity that adds PDF extensions.

To set the extension level, use the \sphinxcode{\sphinxupquote{Cos}} object methods described in \sphinxhref{Plugins\_Cos.html\#50618418\_86959}{Working with Cos Objects}.


\subsection{Getting the extension level of a document}
\label{\detokenize{Plugins_Documents:getting-the-extension-level-of-a-document}}
Beginning with Acrobat 9.0, the \sphinxcode{\sphinxupquote{PDDocGetVersionEx}} method lets you obtain the Adobe\sphinxhyphen{}specific version extension information and the PDF version.

To obtain version extension information introduced by entities other than Adobe, use the \sphinxcode{\sphinxupquote{Cos}} object methods described in \sphinxhref{Plugins\_Cos.html\#50618418\_86959}{Working with Cos Objects}.


\section{Bridging core API layers}
\label{\detokenize{Plugins_Documents:bridging-core-api-layers}}
To operate on the contents of a PDF, and not just manipulate its representation in Adobe Reader or Acrobat, you must use a \sphinxcode{\sphinxupquote{PDDoc}} object. For example, to create an annotation for a PDF, you must create a \sphinxcode{\sphinxupquote{PDDoc}} object. (See \sphinxhref{Plugins\_Annotations.html\#50618420\_98126}{Creating Annotations}.)

You can create a \sphinxcode{\sphinxupquote{PDDoc}} object by using an \sphinxcode{\sphinxupquote{AVDoc}} object. To get a \sphinxcode{\sphinxupquote{PDDoc}} object that corresponds to an \sphinxcode{\sphinxupquote{AVDoc}} object, invoke the \sphinxcode{\sphinxupquote{AVDocGetPDDoc}} method. This method is referred to as a bridge method because it allows your plugin to access other layers from the AV layer. There are several bridge methods which connect the different API layers (AV, PD, and Cos).

All \sphinxcode{\sphinxupquote{AVDoc}} objects have an underlying \sphinxcode{\sphinxupquote{PDDoc}} object. Operations on an \sphinxcode{\sphinxupquote{AVDoc}} object usually result in visible modifications to the document’s view. If you just want your plugin to make changes to a document’s contents, it can open a \sphinxcode{\sphinxupquote{PDDoc}} object directly (that is, without going through an \sphinxcode{\sphinxupquote{AVDoc}} object to get the \sphinxcode{\sphinxupquote{PDDo}} c object) and use PD layer methods.


\subsection{Creating a PDDoc object}
\label{\detokenize{Plugins_Documents:creating-a-pddoc-object}}
You can access a PDF file’s contents without displaying the PDF file in Acrobat or Adobe Reader. To perform this task, create a \sphinxcode{\sphinxupquote{PDDoc}} object by invoking the \sphinxcode{\sphinxupquote{PDDocOpen}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASPathName}} object that specifies the PDF file on which the \sphinxcode{\sphinxupquote{PDDoc}} is based. For information about creating an \sphinxcode{\sphinxupquote{ASPathName}} object, see \sphinxhref{Plugins\_Documents.html\#50618416\_65430}{Opening PDFs}.

\item {} 
An \sphinxcode{\sphinxupquote{ASFileSys}} object that represents the file system in which the PDF file is located. (See \sphinxhref{Plugins\_Unicode.html\#50618402\_67382}{Creating an ASFileSys object}.)

\item {} 
A \sphinxcode{\sphinxupquote{PDAuthProc}} authorization callback that is invoked only if the file has been secured (that is, if the file has either the user or the master password set). This callback must obtain required information to determine whether the user is authorized to open the file. You can pass \sphinxcode{\sphinxupquote{NULL}} if an authorization callback is not required. For information about callbacks, see \sphinxhref{Plugins\_Pimech.html\#50618406\_20671}{Using callback functions}.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} value. When set to \sphinxcode{\sphinxupquote{true}}, an attempt to repair a damaged file is performed. If \sphinxcode{\sphinxupquote{false}}, an attempt to repair a damaged file is not performed.

\end{itemize}

The following code example creates a \sphinxcode{\sphinxupquote{PDDoc}} object that is based on a PDF file named PurchaseOrder.pdf and located in the root of the C drive. This code example is located within a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{getDocument}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{PDDoc} \PYG{n}{getDocument}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{a} \PYG{n}{PDDoc} \PYG{n+nb}{object}
   \PYG{n}{PDDoc} \PYG{n}{myPDDoc}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{a} \PYG{n}{PDAuthProc} \PYG{n}{callback}
   \PYG{n}{PDAuthProc} \PYG{n}{myAuthProcPtr}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Specify} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{file} \PYG{n}{on} \PYG{n}{which} \PYG{n}{to} \PYG{n}{base} \PYG{n}{the} \PYG{n}{PDDoc} \PYG{n+nb}{object}
   \PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n}{myPath} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:PurchaseOrder.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
   \PYG{n}{ASAtom} \PYG{n}{pathType} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cstring}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASPathName} \PYG{n+nb}{object}
   \PYG{n}{ASFileSys} \PYG{n}{fileSys} \PYG{o}{=} \PYG{n}{ASGetDefaultFileSysForPath}\PYG{p}{(}\PYG{n}{pathType}\PYG{p}{,} \PYG{n}{myPath}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASPathName} \PYG{n}{pathName} \PYG{o}{=} \PYG{n}{ASFileSysCreatePathName}\PYG{p}{(}\PYG{n}{fileSys}\PYG{p}{,}\PYG{n}{pathType}\PYG{p}{,}
   \PYG{n}{myPath}\PYG{p}{,}\PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{the} \PYG{n}{authentication} \PYG{n}{callback}
   \PYG{n}{myAuthProcPtr} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto} \PYG{p}{(}\PYG{n}{PDAuthProc}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{authProc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDDoc} \PYG{n+nb}{object}
   \PYG{n}{myPDDoc} \PYG{o}{=} \PYG{n}{PDDocOpen} \PYG{p}{(}\PYG{n}{pathName}\PYG{p}{,} \PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{myAuthProcPtr}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Release} \PYG{n}{the} \PYG{n}{callback}
   \PYG{n}{ASCallbackDestroy} \PYG{p}{(}\PYG{n}{myAuthProcPtr}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{myPDDoc}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}


   \PYG{n}{ASBool} \PYG{n}{authProc}\PYG{p}{(}\PYG{n}{PDDoc} \PYG{n}{TheDoc}\PYG{p}{)}

   \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{business} \PYG{n}{logic} \PYG{n}{that} \PYG{n}{authenticates} \PYG{n}{the} \PYG{n}{user}
   \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Creating a PDDoc object for an open PDF}
\label{\detokenize{Plugins_Documents:creating-a-pddoc-object-for-an-open-pdf}}
You can create a \sphinxcode{\sphinxupquote{PDDoc}} object that is based on a PDF that is currently open by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an \sphinxcode{\sphinxupquote{AVDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVAppGetActiveDoc}} method. This method gets the frontmost document located in Adobe Reader or Acrobat.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVDocGetPDDoc}} method. This method requires an \sphinxcode{\sphinxupquote{AVDoc}} object and returns a \sphinxcode{\sphinxupquote{PDDoc}} object.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVDoc} \PYG{n}{avDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{myPDDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Accessing non\sphinxhyphen{}PDF files}
\label{\detokenize{Plugins_Documents:accessing-non-pdf-files}}
You can use the Acrobat core API to access non\sphinxhyphen{}PDF files. Your plugin can open a non\sphinxhyphen{}PDF file, write data to it, and then read the data at a later time by using \sphinxcode{\sphinxupquote{ASFile}} methods. For example, your plugin can use a text file to track log information or other type of information.

The following code example invokes the Acrobat core API methods to open a file, write data, and read data.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{AVAlertNote}} displays an error message if something goes wrong.

\item {} 
\sphinxcode{\sphinxupquote{ASFileSysOpenFile}} opens a file using the modes specified.

\item {} 
\sphinxcode{\sphinxupquote{ASFileWrite}} writes data to the file.

\item {} 
\sphinxcode{\sphinxupquote{ASFileClose}} closes the file.

\item {} 
\sphinxcode{\sphinxupquote{ASFileRead}} reads data from the file.

\item {} 
\sphinxcode{\sphinxupquote{ASFileGetEOF}} gets the current size of a file.

\end{itemize}

In the following code example, the \sphinxcode{\sphinxupquote{CreateDataFile}} user\sphinxhyphen{}defined function creates a file and writes data to it. The \sphinxcode{\sphinxupquote{ReadDataFile}} user\sphinxhyphen{}defined function opens a file and reads data from it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{k}{global} \PYG{n}{character} \PYG{n}{pointer}
   \PYG{n}{char}\PYG{o}{*} \PYG{n}{gDataBuf} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is some data in the file.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

   \PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{ExeProc} \PYG{p}{(}\PYG{n}{void}\PYG{o}{*} \PYG{n}{data}\PYG{p}{)}

   \PYG{p}{\PYGZob{}}
   \PYG{n}{CreateDataFile}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:DataFile.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ReadDataFile}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:DataFile.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Returns} \PYG{n}{false} \PYG{k}{if} \PYG{n}{error}\PYG{p}{,} \PYG{n}{true} \PYG{n}{otherwise}
   \PYG{n}{ASBool} \PYG{n}{CreateDataFile} \PYG{p}{(}\PYG{n}{char}\PYG{o}{*} \PYG{n}{pathname}\PYG{p}{)}

   \PYG{p}{\PYGZob{}}
   \PYG{n}{ASPathName} \PYG{n}{path} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{ASFile} \PYG{n}{TheFile} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{ASInt32} \PYG{n}{err} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{ASInt32} \PYG{n}{numBytes} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{ASInt32} \PYG{n}{mode} \PYG{o}{=} \PYG{n}{ASFILE\PYGZus{}WRITE} \PYG{o}{|} \PYG{n}{ASFILE\PYGZus{}CREATE}\PYG{p}{;}
   \PYG{n}{path} \PYG{o}{=} \PYG{n}{MakeCrossPlatformASPathName} \PYG{p}{(}\PYG{n}{pathname}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{path} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Unable to gain access to data file.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{err} \PYG{o}{=} \PYG{n}{ASFileSysOpenFile} \PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{n}{path}\PYG{p}{,} \PYG{n}{mode}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{TheFile}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{err} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{n}{Returns} \PYG{l+m+mi}{0} \PYG{k}{if} \PYG{n}{no} \PYG{n}{error}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Unable to open data file for writing.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{numBytes} \PYG{o}{=} \PYG{n}{ASFileWrite} \PYG{p}{(}\PYG{n}{TheFile}\PYG{p}{,} \PYG{n}{gDataBuf}\PYG{p}{,} \PYG{n}{strlen} \PYG{p}{(}\PYG{n}{gDataBuf}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{numBytes} \PYG{o}{!=} \PYG{n}{strlen} \PYG{p}{(}\PYG{n}{gDataBuf}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{ASFileClose} \PYG{p}{(}\PYG{n}{TheFile}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Number of bytes written was not the expected number.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{ASFileClose} \PYG{p}{(}\PYG{n}{TheFile}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Read} \PYG{n}{data} \PYG{k+kn}{from} \PYG{n+nn}{a} \PYG{n}{file}
   \PYG{n}{void} \PYG{n}{ReadDataFile} \PYG{p}{(}\PYG{n}{char}\PYG{o}{*} \PYG{n}{pathname}\PYG{p}{)}

   \PYG{p}{\PYGZob{}}
   \PYG{n}{ASPathName} \PYG{n}{path} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{ASFile} \PYG{n}{TheFile} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{ASInt32} \PYG{n}{err} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{ASInt32} \PYG{n}{mode} \PYG{o}{=} \PYG{n}{ASFILE\PYGZus{}READ}\PYG{p}{;}
   \PYG{n}{char} \PYG{n}{Data}\PYG{p}{[}\PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{char} \PYG{n}{buf}\PYG{p}{[}\PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{path} \PYG{o}{=} \PYG{n}{MakeCrossPlatformASPathName} \PYG{p}{(}\PYG{n}{pathname}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{path} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Unable to gain access to data file.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{err} \PYG{o}{=} \PYG{n}{ASFileSysOpenFile} \PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{n}{path}\PYG{p}{,} \PYG{n}{mode}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{TheFile}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{err} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{n}{Returns} \PYG{l+m+mi}{0} \PYG{k}{if} \PYG{n}{no} \PYG{n}{error}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Unable to open data file for reading.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{err} \PYG{o}{=} \PYG{n}{ASFileRead} \PYG{p}{(}\PYG{n}{TheFile}\PYG{p}{,} \PYG{n}{Data}\PYG{p}{,} \PYG{n}{ASFileGetEOF} \PYG{p}{(}\PYG{n}{TheFile}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{err} \PYG{o}{!=} \PYG{n}{strlen} \PYG{p}{(}\PYG{n}{gDataBuf}\PYG{p}{)}\PYG{p}{)}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Number of bytes read was not the expected amount of bytes.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{NULL} \PYG{n}{terminate} \PYG{n}{the} \PYG{n}{string}\PYG{o}{.}
   \PYG{n}{Data}\PYG{p}{[}\PYG{n}{ASFileGetEOF} \PYG{p}{(}\PYG{n}{TheFile}\PYG{p}{)} \PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{ASFileClose} \PYG{p}{(}\PYG{n}{TheFile}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{strcpy} \PYG{p}{(}\PYG{n}{buf}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Data read was: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{strcat} \PYG{p}{(}\PYG{n}{buf}\PYG{p}{,} \PYG{n}{Data}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{n}{Data}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{platform}\PYG{o}{\PYGZhy{}}\PYG{n}{independent} \PYG{n}{path}

   \PYG{n}{ASPathName} \PYG{n}{MakeCrossPlatformASPathName} \PYG{p}{(}\PYG{n}{char}\PYG{o}{*} \PYG{n}{platformPathname}\PYG{p}{)}

   \PYG{p}{\PYGZob{}}
   \PYG{n}{ASPathName} \PYG{n}{ThePathName} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{ThePathName} \PYG{o}{=} \PYG{n}{ASFileSysCreatePathName} \PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cstring}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{platformPathname}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{ThePathName}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Printing documents}
\label{\detokenize{Plugins_Documents:printing-documents}}
You can use the Acrobat core API to print documents by using one of the following methods:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{AVDocPrintPages}}

\item {} 
\sphinxcode{\sphinxupquote{AVDocPrintPagesWithParams}}

\end{itemize}

The \sphinxcode{\sphinxupquote{AVDocPrintPages}} method prints a document without displaying any user dialog boxes. The current printer, page settings, and job settings are used. Printing is complete when this method returns.

The \sphinxcode{\sphinxupquote{AVDocPrintPagesWithParams}} method prints a document with a full range of options. Printing is complete when this method returns. It performs embedded printing; that is, it allows a PDF page to print within a bounding rectangle on a page. It allows interactive printing to the specified printer.

To print a document with a range of options, invoke the \sphinxcode{\sphinxupquote{AVDocPrintPagesWithParams}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVDoc}} object that represents the PDF from which to print page. For information about creating an \sphinxcode{\sphinxupquote{AVDoc}} object, see \sphinxhref{Plugins\_Documents.html\#50618416\_65430}{Opening PDFs}.

\item {} 
An instance of the \sphinxcode{\sphinxupquote{AVDocPrintParams}} data structure that defines printing parameters. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

\end{itemize}


\section{Working with the PDF/X format}
\label{\detokenize{Plugins_Documents:working-with-the-pdf-x-format}}
Beginning PDF Library XI, you can convert an existing PDF file to the PDF/X format. The converter aims at creating an output PDF/X document that is self\sphinxhyphen{}contained and whose visual fidelity is maintained over time. The converter manages operations like font embedding, changes in colors while printing, etc., to give a seamless PDF/X conversion process. PDF/X\sphinxhyphen{}1a:2001 and PDF/X\sphinxhyphen{}3:2003 are the two PDF/X standards that are supported by the PDF processor plugin. For files containing objects that cannot be converted as per the PDF/X standards, the conversion process is aborted.

\begin{sphinxadmonition}{note}{Note:}
PDFL SDK XI does not support the conversion of PDF packages or of PDF portfolios to the PDF/X format.
\end{sphinxadmonition}

The following lists how various file elements are handled during conversion:
\begin{itemize}
\item {} 
Color Spaces: All color spaces in the input file are converted to PDF/X compliant color spaces. For PDF/X\sphinxhyphen{}3:2003, conversions to the US SWOP colorspace is supported.

\item {} 
AcroForms: AcroForms are flattened in the PDF/X compliant output file. This may result in loss of interactivity if the source file includes annotations. In the case of text fields, only the visible text is saved.

\item {} 
Digital Signatures: Digital signatures are flattened and replaced by equivalent graphics operators with the same visual appearance.

\item {} 
Annotations and Actions: The PDF/X standard does not allow the use of annotations or actions inside the print area. Any actions present in the input file will not be available in the output PDF/X file Annotations, if present, are moved outside the print area in the converted PDF/X file. You can choose to turn off the relocation of annotations which will result in the removal of annotations altogether.

\item {} 
Tagged PDF: PDF files that include tags are not supported. All tagging information is lost when a tagged PDF file is converted to the PDF/X format.

\item {} 
Fonts: The conversion is aborted if fonts in the input file are not embedded, the fonts are not present on the system, or the font embedding permissions are not available. Any invisible text in the input file will not be available in the output PDF/X file.

\item {} 
Transparency: Transparency is not supported in the PDF/X format. All transparency is flattened when a file is converted to the PDF/X format

\end{itemize}

The following APIs are available for conversion using the PDF Processor:
\begin{itemize}
\item {} 
PDFProcessorConvertAndSaveToPDFA

\item {} 
PDFProcessorConvertToPDFA

\item {} 
PDFProcessorTerminate

\item {} 
PDFProcessorConvertAndSaveToPDFX

\item {} 
PDFProcessorConvertToPDFX.

\end{itemize}

See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference} for more information.


\chapter{Creating Menus and Menu Commands}
\label{\detokenize{Plugins_Menu:creating-menus-and-menu-commands}}\label{\detokenize{Plugins_Menu::doc}}
The Acrobat core API supports creating new menu commands and modify existing menus. A menu command lets a user interact with your plugin by clicking a menu command that is displayed in an Adobe Reader or Acrobat menu. When the user clicks the menu command, application logic that is defined in the callback function associated with the menu command is executed. It is your responsibility to define the application logic that is located in the callback function.


\section{About menus}
\label{\detokenize{Plugins_Menu:about-menus}}
Adobe Reader and Acrobat have a standard menu bar and menu that let a user invoke specific functionality. You can, for example, click the Open command that is located on the File menu to open an existing PDF file. Using the Acrobat core API, you can programmatic\sphinxhyphen{}ally modify the menu bar. The following illustration shows the menu bar located in Acrobat.

\noindent\sphinxincludegraphics{{menu}.png}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Letter
&\sphinxstyletheadfamily 
Description
\\
\hline
A
&
The Acrobat menu bar.
\\
\hline
B
&
An Acrobat menu.
\\
\hline
C
&
A menu command.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{About AVmenubar typedefs}
\label{\detokenize{Plugins_Menu:about-avmenubar-typedefs}}
An \sphinxcode{\sphinxupquote{AVmenubar}} typedef represents the menu bar located within Adobe Reader or Acrobat and contains a list of all menus. A plugin can only have one \sphinxcode{\sphinxupquote{AVmenubar}} object. You can add new menus to the menu bar, remove menus from the menu bar, or hide the menu bar by using the Acrobat core API.


\subsection{About AVMenu typedefs}
\label{\detokenize{Plugins_Menu:about-avmenu-typedefs}}
An \sphinxcode{\sphinxupquote{AVMenu}} typedef represents a menu in the Adobe Reader or Acrobat menu bar. You can create new menus, add menu commands to a menu, and remove menu items. Deleting an \sphinxcode{\sphinxupquote{AVMenu}} removes it from the menu bar (if it was attached) and deletes all the menu items it contains.

Submenus (also called pull right menus) are \sphinxcode{\sphinxupquote{AVMenu}} objects that are attached to an \sphinxcode{\sphinxupquote{AVMenuItem}} object instead of to the menu bar.

Each menu has a title and a language\sphinxhyphen{}independent name. The title is the string that appears in the user interface, while the language\sphinxhyphen{}independent name is the same regardless of the language used in the user interface. Language\sphinxhyphen{}independent names enable a plugin to locate a specific menu, such as the File menu, without knowing, for example, that it is called Fichier in French.

You are strongly encouraged to begin your language\sphinxhyphen{}independent menu names with the plugin name (separated by a colon) to avoid name collisions when more than one plugin is present. For example, if a plugin is named myPlug, it may add a menu whose name is \sphinxcode{\sphinxupquote{myPlug:Options}}. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_30769}{Using plugin prefixes}.)


\subsection{About AVMenuItem typedefs}
\label{\detokenize{Plugins_Menu:about-avmenuitem-typedefs}}
An \sphinxcode{\sphinxupquote{AVMenuItem}} is a menu command within a menu. It contains the following attributes:
\begin{itemize}
\item {} 
A name

\item {} 
A keyboard shortcut

\item {} 
A callback function to execute when the menu item is selected

\item {} 
A callback function to compute whether the menu item is enabled

\item {} 
A callback function to compute whether the menu item is check marked, and whether it has a submenu

\end{itemize}

An \sphinxcode{\sphinxupquote{AVMenuItem}} object can also serve as a separators between menu commands. You are encouraged to position your plugin menu commands relative to a separator. This helps ensure that if a block of menu commands is moved in a future version of Acrobat, your plugin menu commands also are moved.

A plugin can simulate a user selecting a menu command by invoking the \sphinxcode{\sphinxupquote{AVMenuItemExecute}} method. If the menu command is disabled, the \sphinxcode{\sphinxupquote{AVMenuItemExecute}} method returns without performing a task. The \sphinxcode{\sphinxupquote{AVMenuItemExecute}} method works even when the menu item is not displayed (for example, if it has not been attached to a menu or if the menu bar is not visible). You can set the attributes of all menu commands that you create; however, do not modify the \sphinxcode{\sphinxupquote{Execute}} procedure of the Acrobat built\sphinxhyphen{}in menu commands.

Your plugin can specify menu command names using either the names seen by a user, or language\sphinxhyphen{}independent names. The latter allows your plugin to locate a specific menu command without knowing, for example, that it is called Imprimer in French.

You are strongly encouraged to avoid name collisions when naming menu commands by using your plugin name and a colon. For example, if a plugin is named \sphinxcode{\sphinxupquote{myPlug}}, you can name a menu command \sphinxcode{\sphinxupquote{myPlug:Open}} or \sphinxcode{\sphinxupquote{myPlug:Find}}. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_30769}{Using plugin prefixes}.)


\section{Adding menu commands to menus}
\label{\detokenize{Plugins_Menu:adding-menu-commands-to-menus}}
You can use the Acrobat core API to add a new menu command to an existing menu. For example, you can add a menu named Acrobat SDK to the Adobe Reader or Acrobat menu bar.

To add a new menu command to an existing menu, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Retrieve the Adobe Reader or Acrobat menu bar that is represented by an \sphinxcode{\sphinxupquote{AVmenubar}} object by invoking the \sphinxcode{\sphinxupquote{AVAppGetMenubar}} method.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVMenubar} \PYG{n}{Themenubar} \PYG{o}{=} \PYG{n}{AVAppGetMenubar}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Retrieve the menu that will contain the new menu command by invoking the \sphinxcode{\sphinxupquote{AVMenubarAcquireMenuByName}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVmenubar}} object that represents the menu bar.

\item {} 
The name of the menu. For example, to reference the File menu, specify \sphinxcode{\sphinxupquote{File}}.

\end{itemize}

\end{enumerate}

This method returns an \sphinxcode{\sphinxupquote{AVMenu}} object that corresponds to the specified menu name.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{AVMenu}
\PYG{n}{FileMenu} \PYG{o}{=} \PYG{n}{AVmenubarAcquireMenuByName} \PYG{p}{(}\PYG{n}{Themenubar}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{File}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If the menu does not exist, you can programmatically create it (see the next step).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
If necessary, programmatically create a new menu by invoking the \sphinxcode{\sphinxupquote{AVMenuNew}} method and passing the following arguments:
\begin{itemize}
\item {} 
A string value that represents the text displayed in Adobe Reader or Acrobat.

\item {} 
A unique, language\sphinxhyphen{}independent name for the menu. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_30769}{Using plugin prefixes}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASExtension}} value that registers the menu. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{AVMenuNew}} method returns an instance of \sphinxcode{\sphinxupquote{AVMenu}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVMenu} \PYG{n}{NewMenu} \PYG{o}{=} \PYG{n}{AVMenuNew} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Acrobat SDK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:Acrobat\PYGZus{}SDK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

After you create a new menu, you must attach it to the menu bar. (See \sphinxhref{Plugins\_Menu.html\#50618409\_95514}{Adding a menu command to a new menu}.)
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Create a new menu command by invoking the \sphinxcode{\sphinxupquote{AVMenuItemNew}} method and passing the following arguments:
\begin{itemize}
\item {} 
A string value that represents the menu command’s text. On Windows only, you can specify a keyboard shortcut by including an ampersand character (\&) in the title.{[}I wonder whether an example would help here.{]} In Acrobat or Adobe Reader, an underscore character (\_) is placed under the character following the ampersand ( \sphinxstyleemphasis{char} ).{[}I wonder whether an example would help here.{]} The user can then press alt+ \sphinxstyleemphasis{char} to select the item.

\item {} 
The language\sphinxhyphen{}independent name of the menu command to create. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_30769}{Using plugin prefixes}.)

\item {} 
An \sphinxcode{\sphinxupquote{AVMenu}} object that represents a submenu for which this menu command is the parent. Pass \sphinxcode{\sphinxupquote{null}} if this menu item does not have a submenu.

\item {} 
A Boolean value. If \sphinxcode{\sphinxupquote{true}}, the menu item is visible only when the user selects Full Menus. If \sphinxcode{\sphinxupquote{false}}, the menu item is visible for both Full Menus and Short Menus modes. This value is ignored in Adobe Reader or Acrobat 3.0 or later.

\item {} 
The key to use as a shortcut for the menu command (an ASCII character). Use \sphinxcode{\sphinxupquote{NO\_SHORTCUT}} if the menu command does not have a shortcut.

\item {} 
Modifier keys, if any, that are used as part of the shortcut. Must be an OR of the Modifier Keys values, except that \sphinxcode{\sphinxupquote{AV\_COMMAND}} cannot be specified.

\item {} 
An \sphinxcode{\sphinxupquote{AVIcon}} object that represents the icon to show in the menu command, or \sphinxcode{\sphinxupquote{null}} if no icon is shown. In Windows, a valid icon is a 24x24 sample monochrome \sphinxcode{\sphinxupquote{HBITMAP}}. In Mac OS, an icon is a handle to a standard SICN resource. For information about creating an \sphinxcode{\sphinxupquote{AVIcon}} object, see \sphinxhref{Plugins\_Toolbutton.html\#50618403\_92880}{Creating toolbar buttons}.

\item {} 
An \sphinxcode{\sphinxupquote{ASExtension}} value that registers this menu command. For information about an \sphinxcode{\sphinxupquote{ASExtension}} value, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{AVMenuItemNew}} method returns an \sphinxcode{\sphinxupquote{AVMenuItem}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
       \PYG{n}{AVMenuItem}
\PYG{n}{menuItem} \PYG{o}{=} \PYG{n}{AVMenuItemNew} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Show Message}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:ExternWin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
      \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{true}\PYG{p}{,} \PYG{n}{NO\PYGZus{}SHORTCUT}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Attach the menu command to a menu by invoking the \sphinxcode{\sphinxupquote{AVMenuAddMenuItem}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVMenu}} object to which a menu command is attached.

\item {} 
An \sphinxcode{\sphinxupquote{AVMenuItem}} object that is attached.

\item {} 
The location in the menu that specifies where the command is added. You can specify \sphinxcode{\sphinxupquote{APPEND\_MENUITEM}} to append the menu command to the end of the menu.

\end{itemize}

\end{enumerate}

If this method is successful, the menu command is added to the specified menu.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
       \PYG{n}{AVMenuAddMenuItem} \PYG{p}{(}
\PYG{n}{FileMenu}\PYG{p}{,} \PYG{n}{menuItem}\PYG{p}{,} \PYG{n}{APPEND\PYGZus{}MENUITEM}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\#6 Release the typedef instances to free memory. To release an \sphinxcode{\sphinxupquote{AVMenu}} instance, invoke the \sphinxcode{\sphinxupquote{AVMenuRelease}} method and pass the \sphinxcode{\sphinxupquote{AVMenu}} instance. To release an \sphinxcode{\sphinxupquote{AVMenuItem}} instance, invoke the \sphinxcode{\sphinxupquote{AVMenuItemRelease}} method and pass the \sphinxcode{\sphinxupquote{AVMenuItem}} instance.


\subsection{Adding a menu command to an existing menu}
\label{\detokenize{Plugins_Menu:adding-a-menu-command-to-an-existing-menu}}
The following code example creates a new menu command that displays the text \sphinxcode{\sphinxupquote{Show}} \sphinxcode{\sphinxupquote{Message}} and attaches it to the File menu.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Adding a menu command to an existing menu

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
//Declare menu variables
   AVMenubar Themenubar = NULL;
   AVMenu FileMenu = NULL;
   AVMenuItem NewMenuCommand = NULL;

//Retrieve the menu bar in Adobe Reader or Acrobat
   Themenubar = AVAppGetMenubar();

//Retrieve the File menu`
   FileMenu = AVMenubarAcquireMenuByName(Themenubar, \PYGZdq{}File\PYGZdq{});

//Create a new menu command
   NewMenuCommand = AVMenuItemNew(\PYGZdq{}Show Message\PYGZdq{}, \PYGZdq{}ADBE:ExternWin\PYGZdq{}, NULL,

   true, NO\PYGZus{}SHORTCUT, 0, NULL, gExtensionID);
   if (NewMenuCommand == NULL)
   \PYGZob{}
   AVAlertNote (\PYGZdq{}Unable to create the menu command\PYGZdq{});
   AVMenuItemRelease(NewMenuCommand);
   return;
   \PYGZcb{}
//Attach the new menu command to the File menu
   AVMenuAddMenuItem (FileMenu, NewMenuCommand, APPEND\PYGZus{}MENUITEM);

//Release the typedef instances
   AVMenuItemRelease(NewMenuCommand);
   AVMenuRelease(FileMenu);
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
This code example creates a new menu command that displays Show Message in the File menu. However, before the menu command performs an action, you have to create a callback menu function. (See \sphinxhref{Plugins\_Menu.html\#50618409\_73167}{Creating menu callback functions}.)
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
To see how the global \sphinxcode{\sphinxupquote{gEntensionID}} variable is declared, see the plugin samples that accompany the Acrobat SDK.
\end{sphinxadmonition}


\subsection{Adding a menu command to a new menu}
\label{\detokenize{Plugins_Menu:adding-a-menu-command-to-a-new-menu}}
The following code example creates a new menu command that displays the text \sphinxcode{\sphinxupquote{Show}} \sphinxcode{\sphinxupquote{Message}} and attaches it to a new menu. The new menu is attached to the menu bar by invoking the \sphinxcode{\sphinxupquote{AVmenubarAddMenu}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{menu} \PYG{n}{variables}
   \PYG{n}{AVMenubar} \PYG{n}{Themenubar} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{AVMenu} \PYG{n}{NewMenu} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{AVMenuItem} \PYG{n}{NewMenuCommand} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{menu} \PYG{n}{bar} \PYG{o+ow}{in} \PYG{n}{Adobe} \PYG{n}{Reader} \PYG{o+ow}{or} \PYG{n}{Acrobat}
   \PYG{n}{Themenubar} \PYG{o}{=} \PYG{n}{AVAppGetMenubar}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{menu}

   \PYG{n}{NewMenu} \PYG{o}{=} \PYG{n}{AVMenuNew}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New Menu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:NewMenu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{NewMenu} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Unable to create the menu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVMenuRelease} \PYG{p}{(}\PYG{n}{NewMenu}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{menu} \PYG{n}{command}
   \PYG{n}{NewMenuCommand} \PYG{o}{=} \PYG{n}{AVMenuItemNew}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Show Message}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:ExternWin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,}
   \PYG{n}{true}\PYG{p}{,} \PYG{n}{NO\PYGZus{}SHORTCUT}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{NewMenuCommand} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Unable to create the menu command}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVMenuItemRelease}\PYG{p}{(}\PYG{n}{NewMenuCommand}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Attach} \PYG{n}{the} \PYG{n}{menu} \PYG{n}{item} \PYG{n}{to} \PYG{n}{the} \PYG{n}{menu} \PYG{o+ow}{and} \PYG{n}{the} \PYG{n}{menu} \PYG{n}{to}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{the} \PYG{n}{menu} \PYG{n}{bar}
   \PYG{n}{AVMenuAddMenuItem} \PYG{p}{(}\PYG{n}{NewMenu}\PYG{p}{,} \PYG{n}{NewMenuCommand}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVMenubarAddMenu} \PYG{p}{(}\PYG{n}{Themenubar}\PYG{p}{,} \PYG{n}{NewMenu}\PYG{p}{,} \PYG{n}{APPEND\PYGZus{}MENU}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Release} \PYG{n}{the} \PYG{n}{typedef} \PYG{n}{instances}
   \PYG{n}{AVMenuItemRelease}\PYG{p}{(}\PYG{n}{NewMenuCommand}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVMenuRelease}\PYG{p}{(}\PYG{n}{NewMenu}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If you plan to add a submenu to a menu command, you must create the submenu before creating the menu command.
\end{sphinxadmonition}


\section{Creating menu callback functions}
\label{\detokenize{Plugins_Menu:creating-menu-callback-functions}}
When creating menus, you must create menu callback functions that are invoked by Adobe Reader or Acrobat. These types of callback functions can be created:
\begin{itemize}
\item {} 
\sphinxstylestrong{Execute}: Invoked by Adobe Reader or Acrobat in response to a user selecting a menu command. This callback is required.

\item {} 
\sphinxstylestrong{Compute\sphinxhyphen{}enabled}: This optional callback is invoked by Adobe Reader or Acrobat when determining whether to enable the menu command.

\item {} 
\sphinxstylestrong{Compute\sphinxhyphen{}marked}: This optional callback is invoked by Adobe Reader or Acrobat when determining whether the menu command should be checked.

\end{itemize}

For the purpose of this discussion, a simplistic user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{ShowMessage}} is introduced. This method displays a message box by invoking the \sphinxcode{\sphinxupquote{AVAlertNote}} method. The following code example shows the body of the \sphinxcode{\sphinxupquote{ShowMessage}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{ShowMessage} \PYG{p}{(}\PYG{n}{void}\PYG{o}{*} \PYG{n}{data}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
     \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A menu command was selected.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The data parameter for this and the other callbacks can be used to maintain private data for the menu command. Notice that this user\sphinxhyphen{}defined function is declared using the \sphinxcode{\sphinxupquote{ACCB1}} and \sphinxcode{\sphinxupquote{ACCB2}} macros. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_20671}{Using callback functions}.)

For each callback that you create, you declare pointers to callbacks that are defined in the Acrobat core API:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVExecuteProc} \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{AVComputeEnabledProc} \PYG{n}{CompEnabledProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{AVComputeMarkedProc} \PYG{n}{CompMarkedProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{AVExecuteProc}} is a callback that you can create that is invoked by Acrobat or Adobe Reader when a user selects a menu item. \sphinxcode{\sphinxupquote{AVComputeEnabledProc}} is a callback that you can create that is invoked by Adobe Reader or Acrobat when determining whether to enable the menu command. \sphinxcode{\sphinxupquote{AVComputeMarkedProc}} is a callback that you can create that is invoked by Adobe Reader or Acrobat when determining whether the menu command should be checked.

After you create a pointer, such as a pointer that points to \sphinxcode{\sphinxupquote{AVExecuteProc}}, you can invoke the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro that is defined in the Acrobat core API to convert a user\sphinxhyphen{}defined function to an Acrobat callback function. For example, you can invoke \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} to convert \sphinxcode{\sphinxupquote{ShowMessage}} to a callback function. The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro requires the following arguments:
\begin{itemize}
\item {} 
The callback type. For example, you can pass \sphinxcode{\sphinxupquote{AVExecuteProc}}.

\item {} 
The address of the user\sphinxhyphen{}defined function to convert to a callback function.

\end{itemize}

The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro returns a callback of the specified type that invokes the user\sphinxhyphen{}defined function whose address was passed as the second argument. The following code example shows the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro converting the \sphinxcode{\sphinxupquote{ShowMessage}} user\sphinxhyphen{}defined function to a \sphinxcode{\sphinxupquote{AVExecuteProc}} callback.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVExecuteProc} \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{AVExecuteProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ShowMessage}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

After you create an \sphinxcode{\sphinxupquote{AVExecuteProc}} callback, invoke the \sphinxcode{\sphinxupquote{AVMenuItemSetExecuteProc}} method to associate a menu command with a callback. That is, when a user selects a specific menu command, Acrobat or Adobe Reader will invoke the user\sphinxhyphen{}defined function whose address was passed to the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro. The \sphinxcode{\sphinxupquote{AVMenuItemSetExecuteProc}} method requires the following parameters:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVMenuItem}} instance that represents the menu command.

\item {} 
An \sphinxcode{\sphinxupquote{AVExecuteProc}} that represents the callback function.

\item {} 
The address of a user\sphinxhyphen{}defined data structure that can be passed to the user\sphinxhyphen{}defined function.

\end{itemize}

When you are done with a menu callback, you can invoke the \sphinxcode{\sphinxupquote{ASCallbackDestroy}} method to release memory that it consumes. The following code example creates callback functions for menu commands.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{o}{/}\PYG{o}{*} \PYG{n}{Display} \PYG{n}{a} \PYG{n}{message} \PYG{n}{box} \PYG{o}{*}\PYG{o}{/}
   \PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{ShowMessage} \PYG{p}{(}\PYG{n}{void}\PYG{o}{*} \PYG{n}{data}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A menu command was selected.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{ComputeMarkedProc} \PYG{p}{(}\PYG{n}{void}\PYG{o}{*} \PYG{n}{data}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{ASBool} \PYG{n}{expressionorcondition} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{expressionorcondition}\PYG{p}{)}
         \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
   \PYG{k}{else} \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{ComputeEnabledProc} \PYG{p}{(}\PYG{n}{void}\PYG{o}{*} \PYG{n}{data}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{AVAppGetNumDocs}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
         \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
   \PYG{k}{else} \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginInit} \PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{menu} \PYG{n}{callbacks}
   \PYG{n}{AVExecuteProc} \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{AVComputeEnabledProc} \PYG{n}{CompEnabledProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{AVComputeMarkedProc} \PYG{n}{CompMarkedProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{menu} \PYG{n}{variables}
   \PYG{n}{AVMenu} \PYG{n}{FileMenu} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{AVMenuItem} \PYG{n}{NewItem} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{menu} \PYG{n}{bar} \PYG{o+ow}{in} \PYG{n}{Adobe} \PYG{n}{Reader} \PYG{o+ow}{or} \PYG{n}{Acrobat}
   \PYG{n}{AVMenubar} \PYG{n}{Themenubar} \PYG{o}{=} \PYG{n}{AVAppGetMenubar} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{menu} \PYG{n}{callbacks}
   \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto} \PYG{p}{(}\PYG{n}{AVExecuteProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ShowMessage}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{CompEnabledProcPtr} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto} \PYG{p}{(}\PYG{n}{AVComputeEnabledProc}\PYG{p}{,}
   \PYG{o}{\PYGZam{}}\PYG{n}{ComputeEnabledProc}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{CompMarkedProcPtr} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto} \PYG{p}{(}\PYG{n}{AVComputeMarkedProc}\PYG{p}{,}
   \PYG{o}{\PYGZam{}}\PYG{n}{ComputeMarkedProc}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{File} \PYG{n}{menu}
   \PYG{n}{FileMenu} \PYG{o}{=} \PYG{n}{AVmenubarAcquireMenuByName} \PYG{p}{(}\PYG{n}{Themenubar}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{File}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{FileMenu}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{menu} \PYG{n}{item}
   \PYG{n}{NewItem} \PYG{o}{=} \PYG{n}{AVMenuItemNew} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Show Message}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADBE:ExternWin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{true}\PYG{p}{,}
   \PYG{n}{NO\PYGZus{}SHORTCUT}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{NewItem} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
         \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Unable to create a menu item, not loading.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{AVMenuItemSetExecuteProc} \PYG{p}{(}\PYG{n}{NewItem}\PYG{p}{,} \PYG{n}{ExecProcPtr}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVMenuItemSetComputeEnabledProc} \PYG{p}{(}\PYG{n}{NewItem}\PYG{p}{,}
   \PYG{n}{CompEnabledProcPtr}\PYG{p}{,}\PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVMenuItemSetComputeMarkedProc} \PYG{p}{(}\PYG{n}{NewItem}\PYG{p}{,}
   \PYG{n}{CompMarkedProcPtr}\PYG{p}{,}\PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVMenuAddMenuItem} \PYG{p}{(}\PYG{n}{FileMenu}\PYG{p}{,} \PYG{n}{NewItem}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVMenuRelease} \PYG{p}{(}\PYG{n}{FileMenu}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{else} \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginUnload} \PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{ASCallbackDestroy} \PYG{p}{(}\PYG{n}{ExecProcPtr}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASCallbackDestroy} \PYG{p}{(}\PYG{n}{CompEnabledProcPtr}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASCallbackDestroy} \PYG{p}{(}\PYG{n}{CompMarkedProcPtr}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Notice that the application logic that creates a menu command is located in the \sphinxcode{\sphinxupquote{PluginInit}} procedure. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_58810}{About plugin initialization}.)
\end{sphinxadmonition}


\section{Determining if a menu item can be executed}
\label{\detokenize{Plugins_Menu:determining-if-a-menu-item-can-be-executed}}
In previous versions of Adobe Reader and Acrobat, it was possible for a document to execute a menu item in the viewing application using a Named action or the \sphinxcode{\sphinxupquote{app.execMenuItem}} JavaScript method. These two features, referred to as \sphinxcode{\sphinxupquote{ExecMenu}} expose all menu items to the document, potentially allowing a malicious document to compromise a user’s privacy or system. For example, it was possible to use the \sphinxcode{\sphinxupquote{app.execMenuItem}} JavaScript method to obtain data from a document by creating the equivalent to a user selecting the menu sequence of Select All, Copy, and Paste.

Acrobat and Adobe Reader 8.0 and later contain a list of menu items that can be executed using \sphinxcode{\sphinxupquote{ExecMenu}}. Any menu item not on the list cannot be programmatically executed.

You can determine if a menu item can be programmatically executed by invoking the \sphinxcode{\sphinxupquote{AVMenuItemIsScriptable}} method and passing an \sphinxcode{\sphinxupquote{AVMenuItem}}. This method returns a Boolean value. That is, if the menu item that corresponds to the \sphinxcode{\sphinxupquote{AVMenuItem}} argument can be executed, \sphinxcode{\sphinxupquote{True}} is returned; otherwise, \sphinxcode{\sphinxupquote{False}} is returned.


\chapter{Creating Toolbars and Buttons}
\label{\detokenize{Plugins_Toolbutton:creating-toolbars-and-buttons}}\label{\detokenize{Plugins_Toolbutton::doc}}
You can use the Acrobat core API to create new toolbars and toolbar buttons and to modify existing ones. For example, you can create a new button, attach it to an existing toolbar, and associate the button with a specified callback function that is executed when the user clicks the button.


\section{About toolbars}
\label{\detokenize{Plugins_Toolbutton:about-toolbars}}
Adobe Reader and Acrobat consists of various toolbars that enable a user to invoke specific functionality. For example, you can click the \sphinxcode{\sphinxupquote{Open}} button that is located on the \sphinxcode{\sphinxupquote{File}} toolbar to open an existing PDF document. The following illustration shows two toolbars located in Acrobat.

\noindent\sphinxincludegraphics{{toolbar}.png}

\begin{sphinxadmonition}{tip}{Tip:}
You can obtain the display name of the toolbar by pointing the mouse to the left portion of a toolbar.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
The display name is the name that is displayed in Acrobat or Adobe Reader. However, toolbars also have internal names that may differ. That is, in some cases, the internal name and display name of a toolbar are different and in other cases they are the same. For example, consider the Help toolbar. The display name is Help and the internal name is HowTo. An internal name is used to programmatically retrieve a toolbar. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_92112}{Retrieving toolbars}. )
\end{sphinxadmonition}


\subsection{About AVToolBar typedefs}
\label{\detokenize{Plugins_Toolbutton:about-avtoolbar-typedefs}}
An \sphinxcode{\sphinxupquote{AVToolBar}} represents a toolbar that is located in Adobe Reader or Acrobat. A plugin can add buttons to and remove buttons from a toolbar, show or hide toolbars, and create new toolbars. Because screen space is limited on many monitors, it is recommended that you only create buttons that are necessary.

You can add a button to a toolbar by specifying the relative position of the button (before or after) to an existing button. A plugin controls the toolbar upon which a button will appear by placing the button next to an existing one already in the appropriate location.


\subsection{About AVToolButton typedefs}
\label{\detokenize{Plugins_Toolbutton:about-avtoolbutton-typedefs}}
An \sphinxcode{\sphinxupquote{AVToolButton}} represents a button that is located within a toolbar. Like menu items, a callback function that is executed when the button is clicked must be defined. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_31936}{Creating toolbar button callback functions}.)

A plugin can invoke a button as if a user clicked it. Buttons can be enabled (selectable) or disabled (grayed out), and can be marked (selected). Each button also has an icon that appears in the toolbar. Normally, all tools are persistent and remain selected indefinitely. The Control key (Windows) or Option key (Mac OS) can be used to select a tool for one\sphinxhyphen{}shot use. Plugins should follow this convention to add buttons.

Separators between groups of buttons are themselves buttons, although they are neither selectable nor executable. Because they are buttons, however, they do have names, allowing other buttons to be positioned relative to them.

You are encouraged to position tool buttons relative to separators. Doing this increases the likelihood that tool buttons will be correctly placed if future versions of Acrobat move groups of tool buttons around.


\section{Retrieving toolbars}
\label{\detokenize{Plugins_Toolbutton:retrieving-toolbars}}
You can use the Acrobat core API to retrieve an existing toolbar that appears in Adobe Reader or Acrobat. After you retrieve a toolbar, you can perform additional tasks such as attaching a button. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_75762}{Attaching a button to a toolbar}.)

You retrieve a specific toolbar by invoking the \sphinxcode{\sphinxupquote{AVAppGetToolBarByName}} method. This method requires a constant character pointer that specifies the internal name of a toolbar and returns an \sphinxcode{\sphinxupquote{AVToolBar}} object that corresponds to the toolbar. If the name cannot be found, this method returns \sphinxcode{\sphinxupquote{NULL}}.

The following table lists toolbar names that appear in Acrobat and Adobe Reader (Adobe Reader does not contain all the toolbars that Acrobat does). The Display Name column specifies the toolbar name that appears in Acrobat or Adobe Reader. The Internal Name column specifies the value that you must pass to the \sphinxcode{\sphinxupquote{AVAppGetToolBarByName}} method to retrieve the toolbar.


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{Plugins_Toolbutton:section-1}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Display Name
&\sphinxstyletheadfamily 
Internal Name
&\sphinxstyletheadfamily 
Description
\\
\hline
Advanced Editing
&
Editing
&
Contains buttons that enable you to perform advanced editing operations such as using the Crop tool.
\\
\hline
Basic
&
BasicTools
&
Contains buttons that enable you to perform basic operations such as using the Hand tool.
\\
\hline
Commenting
&
Commenting
&
Contains buttons that enable you to perform commenting operations such as using the Notes tool.
\\
\hline
Drawing Markups
&
AdvCommenting
&
Contains buttons that enable you to perform drawing operations such using the Arrow tool.
\\
\hline
Edit
&
UndoRedo
&
Contains buttons that enable you to perform editing operations such as checking the spelling.
\\
\hline
File
&
File
&
Contains buttons that enable you to perform file operations such as opening a PDF file.
\\
\hline
Help
&
HowTo
&
Contains a button that enables you to access online help topics.
\\
\hline
Measuring
&
Measuring
&
Contains buttons that enable you to perform measuring operations such as using the Distance tool.
\\
\hline
Navigation
&
Navigation
&
Contains buttons that enable you to perform navigation operations such as skipping to the next page.
\\
\hline
Print Production
&
PrintProduction
&
Contains buttons that enable you to perform print operations such as viewing an output preview.
\\
\hline
Rotate View
&
Rotate
&
Contains a button that enables you to rotate a PDF document.
\\
\hline
Tasks
&
Tasks
&
Contains buttons that enable you to perform operations such as digitally signing a document.
\\
\hline
Typewriter
&
Typewriter
&
Enables you to type text on a PDF document.
\\
\hline
Zoom
&
Viewing
&
Contains buttons that enable you to perform viewing operations such as zooming in on a document.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The following code example retrieves the Tasks toolbar by name:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{Tasks} \PYG{n}{toolbar}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n}{toolbarName}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tasks}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{;}
\PYG{n}{AVToolBar} \PYG{n}{myToolBar} \PYG{o}{=} \PYG{n}{AVAppGetToolBarByName}\PYG{p}{(}\PYG{n}{toolbarName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
You can invoke the \sphinxcode{\sphinxupquote{AVAppGetToolBar}} method to return an \sphinxcode{\sphinxupquote{AVToolbar}} object that is based on the Advanced Editing toolbar.
\end{sphinxadmonition}


\section{Creating toolbar buttons}
\label{\detokenize{Plugins_Toolbutton:creating-toolbar-buttons}}
You can create a new button that you can attach to a new or existing toolbar. To create a new button, invoke the \sphinxcode{\sphinxupquote{AVToolButtonNew}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that specifies the button’s name.

\item {} 
An \sphinxcode{\sphinxupquote{AVIcon}} object that represents the button’s icon. If a button does not have an icon, the button appears with a gray background.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} value that you can set to \sphinxcode{\sphinxupquote{true}} or \sphinxcode{\sphinxupquote{false}}. If \sphinxcode{\sphinxupquote{true}}, the button is shown only when the user selects ‘Full menus’. If \sphinxcode{\sphinxupquote{false}}, shows in both ‘Full menu’ and ‘Short menu’ modes. This argument is ignored in Acrobat 3.0 or later.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} value that you can set to \sphinxcode{\sphinxupquote{true}} or \sphinxcode{\sphinxupquote{false}}. If \sphinxcode{\sphinxupquote{true}}, the new button is a separator used to leave space between groups of related buttons. Callback functions are ignored and a user cannot click on a separator. If \sphinxcode{\sphinxupquote{false}}, the button is normal.

\end{itemize}

The \sphinxcode{\sphinxupquote{AVToolButtonNew}} method returns an \sphinxcode{\sphinxupquote{AVToolButton}} object. You must attach this button to a toolbar in order to view it. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_75762}{Attaching a button to a toolbar}.)

It is strongly recommended that you create an \sphinxcode{\sphinxupquote{AVIcon}} object when creating a new button. To create an \sphinxcode{\sphinxupquote{AVIcon}} object, you must invoke platform specific APIs. That is, you do not invoke methods that belong to the Acrobat core API. If, for example, you are working on Windows, you can invoke a Win32 API method named \sphinxcode{\sphinxupquote{LoadBitmap}}. Likewise, if you are working on Mac OS, you can invoke \sphinxcode{\sphinxupquote{SafeGetResource}}.

The following code example shows how to create an \sphinxcode{\sphinxupquote{AVIcon}} object that is based on a bitmap resource named \sphinxcode{\sphinxupquote{IDB\_BITMAP1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVIcon} \PYG{n}{myIcon} \PYG{o}{=} \PYG{p}{(}\PYG{n}{AVCursor}\PYG{p}{)}\PYG{n}{LoadBitmap}\PYG{p}{(}\PYG{n}{gHINSTANCE}\PYG{p}{,} \PYG{n}{MAKEINTRESOURCE}\PYG{p}{(}\PYG{n}{IDB\PYGZus{}BITMAP1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{gHINSTANCE}} object is an instance of \sphinxcode{\sphinxupquote{HINSTANCE}} and is declared in the PIMain.c file. In addition to creating a new icon, you can also retrieve an existing icon appearing on a toolbar button. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_19658}{Retrieving existing toolbar buttons}.)

Once you create an \sphinxcode{\sphinxupquote{AVIcon}} object, you can create a new toolbar button. The following code example creates a new toolbar button.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{an} \PYG{n}{AVToolButton} \PYG{n+nb}{object}
   \PYG{n}{AVToolButton} \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{AVIcon} \PYG{n+nb}{object}
   \PYG{n}{AVIcon} \PYG{n}{myIcon} \PYG{o}{=} \PYG{p}{(}\PYG{n}{AVCursor}\PYG{p}{)}\PYG{n}{LoadBitmap}\PYG{p}{(}\PYG{n}{gHINSTANCE}\PYG{p}{,} \PYG{n}{MAKEINTRESOURCE}\PYG{p}{(}\PYG{n}{IDB\PYGZus{}BITMAP1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{button}
   \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{AVToolButtonNew}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyExtn:MyButton}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myIcon}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Setting help text for a button}
\label{\detokenize{Plugins_Toolbutton:setting-help-text-for-a-button}}
A button’s help text appears when the mouse scrolls over and pauses on a toolbar button. A small pop\sphinxhyphen{}up window appears with a text message. To set a button’s help text, invoke the \sphinxcode{\sphinxupquote{AVToolButtonSetHelpText}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVToolButton}} object that represents a button for which the help text is set.

\item {} 
A constant character pointer that specifies the button’s help text value.

\end{itemize}

The following code example sets a button’s help text.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{an} \PYG{n}{AVToolButton} \PYG{n+nb}{object}
   \PYG{n}{AVToolButton} \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{AVIcon} \PYG{n+nb}{object}
   \PYG{n}{AVIcon} \PYG{n}{myIcon} \PYG{o}{=} \PYG{p}{(}\PYG{n}{AVCursor}\PYG{p}{)}\PYG{n}{LoadBitmap}\PYG{p}{(}\PYG{n}{gHINSTANCE}\PYG{p}{,} \PYG{n}{MAKEINTRESOURCE}\PYG{p}{(}\PYG{n}{IDB\PYGZus{}BITMAP1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{button}
   \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{AVToolButtonNew}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyExtn:MyButton}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myIcon}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{a} \PYG{n}{button}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s help text}
   \PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n}{helpText} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Open PDF in external window}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{;}
   \PYG{n}{AVToolButtonSetHelpText} \PYG{p}{(}\PYG{n}{MyButton}\PYG{p}{,} \PYG{n}{helpText}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Setting label text}
\label{\detokenize{Plugins_Toolbutton:setting-label-text}}
A button’s label text is the text that is displayed beside the button. To set a button’s label, invoke the \sphinxcode{\sphinxupquote{AVToolButtonSetLabelText}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVToolButton}} object that represents a button for which the label text is set.

\item {} 
An \sphinxcode{\sphinxupquote{ASConstText}} object that specifies the button’s label text (the following code example demonstrates how to create this object).

\item {} 
An \sphinxcode{\sphinxupquote{AVToolButtonLabelPriority}} value that specifies a set of priority values for a button’s label text. This priority value determines the preference order in which labels are shown when a toolbar is too short to hold all of the button labels. The following values are valid:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOffExtraLow}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOffLow}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOffNormal}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOffHigh}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOffExtraHigh}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOnExtraLow}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOnLow}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOnNormal}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOnHigh}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityOnExtraHigh}}

\item {} 
\sphinxcode{\sphinxupquote{kAVButtonPriorityAlwaysOn}}

\end{itemize}

\end{itemize}

The following code example sets a button’s label text.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{an} \PYG{n}{AVToolButton} \PYG{n+nb}{object}
\PYG{n}{AVToolButton} \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{AVIcon} \PYG{n+nb}{object}
   \PYG{n}{AVIcon} \PYG{n}{myIcon} \PYG{o}{=} \PYG{p}{(}\PYG{n}{AVCursor}\PYG{p}{)}\PYG{n}{LoadBitmap}\PYG{p}{(}\PYG{n}{gHINSTANCE}\PYG{p}{,} \PYG{n}{MAKEINTRESOURCE}\PYG{p}{(}\PYG{n}{IDB\PYGZus{}BITMAP1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{button}
   \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{AVToolButtonNew} \PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyExtn:MyButton}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myIcon}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASConstText} \PYG{n+nb}{object} \PYG{n}{by} \PYG{n}{using} \PYG{n}{a} \PYG{n}{ASText} \PYG{n+nb}{object}
   \PYG{n}{ASText} \PYG{n}{tmpText} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASTextSetPDText}\PYG{p}{(}\PYG{n}{tmpText}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{View PDF}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASConstText} \PYG{n}{labelText} \PYG{o}{=} \PYG{n}{tmpText}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n}{button}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s label text with a kAVButtonPriorityOnNormal priority}
   \PYG{n}{AVToolButtonSetLabelText} \PYG{p}{(}\PYG{n}{MyButton}\PYG{p}{,} \PYG{n}{labelText}\PYG{p}{,} \PYG{n}{kAVButtonPriorityOnNormal}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Creating a sub\sphinxhyphen{}menu for a button}
\label{\detokenize{Plugins_Toolbutton:creating-a-sub-menu-for-a-button}}
You can create a sub\sphinxhyphen{}menu that appears when a user clicks the button. A sub\sphinxhyphen{}menu contains menu comments that a user can select to invoke a specific action. To create a sub\sphinxhyphen{}menu for a button, invoke the \sphinxcode{\sphinxupquote{AVToolButtonSetMenu}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVToolButton}} object that specifies a button to which the menu is attached.

\item {} 
An \sphinxcode{\sphinxupquote{AVMenu}} object that represents the menu. (See \sphinxhref{Plugins\_Menu.html\#50618409\_98126}{Creating Menus and Menu Commands}.)

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
To view an example of a sub\sphinxhyphen{}menu, click the Help button that appears on the Help toolbar.
\end{sphinxadmonition}


\section{Retrieving existing toolbar buttons}
\label{\detokenize{Plugins_Toolbutton:retrieving-existing-toolbar-buttons}}
Instead of creating a new button, you can retrieve an existing button. You can, for example, retrieve a button from one toolbar and attach it to another toolbar. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_75762}{Attaching a button to a toolbar}.)

To retrieve an existing toolbar button, invoke the \sphinxcode{\sphinxupquote{AVToolBarGetButtonByName}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVToolBar}} object that represents the toolbar from which the button is retrieved.

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that represents the button name. For information about button names, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\end{itemize}

The \sphinxcode{\sphinxupquote{AVToolBarGetButtonByName}} method returns an \sphinxcode{\sphinxupquote{AVToolButton}} object that corresponds to the specified button. If the name is not found, then this method returns \sphinxcode{\sphinxupquote{NULL}}. Once you obtain a button, you can perform various tasks such as attaching it to another toolbar or retrieving its icon by invoking the \sphinxcode{\sphinxupquote{AVToolButtonGetIcon}} method and passing the \sphinxcode{\sphinxupquote{AVToolButton}} object that contains the icon.

The following code example retrieves the SecureTask button located on the Tasks toolbar and gets its icon.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{Tasks} \PYG{n}{toolbar}
   \PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n}{toolbarName}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tasks}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{;}
   \PYG{n}{AVToolBar} \PYG{n}{myToolBar} \PYG{o}{=} \PYG{n}{AVAppGetToolBarByName}\PYG{p}{(}\PYG{n}{toolbarName}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{SecureTask} \PYG{n}{button} \PYG{n}{located} \PYG{n}{on} \PYG{n}{the} \PYG{n}{Tasks} \PYG{n}{toolbar}
   \PYG{n}{AVToolButton} \PYG{n}{mySecureButton} \PYG{o}{=} \PYG{n}{AVToolBarGetButtonByName}\PYG{p}{(}\PYG{n}{myToolBar}\PYG{p}{,}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SecureTask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{mySecureButton} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The button was not successfully retrieved}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{icon} \PYG{n}{located} \PYG{n}{on} \PYG{n}{the} \PYG{n}{button}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Pass} \PYG{n}{the} \PYG{n}{AVToolButton} \PYG{n+nb}{object}
   \PYG{n}{AVIcon} \PYG{n}{mySecureIcon} \PYG{o}{=} \PYG{n}{AVToolButtonGetIcon}\PYG{p}{(}\PYG{n}{mySecureButton}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Attaching a button to a toolbar}
\label{\detokenize{Plugins_Toolbutton:attaching-a-button-to-a-toolbar}}
After you create a new button, you must attach it to a toolbar. A button must be attached to a toolbar before it is visible within Adobe Reader or Acrobat. To attach a button to a toolbar, invoke the \sphinxcode{\sphinxupquote{AVToolBarAddButton}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVToolBar}} object that represents the toolbar to which the button is attached.

\item {} 
An \sphinxcode{\sphinxupquote{AVToolButton}} object that represents the button that is attached.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies the location of where the button is attached. If \sphinxcode{\sphinxupquote{true}}, the button is attached before the button specified by the \sphinxcode{\sphinxupquote{otherButton}} argument. If \sphinxcode{\sphinxupquote{false}}, the button is attached after the button specified by the \sphinxcode{\sphinxupquote{otherButton}} argument. If \sphinxcode{\sphinxupquote{otherButton}} is NULL and this value is \sphinxcode{\sphinxupquote{true}}, the button is attached at the beginning of the toolbar. If \sphinxcode{\sphinxupquote{otherButton}} is NULL and this value is \sphinxcode{\sphinxupquote{false}}, the button is attached at the end of the toolbar.

\item {} 
An \sphinxcode{\sphinxupquote{AVToolButton}} object (the name of this argument is \sphinxcode{\sphinxupquote{otherButton}} ) that is used in conjunction with the \sphinxcode{\sphinxupquote{ASBool}} object that specifies the location of where the \sphinxcode{\sphinxupquote{AVToolButton}} object is attached.

\end{itemize}

Before a button has functionality, you must create a callback function. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_31936}{Creating toolbar button callback functions}.)

Acrobat 9 adds the \sphinxcode{\sphinxupquote{AVToolBarAddButtonEx}} method for creating a new button. This method takes a structure that lets you specify where you want the button to appear and whether the button should be hidden by default.

The following code example attaches a newly created button to the File toolbar.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{an} \PYG{n}{AVToolButton} \PYG{n+nb}{object}
   \PYG{n}{AVToolButton} \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{AVIcon} \PYG{n+nb}{object}
   \PYG{n}{AVIcon} \PYG{n}{myIcon} \PYG{o}{=} \PYG{p}{(}\PYG{n}{AVCursor}\PYG{p}{)}\PYG{n}{LoadBitmap}\PYG{p}{(}\PYG{n}{gHINSTANCE}\PYG{p}{,} \PYG{n}{MAKEINTRESOURCE}\PYG{p}{(}\PYG{n}{IDB\PYGZus{}BITMAP1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{button}
   \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{AVToolButtonNew} \PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyExtn:MyButton}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myIcon}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{File} \PYG{n}{toolbar}
   \PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n}{toolbarName}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{File}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
   \PYG{n}{AVToolBar} \PYG{n}{ToolBar} \PYG{o}{=} \PYG{n}{AVAppGetToolBarByName}\PYG{p}{(}\PYG{n}{toolbarName}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Attach} \PYG{n}{the} \PYG{n}{button}
   \PYG{n}{AVToolBarAddButton}\PYG{p}{(}\PYG{n}{ToolBar}\PYG{p}{,} \PYG{n}{MyButton}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For information about creating a button, see \sphinxhref{Plugins\_Toolbutton.html\#50618403\_92880}{Creating toolbar buttons}.
\end{sphinxadmonition}


\section{Exposing a button in a web browser}
\label{\detokenize{Plugins_Toolbutton:exposing-a-button-in-a-web-browser}}
You can expose an Acrobat or Adobe Reader toolbar button within a web browser by invoking the \sphinxcode{\sphinxupquote{AVToolButtonSetExternal}} method. Pass the following arguments to the \sphinxcode{\sphinxupquote{AVToolButtonSetExternal}} method:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVToolButton}} object that represents the button to expose within a web browser.

\item {} 
Both the \sphinxcode{\sphinxupquote{TOOLBUTTON\_EXTERNAL}} and \sphinxcode{\sphinxupquote{TOOLBUTTON\_INTERNAL}} values to ensure that the button is visible within Acrobat or Adobe Reader and a web browser.

\end{itemize}

The following code example exposes a button in a web browser.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{an} \PYG{n}{AVToolButton} \PYG{n+nb}{object}
   \PYG{n}{AVToolButton} \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{AVIcon} \PYG{n+nb}{object}
   \PYG{n}{AVIcon} \PYG{n}{myIcon} \PYG{o}{=} \PYG{p}{(}\PYG{n}{AVCursor}\PYG{p}{)}\PYG{n}{LoadBitmap}\PYG{p}{(}\PYG{n}{gHINSTANCE}\PYG{p}{,} \PYG{n}{MAKEINTRESOURCE}\PYG{p}{(}\PYG{n}{IDB\PYGZus{}BITMAP1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{button}
   \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{AVToolButtonNew} \PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyExtn:MyButton}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myIcon}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{File} \PYG{n}{toolbar}
   \PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n}{toolbarName}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{File}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
   \PYG{n}{AVToolBar} \PYG{n}{ToolBar} \PYG{o}{=} \PYG{n}{AVAppGetToolBarByName}\PYG{p}{(}\PYG{n}{toolbarName}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Expose} \PYG{n}{the} \PYG{n}{button} \PYG{o+ow}{in} \PYG{n}{a} \PYG{n}{web} \PYG{n}{browser}
   \PYG{n}{AVToolButtonSetExternal}\PYG{p}{(}\PYG{n}{MyButton}\PYG{p}{,} \PYG{n}{TOOLBUTTON\PYGZus{}EXTERNAL} \PYG{o}{|} \PYG{n}{TOOLBUTTON\PYGZus{}INTERNAL}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Attach} \PYG{n}{the} \PYG{n}{button}
   \PYG{n}{AVToolBarAddButton}\PYG{p}{(}\PYG{n}{ToolBar}\PYG{p}{,} \PYG{n}{MyButton}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Removing a button from a toolbar}
\label{\detokenize{Plugins_Toolbutton:removing-a-button-from-a-toolbar}}
You can use the Acrobat core API to remove a button from a toolbar. To remove a button from a toolbar, invoke the \sphinxcode{\sphinxupquote{AVToolButtonRemove}} method and pass a \sphinxcode{\sphinxupquote{AVToolButton}} object that represents the button to remove. Although the button is removed from the toolbar, it is not destroyed. At any time, you can attach the button to the same or different toolbar. (See \sphinxhref{Plugins\_Toolbutton.html\#50618403\_75762}{Attaching a button to a toolbar}.)

After you remove the button, invoke the \sphinxcode{\sphinxupquote{AVToolBarUpdateButtonStates}} method to update the toolbar. This method requires an \sphinxcode{\sphinxupquote{AVToolBar}} object that represents the toolbar to update. The following code example removes the SecureTask button located on the Tasks toolbar.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{Tasks} \PYG{n}{toolbar}
   \PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n}{toolbarName}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tasks}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{;}
   \PYG{n}{AVToolBar} \PYG{n}{myToolBar} \PYG{o}{=} \PYG{n}{AVAppGetToolBarByName}\PYG{p}{(}\PYG{n}{toolbarName}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{SecureTask} \PYG{n}{button} \PYG{n}{located} \PYG{n}{on} \PYG{n}{the} \PYG{n}{Tasks} \PYG{n}{toolbar}
   \PYG{n}{AVToolButton} \PYG{n}{mySecureButton} \PYG{o}{=} \PYG{n}{AVToolBarGetButtonByName}\PYG{p}{(}\PYG{n}{myToolBar}\PYG{p}{,}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SecureTask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{mySecureButton} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The button was not successfully retrieved}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Remove} \PYG{n}{the} \PYG{n}{SecureTask} \PYG{n}{button} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{n}{Tasks} \PYG{n}{toolbar}
   \PYG{n}{AVToolButtonRemove}\PYG{p}{(}\PYG{n}{mySecureButton}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Update} \PYG{n}{the} \PYG{n}{toolbar}
   \PYG{n}{AVToolBarUpdateButtonStates}\PYG{p}{(}\PYG{n}{myToolBar}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
You can invoke the \sphinxcode{\sphinxupquote{AVToolButtonDestroy}} method to destroy a button.
\end{sphinxadmonition}


\section{Creating toolbar button callback functions}
\label{\detokenize{Plugins_Toolbutton:creating-toolbar-button-callback-functions}}
You can create a toolbar button callback function which is invoked by Adobe Reader or Acrobat when a user clicks a button. For the purposes of this discussion, a simplistic user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{ShowButtonMessage}} is introduced. This method displays a message box by invoking the \sphinxcode{\sphinxupquote{AVAlertNote}} method. The following code shows the body of the \sphinxcode{\sphinxupquote{ShowButtonMessage}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{ShowButtonMessage} \PYG{p}{(}\PYG{n}{void}\PYG{o}{*} \PYG{n}{data}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
     \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A button was clicked.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The data parameter for this and the other callbacks can be used to maintain private data that is used by the callback. Notice that this user\sphinxhyphen{}defined function is declared using the \sphinxcode{\sphinxupquote{ACCB1}} and \sphinxcode{\sphinxupquote{ACCB2}} macros. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_20671}{Using callback functions}.)

To create a callback for a button, create an \sphinxcode{\sphinxupquote{AVExecuteProc}} object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVExecuteProc} \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{AVExecuteProc}} is a callback that you can create that is invoked by Acrobat or Adobe Reader when a user clicks a button. After you create an \sphinxcode{\sphinxupquote{AVExecuteProc}} object, you can invoke the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro that is defined in the Acrobat core API to convert a user\sphinxhyphen{}defined function to an Acrobat callback. For example, you can invoke \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} to convert \sphinxcode{\sphinxupquote{ShowButtonMessage}} to a callback function. The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro requires the following arguments:
\begin{itemize}
\item {} 
The callback type. For example, you can pass \sphinxcode{\sphinxupquote{AVExecuteProc}}.

\item {} 
The address of the user\sphinxhyphen{}defined function to convert to a callback.

\end{itemize}

The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro returns a callback of the specified type that invokes the user\sphinxhyphen{}defined function whose address was passed as the second argument. The following lines of code shows the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro converting the \sphinxcode{\sphinxupquote{ShowButtonMessage}} user\sphinxhyphen{}defined function to a \sphinxcode{\sphinxupquote{AVExecuteProc}} callback.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVExecuteProc} \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{ExecProcPtr}\PYG{o}{=} \PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{AVExecuteProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ShowButtonMessage}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

After you create an \sphinxcode{\sphinxupquote{AVExecuteProc}} callback, you can invoke the \sphinxcode{\sphinxupquote{AVToolButtonSetExecuteProc}} method to associate a button with a callback. That is, when a user clicks a button, Acrobat or Adobe Reader will invoke the user\sphinxhyphen{}defined function whose address was passed to the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro. The \sphinxcode{\sphinxupquote{AVToolButtonSetExecuteProc}} method requires the following parameters:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVToolButton}} object that represents the button to associate with the callback

\item {} 
An \sphinxcode{\sphinxupquote{AVExecuteProc}} object that represents the callback function

\item {} 
The address of a user\sphinxhyphen{}defined data structure that can be passed to the user\sphinxhyphen{}defined function

\end{itemize}

When you are done with a button callback, invoke the \sphinxcode{\sphinxupquote{ASCallbackDestroy}} method to release the memory that it consumes.

The following code example creates a callback function for a button.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{a} \PYG{n}{toolbar} \PYG{n}{button} \PYG{n}{callback} \PYG{n}{function}
   \PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{ShowButtonMessage} \PYG{p}{(}\PYG{n}{void}\PYG{o}{*} \PYG{n}{data}\PYG{p}{)}

   \PYG{p}{\PYGZob{}}
   \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A button was clicked.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginInit} \PYG{p}{(}\PYG{n}{void}\PYG{p}{)}

   \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{an} \PYG{n}{AVToolButton} \PYG{n+nb}{object}
   \PYG{n}{AVToolButton} \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{AVIcon} \PYG{n+nb}{object}
   \PYG{n}{AVIcon} \PYG{n}{myIcon} \PYG{o}{=} \PYG{p}{(}\PYG{n}{AVCursor}\PYG{p}{)}\PYG{n}{LoadBitmap}\PYG{p}{(}\PYG{n}{gHINSTANCE}\PYG{p}{,} \PYG{n}{MAKEINTRESOURCE}\PYG{p}{(}\PYG{n}{IDB\PYGZus{}BITMAP1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{button}
   \PYG{n}{MyButton} \PYG{o}{=} \PYG{n}{AVToolButtonNew} \PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyExtn:MyButton}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{myIcon}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{File} \PYG{n}{toolbar}
   \PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n}{toolbarName}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{File}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{;}
   \PYG{n}{AVToolBar} \PYG{n}{ToolBar} \PYG{o}{=} \PYG{n}{AVAppGetToolBarByName}\PYG{p}{(}\PYG{n}{toolbarName}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{toolbar} \PYG{n}{button} \PYG{n}{callback}
   \PYG{n}{AVExecuteProc} \PYG{n}{ExecProcPtr} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto} \PYG{p}{(}\PYG{n}{AVExecuteProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ShowButtonMessage}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVToolButtonSetExecuteProc} \PYG{p}{(}\PYG{n}{MyButton}\PYG{p}{,} \PYG{n}{ExecProcPtr}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Attach} \PYG{n}{the} \PYG{n}{button}
   \PYG{n}{AVToolBarAddButton}\PYG{p}{(}\PYG{n}{ToolBar}\PYG{p}{,} \PYG{n}{MyButton}\PYG{p}{,} \PYG{n}{FALSE}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Release} \PYG{n}{the} \PYG{n}{callback} \PYG{n}{function}
   \PYG{n}{ASCallbackDestroy}\PYG{p}{(}\PYG{n}{ExecProcPtr}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginUnload} \PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
   \PYG{n}{ASCallbackDestroy} \PYG{p}{(}\PYG{n}{ExecProcPtr}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASCallbackDestroy} \PYG{p}{(}\PYG{n}{CompEnabledProcPtr}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ASCallbackDestroy} \PYG{p}{(}\PYG{n}{CompMarkedProcPtr}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Notice that the application logic that creates a toolbar button is located in the \sphinxcode{\sphinxupquote{PluginInit}} procedure. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_58810}{About plugin initialization}.)
\end{sphinxadmonition}


\chapter{Creating Annotations}
\label{\detokenize{Plugins_Annotations:creating-annotations}}\label{\detokenize{Plugins_Annotations::doc}}
An annotation associates an object such as a note, sound, or movie with a location on a page of a PDF document, or provides a way to interact with the user by means of the mouse and keyboard.

The Acrobat core API provides methods for working with annotations in PDF documents. Annotations are represented by a \sphinxcode{\sphinxupquote{PDAnnot}} typedef, which is the abstract superclass for all annotations.

Several annotation types exist, which are identified by their subtype. Each subtype can have additional properties that extend the basic ones. The subtype for text annotations (also called notes) is text. The subtype for link annotations is link. The Acrobat core API contains two built\sphinxhyphen{}in annotation typedefs \sphinxcode{\sphinxupquote{PDTextAnnot}} and \sphinxcode{\sphinxupquote{PDLinkAnnot}}. A \sphinxcode{\sphinxupquote{PDTextAnnot}} object corresponds to a text annotation and a \sphinxcode{\sphinxupquote{PDLinkAnnot}} object corresponds to a link annotation.

You can use \sphinxcode{\sphinxupquote{PDAnnot}} methods to get and set various annotation properties, such as color, date, title, location, and subtype. For example, you can invoke the \sphinxcode{\sphinxupquote{PDAnnotSetColor}} method to set the color of an annotation.

\begin{sphinxadmonition}{note}{Note:}
This chapter does not discuss how to create 3D annotations. (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_43763}{Creating 3D Annotations}.)
\end{sphinxadmonition}


\section{Working with text annotations}
\label{\detokenize{Plugins_Annotations:working-with-text-annotations}}
The Acrobat API lets you create text annotations and retrieve and modify attributes of an existing text annotation. Acrobat displays text annotations as sticky notes.


\subsection{Creating text annotations}
\label{\detokenize{Plugins_Annotations:creating-text-annotations}}
You can create a text annotation by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a rectangle region that specifies the annotation’s location. To create a rectangle region, create an \sphinxcode{\sphinxupquote{ASFixedRect}} object.

\item {} 
Define the rectangle’s borders by setting the \sphinxcode{\sphinxupquote{ASFixedRect}} object’s left, top, right, and bottom attributes.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDPage}} object that represents the page that will contain the new annotation by invoking the \sphinxcode{\sphinxupquote{PDDocAcquirePage}} method. The first argument passed to this method is a \sphinxcode{\sphinxupquote{PDDoc}} object that represents the PDF document and the second is an \sphinxcode{\sphinxupquote{ASInt32}} object that represents the page number on which the annotation is applied. This method returns a \sphinxcode{\sphinxupquote{PDPage}} object.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDAnnot}} object by invoking the \sphinxcode{\sphinxupquote{PDPageCreateAnnot}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDPage}} object that represents the page that will contain the new annotation.

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that represents the annotation’s subtype. Because a text annotation is created, specify \sphinxcode{\sphinxupquote{Text}} as the annotation’s subtype. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

\item {} 
The address of the \sphinxcode{\sphinxupquote{ASFixedRect}} object.

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Cast the \sphinxcode{\sphinxupquote{PDAnnot}} object to a \sphinxcode{\sphinxupquote{PDTextAnnot}} object by invoking the \sphinxcode{\sphinxupquote{CastToPDTextAnnot}} method. This method requires a \sphinxcode{\sphinxupquote{PDAnnot}} object and returns a \sphinxcode{\sphinxupquote{PDTextAnnot}} object.

\item {} 
Open the text annotation by invoking the \sphinxcode{\sphinxupquote{PDTextAnnotSetOpen}} method. Opening an annotation enables you to set its content. This method requires a \sphinxcode{\sphinxupquote{PDTextAnnot}} object and an \sphinxcode{\sphinxupquote{ASBool}} value that specifies \sphinxcode{\sphinxupquote{true}}.

\item {} 
Set the text of the annotation by invoking the \sphinxcode{\sphinxupquote{PDTextAnnotSetContents}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDTextAnnot}} object that represents the annotation for which text is set.

\item {} 
A character pointer that specifies the text to set.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} object that specifies the length of the character pointer.

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
Add the text annotation to the page by invoking the \sphinxcode{\sphinxupquote{PDPageAddAnnot}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDPage}} object that represents the page that will contain the new annotation.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} object that specifies the index that controls where the annotation is added. The first annotation in the array has an index of zero. Passing a value of \sphinxhyphen{}2 adds the annotation to the end of the array.

\item {} 
A \sphinxcode{\sphinxupquote{PDTextAnnot}} object that represents the annotation.

\end{itemize}

\end{enumerate}

The following code example adds a text annotation to a PDF document page. In this code example, a \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} exists. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDPage} \PYG{n}{page} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{PDAnnot} \PYG{n}{annot}\PYG{p}{,}\PYG{n}{textannot}\PYG{p}{;}
\PYG{n}{char}\PYG{o}{*} \PYG{n}{ptr} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is initial text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASFixed} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n}{define} \PYG{n}{its} \PYG{n}{borders}
\PYG{n}{ASFixedRect} \PYG{n}{fr}\PYG{p}{;}
\PYG{n}{fr}\PYG{o}{.}\PYG{n}{left} \PYG{o}{=} \PYG{n}{ASInt32ToFixed}\PYG{p}{(}\PYG{l+m+mi}{36}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{fr}\PYG{o}{.}\PYG{n}{top} \PYG{o}{=} \PYG{n}{ASInt32ToFixed}\PYG{p}{(}\PYG{l+m+mi}{792}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{36}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{fr}\PYG{o}{.}\PYG{n}{right} \PYG{o}{=} \PYG{n}{ASInt32ToFixed}\PYG{p}{(}\PYG{l+m+mi}{136}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{fr}\PYG{o}{.}\PYG{n}{bottom} \PYG{o}{=} \PYG{n}{ASInt32ToFixed}\PYG{p}{(}\PYG{l+m+mi}{792}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{136}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDPage} \PYG{n+nb}{object}
\PYG{n}{page} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDAnnot} \PYG{n+nb}{object}
\PYG{n}{annot} \PYG{o}{=} \PYG{n}{PDPageCreateAnnot} \PYG{p}{(}\PYG{n}{page}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{fr}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Cast} \PYG{n}{the} \PYG{n}{PDAnnot} \PYG{n+nb}{object} \PYG{n}{to} \PYG{n}{a} \PYG{n}{PDTextAnnot} \PYG{n+nb}{object}
\PYG{n}{textannot} \PYG{o}{=} \PYG{n}{CastToPDTextAnnot}\PYG{p}{(}\PYG{n}{annot}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Open} \PYG{n}{the} \PYG{n}{annotation}\PYG{p}{,} \PYG{n+nb}{set} \PYG{n}{the} \PYG{n}{text}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{add} \PYG{n}{it} \PYG{n}{to} \PYG{n}{a} \PYG{n}{page}
\PYG{n}{PDTextAnnotSetOpen} \PYG{p}{(}\PYG{n}{textannot}\PYG{p}{,} \PYG{n}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDTextAnnotSetContents} \PYG{p}{(}\PYG{n}{textannot}\PYG{p}{,} \PYG{n}{ptr}\PYG{p}{,} \PYG{n}{strlen} \PYG{p}{(}\PYG{n}{ptr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPageAddAnnot}\PYG{p}{(}\PYG{n}{page}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{textannot}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Retrieving existing annotations}
\label{\detokenize{Plugins_Annotations:retrieving-existing-annotations}}
You can use the Acrobat core API to retrieve existing annotations located within a PDF document by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{PDDoc}} object that represents the PDF document that contains annotations. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\item {} 
Search for existing annotations by iterating through the PDF document page by page. One way to perform this task is to create a for loop structure and invoke the \sphinxcode{\sphinxupquote{PDDocGetNumPages}} method. This method requires a \sphinxcode{\sphinxupquote{PDDoc}} object as an argument and returns the number of pages within the document.

\item {} 
For each page within the PDF document, obtain a \sphinxcode{\sphinxupquote{PDPage}} object by invoking the \sphinxcode{\sphinxupquote{PDDocAcquirePage}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} object that represents the PDF document that contains the page.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} object that represents the page number.

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
After you obtain a \sphinxcode{\sphinxupquote{PDPage}} object, get the number of annotations located on the page by invoking the \sphinxcode{\sphinxupquote{PDPageGetNumAnnots}} method. This method requires a \sphinxcode{\sphinxupquote{PDPage}} object as an argument and returns an \sphinxcode{\sphinxupquote{ASInt32}} object representing the number of annotations located on the page.

\item {} 
For each annotation on a page, invoke the \sphinxcode{\sphinxupquote{PDPageGetAnnot}} method. This method requires a \sphinxcode{\sphinxupquote{PDPage}} object and an \sphinxcode{\sphinxupquote{ASInt32}} object that represents the index of the annotation. This method returns a \sphinxcode{\sphinxupquote{PDAnnot}} object.

\end{enumerate}

The following code example retrieves existing annotations located within a PDF document. After an annotation is retrieved, information about the annotation is displayed within an alert box. Information about the annotation is retrieved by invoking the \sphinxcode{\sphinxupquote{PDAnnotGetSubtype}} method. This method returns an \sphinxcode{\sphinxupquote{ASAtom}} object representing the annotation’s subtype. For example, if the annotation is a stamp, then an \sphinxcode{\sphinxupquote{ASAtom}} object storing the value \sphinxcode{\sphinxupquote{Stamp}} is returned. You can get the string value from an \sphinxcode{\sphinxupquote{ASAtom}} object by invoking the \sphinxcode{\sphinxupquote{ASAtomGetString}} method and passing the \sphinxcode{\sphinxupquote{ASAtom}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDPage} \PYG{n}{page}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{i}\PYG{p}{,}\PYG{n}{i2}\PYG{p}{;}
\PYG{n}{PDAnnot} \PYG{n}{annot}\PYG{p}{;}
\PYG{n}{char}\PYG{o}{*} \PYG{n}{ptr}\PYG{p}{;}
\PYG{n}{char} \PYG{n}{buf}\PYG{p}{[}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{ASAtom} \PYG{n}{atom}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Iterate} \PYG{n}{through} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{document} \PYG{n}{page} \PYG{n}{by} \PYG{n}{page}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{PDDocGetNumPages}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{each} \PYG{n}{page} \PYG{n}{within} \PYG{n}{the} \PYG{n}{document}
 \PYG{n}{page} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{each} \PYG{n}{annotation} \PYG{n}{on} \PYG{n}{the} \PYG{n}{page}
 \PYG{k}{for} \PYG{p}{(}\PYG{n}{i2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i2} \PYG{o}{\PYGZlt{}} \PYG{n}{PDPageGetNumAnnots}\PYG{p}{(}\PYG{n}{page}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i2}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{a} \PYG{n}{specific} \PYG{n}{annotation}
      \PYG{n}{annot} \PYG{o}{=} \PYG{n}{PDPageGetAnnot}\PYG{p}{(}\PYG{n}{page}\PYG{p}{,}\PYG{n}{i2}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{PDAnnotIsValid}\PYG{p}{(}\PYG{n}{annot}\PYG{p}{)}\PYG{p}{)}      \PYG{p}{\PYGZob{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Display} \PYG{n}{subtype} \PYG{n}{information} \PYG{n}{about} \PYG{n}{the} \PYG{n}{annotation}
         \PYG{n}{atom} \PYG{o}{=} \PYG{n}{PDAnnotGetSubtype}\PYG{p}{(}\PYG{n}{annot}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Cast} \PYG{n}{the} \PYG{n}{ASAtom} \PYG{n+nb}{object} \PYG{n}{to} \PYG{n}{a} \PYG{n}{character} \PYG{n}{pointer}
         \PYG{n}{ptr} \PYG{o}{=} \PYG{p}{(}\PYG{n}{char}\PYG{o}{*}\PYG{p}{)} \PYG{n}{ASAtomGetString}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{)}\PYG{p}{;}
          \PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The annotation}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s subtype is }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ptr}\PYG{p}{)}\PYG{p}{;}
          \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{n}{buf}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In the previous code example, assume a \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} exists. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)
\end{sphinxadmonition}


\subsection{Modifying text annotations}
\label{\detokenize{Plugins_Annotations:modifying-text-annotations}}
You can modify an annotation after you retrieve it. For example, you can retrieve an existing text annotation and modify its text. For information about retrieving an annotation, see \sphinxhref{Plugins\_Annotations.html\#50618420\_93262}{Retrieving existing annotations}.

Before you modify an annotation, determine whether the annotation is the correct subtype. That is, before modifying a text annotation, ensure that the annotation is a \sphinxcode{\sphinxupquote{Text}} annotation. You can determine whether an annotation is the correct subtype by invoking the \sphinxcode{\sphinxupquote{PDAnnotGetSubtype}} method. This method requires a \sphinxcode{\sphinxupquote{PDAnnot}} object and returns an \sphinxcode{\sphinxupquote{ASAtom}} object that specifies the annotation’s subtype.

When modifying a text annotation, it is recommended that you check its contents. For example, you can retrieve all text annotations in a PDF document, retrieve the annotation’s text, and modify annotations that contain specific text. To retrieve the text of an annotation, invoke the \sphinxcode{\sphinxupquote{PDTextAnnotGetContents}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDTextAnnot}} object that contains text to retrieve.

\item {} 
A character pointer that is populated with the annotation’s text.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} object that represents the size of the character pointer.

\end{itemize}

The following code example iterates through all annotations located in a PDF document. Each valid annotation is checked to determine whether it is a \sphinxcode{\sphinxupquote{Text}} annotation. This task is performed by invoking the \sphinxcode{\sphinxupquote{PDAnnotGetSubtype}} method. If the annotations is a \sphinxcode{\sphinxupquote{Text}} annotation, then the annotation’s text is retrieved by invoking the \sphinxcode{\sphinxupquote{PDTextAnnotGetContents}} method.

Because the size of the annotation’s text is unknown, the \sphinxcode{\sphinxupquote{PDTextAnnotGetContents}} is invoked twice. The first time it is invoked, \sphinxcode{\sphinxupquote{NULL}} is passed as the buffer address (second argument) and \sphinxcode{\sphinxupquote{0}} is specified as the buffer size (third argument). The text length is returned to an \sphinxcode{\sphinxupquote{ASInt32}} object named \sphinxcode{\sphinxupquote{bufSize}}. The \sphinxcode{\sphinxupquote{ASmalloc}} method is invoked which allocates \sphinxcode{\sphinxupquote{bufSize}} bytes to the character pointer.

The second time \sphinxcode{\sphinxupquote{PDTextAnnotGetContents}} is invoked, the allocated character pointer is passed as well as the \sphinxcode{\sphinxupquote{ASInt32}} object named \sphinxcode{\sphinxupquote{bufSize}}. The character pointer is populated with the annotation’s text.

Next the \sphinxcode{\sphinxupquote{strcmp}} method is invoked to compare the annotation’s text with a specific string value. If the annotation’s text matches the string value, then the \sphinxcode{\sphinxupquote{PDTextAnnotSetContents}} method is invoked, which replaces the annotation’s text with new text.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDPage} \PYG{n}{page}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{i}\PYG{p}{,}\PYG{n}{i2}\PYG{p}{;}
\PYG{n}{PDAnnot} \PYG{n}{annot}\PYG{p}{;}
\PYG{n}{char} \PYG{n}{setbuf}\PYG{p}{[}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{ASAtom} \PYG{n}{atom}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Iterate} \PYG{n}{through} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{document} \PYG{n}{page} \PYG{n}{by} \PYG{n}{page}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{PDDocGetNumPages}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i} \PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{each} \PYG{n}{page} \PYG{n}{within} \PYG{n}{the} \PYG{n}{document}
 \PYG{n}{page} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{each} \PYG{n}{annotation} \PYG{n}{on} \PYG{n}{the} \PYG{n}{page}
 \PYG{k}{for} \PYG{p}{(}\PYG{n}{i2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i2} \PYG{o}{\PYGZlt{}} \PYG{n}{PDPageGetNumAnnots}\PYG{p}{(}\PYG{n}{page}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i2}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{a} \PYG{n}{specific} \PYG{n}{annotation}
     \PYG{n}{annot} \PYG{o}{=} \PYG{n}{PDPageGetAnnot}\PYG{p}{(}\PYG{n}{page}\PYG{p}{,}\PYG{n}{i2}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{PDAnnotIsValid}\PYG{p}{(}\PYG{n}{annot}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Determine} \PYG{k}{if} \PYG{n}{the} \PYG{n}{annotation} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{Text} \PYG{n}{annotation}
         \PYG{k}{if} \PYG{p}{(}\PYG{n}{PDAnnotGetSubtype}\PYG{p}{(}\PYG{n}{annot}\PYG{p}{)} \PYG{o}{==} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{character} \PYG{n}{pointer} \PYG{n}{to} \PYG{n}{store} \PYG{n}{the} \PYG{n}{annotation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s text}
             \PYG{n}{char} \PYG{o}{*} \PYG{n}{annBuf}\PYG{p}{;}
              \PYG{n}{ASInt32} \PYG{n}{bufSize} \PYG{o}{=} \PYG{n}{PDTextAnnotGetContents}\PYG{p}{(}\PYG{n}{annot}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Allocate} \PYG{n}{the} \PYG{n}{size} \PYG{n}{of} \PYG{n}{bufSize} \PYG{n}{to} \PYG{n}{the} \PYG{n}{character} \PYG{n}{pointer}
             \PYG{n}{annBuf} \PYG{o}{=} \PYG{p}{(}\PYG{n}{char}\PYG{o}{*}\PYG{p}{)}\PYG{n}{ASmalloc}\PYG{p}{(}\PYG{p}{(}\PYG{n}{os\PYGZus{}size\PYGZus{}t}\PYG{p}{)}\PYG{n}{bufSize}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Populate} \PYG{n}{annBuf} \PYG{k}{with} \PYG{n}{the} \PYG{n}{annotation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s text}
             \PYG{n}{PDTextAnnotGetContents}\PYG{p}{(}\PYG{n}{annot}\PYG{p}{,} \PYG{n}{annBuf}\PYG{p}{,} \PYG{n}{bufSize}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Compare} \PYG{n}{the} \PYG{n}{contents} \PYG{n}{of} \PYG{n}{annBuf} \PYG{k}{with} \PYG{n}{a} \PYG{n}{string}
             \PYG{k}{if} \PYG{p}{(}\PYG{n}{strcmp}\PYG{p}{(}\PYG{n}{annBuf}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is initial text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Modify} \PYG{n}{the} \PYG{n}{annotation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s text}
                 \PYG{n}{sprintf} \PYG{p}{(}\PYG{n}{setbuf}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is the new text for the annotation.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
                  \PYG{n}{PDTextAnnotSetOpen} \PYG{p}{(}\PYG{n}{annot}\PYG{p}{,} \PYG{n}{true}\PYG{p}{)}\PYG{p}{;}
                  \PYG{n}{PDTextAnnotSetContents} \PYG{p}{(}\PYG{n}{annot}\PYG{p}{,} \PYG{n}{setbuf}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{setbuf}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
              \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In the previous code example, assume a \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} exists. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)
\end{sphinxadmonition}


\section{Working with redaction annotations}
\label{\detokenize{Plugins_Annotations:working-with-redaction-annotations}}
The Acrobat API lets you create redaction annotations and access and modify the attributes in an existing redaction annotation. It also lets you apply an existing redaction annotation, which permanently removes the redacted material from the PDF document.

A redaction annotation identifies content to be removed from the document. The intent of redaction annotations is to enable the following process:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create redaction annotations that identify the content to be removed from the document. The redaction annotation specifies a rectangle that covers the content to be removed and specifies the appearance of the rectangle and associated information.

\item {} 
Apply redaction annotations, which remove the content in the area specified by a set of redaction annotations. In the removed content’s place, some marking appears to indicate that the area was redacted. Also, the redaction annotations are removed from the PDF document.

\end{enumerate}

A single content removal operation can remove the content specified by multiple redaction annotations.


\subsection{Creating a redaction annotation}
\label{\detokenize{Plugins_Annotations:creating-a-redaction-annotation}}
To create a redaction annotation that identifies the content to be removed from the document and the appearance of the redaction annotation, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{PDRedactParamsRec}} structure and populate it with values that describe characteristics of the redaction annotation, such as the page number on which the redaction is to be applied and the regions on the page being redacted.

\item {} 
Apply the redaction annotation to the document, by invoking the \sphinxcode{\sphinxupquote{PDDocCreateRedaction}} method.

\end{enumerate}

The \sphinxcode{\sphinxupquote{PDDocCreateRedaction}} function automatically sets common annotation properties, such as the annotation rectangle (\sphinxcode{\sphinxupquote{Rect}} ) and the annotations unique name (\sphinxcode{\sphinxupquote{NM}} ). Further changes to the annotation are unnecessary. However, if you want to set values for annotation properties not set by the \sphinxcode{\sphinxupquote{PDDocCreateRedaction}} method, convert the \sphinxcode{\sphinxupquote{PDAnnot}} object returned from that method into a Cos object and set its dictionary values. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86959}{Working with Cos Objects} and \sphinxhref{Plugins\_3D\_samples.html\#50618421\_26840}{Creating the attributes dictionary}.)


\subsection{Modifying an existing redaction annotation}
\label{\detokenize{Plugins_Annotations:modifying-an-existing-redaction-annotation}}
To modify the attributes of an existing redaction annotation, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Obtain a pointer to the redaction annotation. (See \sphinxhref{Plugins\_Annotations.html\#50618420\_93262}{Retrieving existing annotations}.) Ensure that the pointer references an annotation with the \sphinxcode{\sphinxupquote{Subtype}} value \sphinxcode{\sphinxupquote{Redact}}.

\item {} 
Get the redaction annotation’s properties, by invoking the PDRedactionGetProps function. The first argument is the pointer to the redaction annotation obtained in Step \sphinxtitleref{Obtain a pointer to the redaction annotation. (See Retrieving existing annotations.) Ensure that the pointer references an annotation with the ``Subtype`} value \sphinxcode{\sphinxupquote{Redact}}. <Plugins\_Annotations.html\#50618420\_94111>`\_\_ and the second argument is a pointer to the \sphinxcode{\sphinxupquote{PDRedactParamsRec}} structure.

\item {} 
Modify the members of the \sphinxcode{\sphinxupquote{PDRedactParamsRec}} structure supplied by the PDRedactionGetProps function. The first argument is the pointer to the redaction annotation obtained in Step \sphinxtitleref{Obtain a pointer to the redaction annotation. (See Retrieving existing annotations.) Ensure that the pointer references an annotation with the ``Subtype`} value \sphinxcode{\sphinxupquote{Redact}}. <Plugins\_Annotations.html\#50618420\_94111>`\_\_, and the second argument is a pointer to the \sphinxcode{\sphinxupquote{PDRedactParamsRec}} structure.

\item {} 
Set the redaction annotation’s properties by invoking the \sphinxcode{\sphinxupquote{PDRedactionSetProps}} function.

\end{enumerate}


\subsection{Applying redaction annotations (removing redacted content)}
\label{\detokenize{Plugins_Annotations:applying-redaction-annotations-removing-redacted-content}}
To apply previously created redaction annotations, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a PDApplyRedactionParamsRec structure that specifies the redaction annotations to apply. The structure also lets you provide callback functions that Acrobat invokes as it applies the redaction annotations.

\item {} 
Apply the redaction annotations by invoking the \sphinxcode{\sphinxupquote{PDDocApplyRedactions}} function. This function name is overloaded with two forms. The simpler form specifies a first argument that is the pointer to the document, and the second argument that is the structure created in Step \sphinxhref{Plugins\_Annotations.html\#50618420\_30308}{Create a PDApplyRedactionParamsRec structure that specifies the redaction annotations to apply. The structure also lets you provide callback functions that Acrobat invokes as it applies the redaction annotations.}. The more complex forms let you specify progress callbacks.

\end{enumerate}


\chapter{Working with Bookmarks}
\label{\detokenize{Plugins_Bookmark:working-with-bookmarks}}\label{\detokenize{Plugins_Bookmark::doc}}
You can use the core API to create new bookmarks and search for existing ones. A bookmark is a link with representative text on the Bookmarks tab in the navigation pane. Each bookmark navigates to a different view or page within a PDF document. You can also use a bookmark to navigate to a specific destination within a PDF document, to another document (PDF or other), or to a web page. Bookmarks can also perform actions, such as executing a menu item or displaying a graphic file.


\section{About bookmarks}
\label{\detokenize{Plugins_Bookmark:about-bookmarks}}
Bookmarks are represented by a \sphinxcode{\sphinxupquote{PDBookmark}} object. All bookmarks have the following attributes:
\begin{itemize}
\item {} 
A title that appears in Adobe Reader or Acrobat.

\item {} 
An action that specifies what happens when a user clicks on the bookmark. The typical action for a bookmark is to move to another location in the current document, although other actions can be specified.

\end{itemize}

Every document has a root bookmark. The root bookmark does not represent a physical bookmark that appears in Adobe Reader or Acrobat, but is the root from which all bookmarks in the tree are descended. Bookmarks are organized in a tree structure in which each bookmark has zero or more children that appear indented, and zero or more siblings that appear at the same indentation level. All bookmarks except the bookmark at the top level of the hierarchy have a parent, the bookmark under which it is indented. A bookmark is open if its children are visible on screen, and closed if they are not.

The following image shows how bookmarks appear in Adobe Reader or Acrobat.

\noindent\sphinxincludegraphics{{bookmarks}.png}

The Acrobat core API contains methods that operate on bookmarks. Using these methods, you can perform the following tasks:
\begin{itemize}
\item {} 
Create new bookmarks

\item {} 
Get and set various attributes of a bookmark (such as its title or action or whether it is open)

\item {} 
Search for a bookmark

\end{itemize}


\section{Creating bookmarks}
\label{\detokenize{Plugins_Bookmark:creating-bookmarks}}
Before you can create a bookmark, you must create a \sphinxcode{\sphinxupquote{PDDoc}} object that represents the PDF document to which the bookmark is added. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

To create bookmarks for a PDF document, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Get the root of the PDF document’s bookmark tree by invoking the \sphinxcode{\sphinxupquote{PDDocGetBookmarkRoot}} method. This method requires a \sphinxcode{\sphinxupquote{PDDoc}} object and returns a \sphinxcode{\sphinxupquote{PDBookmark}} object that represents the document’s root bookmark. The document’s root bookmark does not appear in Adobe Reader or Acrobat.

\item {} 
Create another \sphinxcode{\sphinxupquote{PDBookmark}} object that represents the bookmark to add to the document’s root bookmark by invoking the \sphinxcode{\sphinxupquote{PDBookmarkAddNewChild}} method. This method requires a \sphinxcode{\sphinxupquote{PDBookmark}} object that represents the parent bookmark (in this case the parent bookmark is also the document’s root bookmark) and an \sphinxcode{\sphinxupquote{ASAtom}} object that represents the bookmark’s title.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDBookmark}} object that represents a sibling bookmark to the bookmark that was added to the document’s root bookmark (the sibling bookmark is also a child of the document’s root bookmark). You can perform this task by invoking the \sphinxcode{\sphinxupquote{PDBookmarkAddNewSibling}} method. This method requires a \sphinxcode{\sphinxupquote{PDBookmark}} object that represents the new bookmark’s sibling bookmark and an \sphinxcode{\sphinxupquote{ASAtom}} object that represents the bookmark’s title.

\end{enumerate}

The following code example adds two new bookmarks to a PDF document. After each bookmark is created, the \sphinxcode{\sphinxupquote{PDBookmarkIsValid}} method is invoked to determine whether the bookmark is valid. The name of the \sphinxcode{\sphinxupquote{PDDoc}} object used in this code example is \sphinxcode{\sphinxupquote{myPDDoc}}. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{a} \PYG{n}{bookmark} \PYG{n+nb}{object}
\PYG{n}{PDBookmark} \PYG{n}{rootBookmark}\PYG{p}{;}
\PYG{n}{PDBookmark} \PYG{n}{childBookmark} \PYG{p}{;}
\PYG{n}{PDBookmark} \PYG{n}{siblingBookmark}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{root} \PYG{n}{bookmark}
\PYG{n}{rootBookmark} \PYG{o}{=} \PYG{n}{PDDocGetBookmarkRoot}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{PDBookmarkIsValid}\PYG{p}{(}\PYG{n}{rootBookmark}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Add} \PYG{n}{a} \PYG{n}{child} \PYG{n}{bookmark} \PYG{n}{to} \PYG{n}{the} \PYG{n}{root} \PYG{n}{bookmark}
 \PYG{n}{childBookmark} \PYG{o}{=} \PYG{n}{PDBookmarkAddNewChild}\PYG{p}{(}\PYG{n}{rootBookmark}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bookmark1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{if} \PYG{p}{(}\PYG{n}{PDBookmarkIsValid}\PYG{p}{(}\PYG{n}{childBookmark}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Add} \PYG{n}{a} \PYG{n}{sibling} \PYG{n}{bookmark} \PYG{n}{to} \PYG{n}{the} \PYG{n}{child} \PYG{n}{bookmark}
     \PYG{n}{siblingBookmark} \PYG{o}{=} \PYG{n}{PDBookmarkAddNewSibling}\PYG{p}{(}\PYG{n}{childBookmark}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bookmark2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Defining bookmark actions}
\label{\detokenize{Plugins_Bookmark:defining-bookmark-actions}}
After you create a new bookmark, you must define an action that occurs when a user clicks on the bookmark. Otherwise, nothing occurs when a user clicks on the bookmark.

To create an action for a bookmark, you must create a \sphinxcode{\sphinxupquote{PDAction}} object that represents the action that occurs when a user clicks on a bookmark. Once you create a \sphinxcode{\sphinxupquote{PDAction}} object, you can assign it to a bookmark. (See \sphinxhref{Plugins\_Bookmark.html\#50618419\_70965}{Assigning an action to a bookmark}.)

As specified earlier in this chapter, a typical bookmark action is to move to another location in the current document. To illustrate how to create a bookmark action, this section defines a bookmark action that displays a specific page in a PDF document when a user clicks the bookmark.

To define a bookmark action that generates a specific view of a PDF document, you create a \sphinxcode{\sphinxupquote{PDAction}} object by invoking the \sphinxcode{\sphinxupquote{PDActionNewFromDest}} method. This method creates a new action that directs the user to the specified destination view and requires the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} that represents the PDF document for which the action is created.

\item {} 
A \sphinxcode{\sphinxupquote{PDViewDestination}} object that represents a specific view in the PDF document. (See \sphinxhref{Plugins\_Bookmark.html\#50618419\_74543}{Creating a PDViewDestination object}.)

\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} that represents the destination document. This object is the same object that is specified as the first parameter.

\end{itemize}

The \sphinxcode{\sphinxupquote{PDActionNewFromDest}} method returns a \sphinxcode{\sphinxupquote{PDAction}} method.


\subsubsection{Creating a PDViewDestination object}
\label{\detokenize{Plugins_Bookmark:creating-a-pdviewdestination-object}}
You must create a \sphinxcode{\sphinxupquote{PDViewDestination}} object in order to invoke the \sphinxcode{\sphinxupquote{PDActionNewFromDest}} method. To create a \sphinxcode{\sphinxupquote{PDViewDestination}} object, invoke the \sphinxcode{\sphinxupquote{AVPageViewToViewDest}} method and pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVPageView}} object that represents the page view from which the destination is created. For information about creating this object, see \sphinxhref{Plugins\_Bookmark.html\#50618419\_24473}{Creating a AVPageView object}.

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that specifies the fit type of the view destination (see the table that follows this list).

\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} object that represents the PDF document for which the view is established.

\end{itemize}

The \sphinxcode{\sphinxupquote{AVPageViewToViewDest}} method returns a \sphinxcode{\sphinxupquote{PDViewDestination}} object. The following table specifies the fit type values that you pass to the \sphinxcode{\sphinxupquote{AVPageViewToViewDest}} method as the second argument.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Value
&\sphinxstyletheadfamily 
Description
\\
\hline
XYZ
&
Destination specified as upper\sphinxhyphen{}left corner point and a zoom factor.
\\
\hline
Fit
&
Fits the page into the window, corresponding to the Acrobat viewer’s Fit Page menu item.
\\
\hline
FitH
&
Fits the width of the page into the window, corresponding to the Acrobat viewer’s Fit Width menu item.
\\
\hline
FitV
&
Fits the height of the page into a window.
\\
\hline
FitR
&
Fits the rectangle specified by its upper\sphinxhyphen{}left and lower\sphinxhyphen{}right corner points into the window.
\\
\hline
FitB
&
Fits the rectangle containing all visible elements on the page (known as the bounding box) into the window (corresponds to the Acrobat viewer’s Fit Visible menu item).
\\
\hline
FitBH
&
Fits the width of the bounding box into the window.
\\
\hline
FitBV
&
Fits the height of the bounding box into the window.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Creating a AVPageView object}
\label{\detokenize{Plugins_Bookmark:creating-a-avpageview-object}}
You must create an \sphinxcode{\sphinxupquote{AVPageView}} object that represents the page view in order to invoke the \sphinxcode{\sphinxupquote{AVPageViewToViewDest}} method. You can create an \sphinxcode{\sphinxupquote{AVPageView}} object by invoking the \sphinxcode{\sphinxupquote{AVDocGetPageView}} method. This method requires an \sphinxcode{\sphinxupquote{AVDoc}} that represents a PDF document whose page view is obtained and returns an \sphinxcode{\sphinxupquote{AVPageView}} object.

You can create an \sphinxcode{\sphinxupquote{AVDoc}} object that is based on the \sphinxcode{\sphinxupquote{PDDoc}} object that already exists by invoking the \sphinxcode{\sphinxupquote{AVDocFromPDDo}} c method and passing the \sphinxcode{\sphinxupquote{PDDoc}} object. You can invoke this method as an argument for the \sphinxcode{\sphinxupquote{AVDocGetPageView}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVPageView} \PYG{n}{myPageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{AVDocFromPDDoc}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Once you create an \sphinxcode{\sphinxupquote{AVPageView}} object, you can specify a specific PDF document page number by invoking the \sphinxcode{\sphinxupquote{AVPageViewGoTo}} method and passing the \sphinxcode{\sphinxupquote{AVPageView}} object and an \sphinxcode{\sphinxupquote{ASInt32}} object that represents the page number:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{pNum} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
 \PYG{n}{AVPageViewGoTo}\PYG{p}{(}\PYG{n}{myPageView}\PYG{p}{,}\PYG{n}{pNum}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Assigning an action to a bookmark}
\label{\detokenize{Plugins_Bookmark:assigning-an-action-to-a-bookmark}}
After you create both an \sphinxcode{\sphinxupquote{AVPageView}} object and an \sphinxcode{\sphinxupquote{PDViewDestination}} object, you can create a \sphinxcode{\sphinxupquote{PDAction}} object and assign it to a specific bookmark by invoking the \sphinxcode{\sphinxupquote{PDBookmarkSetAction}} method and passing the \sphinxcode{\sphinxupquote{PDBookmark}} object and the \sphinxcode{\sphinxupquote{PDAction}} object as arguments.

The following code example creates a \sphinxcode{\sphinxupquote{PDAction}} object and assigns it to a bookmark that is represented by a \sphinxcode{\sphinxupquote{PDBookmark}} object named \sphinxcode{\sphinxupquote{childBookmark}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDDoc} \PYG{n+nb}{object} \PYG{n}{based} \PYG{n}{on} \PYG{n}{the} \PYG{n}{current} \PYG{n}{PDF} \PYG{n}{document}
\PYG{n}{AVDoc} \PYG{n}{avDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVPageView} \PYG{n}{pageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPageNumber} \PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{myPDDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{AVPageView} \PYG{n+nb}{object} \PYG{n}{that} \PYG{n}{represents} \PYG{n}{the} \PYG{n}{page} \PYG{n}{view} \PYG{n}{of} \PYG{n}{a} \PYG{n}{document}
\PYG{n}{AVPageView} \PYG{n}{myPageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{AVDocFromPDDoc}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n}{page} \PYG{n}{view} \PYG{n}{to} \PYG{n}{the} \PYG{n}{second} \PYG{n}{page}
\PYG{n}{ASInt32} \PYG{n}{pNum} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{AVPageViewGoTo}\PYG{p}{(}\PYG{n}{myPageView}\PYG{p}{,}\PYG{n}{pNum}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{PDViewDestination} \PYG{n+nb}{object} \PYG{n}{that} \PYG{o+ow}{is} \PYG{n}{used} \PYG{n}{to} \PYG{n}{create} \PYG{n}{a} \PYG{n}{PDAction} \PYG{n+nb}{object}
\PYG{n}{PDViewDestination} \PYG{n}{pdvDes} \PYG{o}{=} \PYG{n}{AVPageViewToViewDest}\PYG{p}{(}\PYG{n}{myPageView}\PYG{p}{,}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDAction} \PYG{n+nb}{object}
\PYG{n}{PDAction} \PYG{n}{myAction} \PYG{o}{=} \PYG{n}{PDActionNewFromDest}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{,}\PYG{n}{pdvDes}\PYG{p}{,}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Attach} \PYG{n}{an} \PYG{n}{action} \PYG{n}{to} \PYG{n}{the} \PYG{n}{bookmark}
\PYG{n}{PDBookmarkSetAction}\PYG{p}{(}\PYG{n}{childBookmark}\PYG{p}{,}\PYG{n}{myAction}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{caution}{Caution:}
When running this code example, you must have the PDF document on which the \sphinxcode{\sphinxupquote{PDDoc}} object is based open. Otherwise, a run\sphinxhyphen{}time error occurs. Also, you must create a \sphinxcode{\sphinxupquote{PDBookmark}} object named \sphinxcode{\sphinxupquote{childBookmark}}. (See \sphinxhref{Plugins\_Bookmark.html\#50618419\_40935}{Creating bookmarks}.)
\end{sphinxadmonition}


\subsection{Removing bookmark actions}
\label{\detokenize{Plugins_Bookmark:removing-bookmark-actions}}
You can remove an action from a bookmark by invoking the \sphinxcode{\sphinxupquote{PDBookmarkRemoveAction}} method. After you remove a bookmark, you can add a new action. The \sphinxcode{\sphinxupquote{PDBookmarkRemoveAction}} method requires a \sphinxcode{\sphinxupquote{PDBookmark}} object that represents the bookmark from which the action is removed.


\subsection{Opening and closing bookmarks}
\label{\detokenize{Plugins_Bookmark:opening-and-closing-bookmarks}}
You can programmatically open and close a bookmark. To open and close a bookmark, invoke the \sphinxcode{\sphinxupquote{PDBookmarkSetOpen}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDBookmark}} object to open or close.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether to open or close the bookmark. The value \sphinxcode{\sphinxupquote{true}} specifies to open the bookmark and the value \sphinxcode{\sphinxupquote{false}} specifies to close the bookmark.

\end{itemize}

Before you invoke the \sphinxcode{\sphinxupquote{PDBookmarkSetOpen}} method, it is recommended that you invoke the \sphinxcode{\sphinxupquote{PDBookmarkIsOpen}} method to determine whether the bookmark is open. This method requires a \sphinxcode{\sphinxupquote{PDBookmark}} object and returns an \sphinxcode{\sphinxupquote{ASBool}} value. If the bookmark is open, then \sphinxcode{\sphinxupquote{true}} is returned.

The following code example retrieves and opens a bookmark whose title is \sphinxstyleemphasis{Samples}. For information about retrieving a specific bookmark, see \sphinxhref{Plugins\_Bookmark.html\#50618419\_90691}{Retrieving a specific bookmark}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
//Retrieve a bookmark whose title is Samples
PDBookmark rootBookmark, myBookmark;
char* bookmarkTitle = \PYGZdq{}Samples\PYGZdq{};


//Get the root bookmark
rootBookmark = PDDocGetBookmarkRoot(myPDDoc);


//Get the bookmark whose title is Samples
myBookmark = PDBookmarkGetByTitle (rootBookmark, bookmarkTitle, strlen(bookmarkTitle), \PYGZhy{}1);
if (PDBookmarkIsValid (myBookmark))\PYGZob{}


//Determine whether the bookmark is open
 if (!PDBookmarkIsOpen(myBookmark))\PYGZob{}

//Open the bookmark
     PDBookmarkSetOpen(myBookmark,true);
      AVAlertNote(\PYGZdq{}The bookmark was opened\PYGZdq{});
  \PYGZcb{}
\PYGZcb{}
else
  AVAlertNote(\PYGZdq{}The bookmark was not retrieved\PYGZdq{});
\end{sphinxVerbatim}


\section{Retrieving bookmarks}
\label{\detokenize{Plugins_Bookmark:retrieving-bookmarks}}
You can retrieve the root bookmark, retrieve a specific bookmark, or retrieve all bookmarks that are located within a PDF document.


\subsection{Retrieving the root bookmark}
\label{\detokenize{Plugins_Bookmark:retrieving-the-root-bookmark}}
Every PDF document has a root bookmark. The root bookmark does not represent a physical bookmark, but is the root from which all bookmarks in the tree are descended.

The following code example shows how to get a PDF document’s root bookmark by creating application logic within a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{GetFirstBookmark}}. First, the \sphinxcode{\sphinxupquote{PDDocGetBookmarkRoot}} method is invoked to get the bookmark root. This method requires a \sphinxcode{\sphinxupquote{PDDoc}} object that represents the PDF document from which the root bookmark is retrieved and returns a \sphinxcode{\sphinxupquote{PDBookmark}} object that represents the root bookmark. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

Next, the \sphinxcode{\sphinxupquote{PDBookmarkGetFirstChild}} method is invoked to get the first child of the root. If there are no bookmarks, \sphinxcode{\sphinxupquote{PDBookmarkGetFirstChild}} returns \sphinxcode{\sphinxupquote{NULL}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDBookmark} \PYG{n}{GetFirstBookmark}\PYG{p}{(}\PYG{n}{PDDoc} \PYG{n}{doc}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{PDBookmark} \PYG{n}{theroot}\PYG{p}{,} \PYG{n}{childBookmark}\PYG{p}{;}
  \PYG{n}{theroot} \PYG{o}{=} \PYG{n}{PDDocGetBookmarkRoot}\PYG{p}{(}\PYG{n}{doc}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{childBookmark} \PYG{o}{=} \PYG{n}{PDBookmarkGetFirstChild}\PYG{p}{(}\PYG{n}{theroot}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{childBookmark}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Retrieving a specific bookmark}
\label{\detokenize{Plugins_Bookmark:retrieving-a-specific-bookmark}}
You can retrieve a specific bookmark by specifying its title. The following code example retrieves a specific bookmark by invoking the \sphinxcode{\sphinxupquote{PDDocGetBookmarkRoot}} method to get the document’s root bookmark as a starting point for the search. It then invokes the \sphinxcode{\sphinxupquote{PDBookmarkGetByTitle}} method to retrieve the first bookmark whose title matches the specified title. This method requires the following arguments:
\begin{itemize}
\item {} 
The root of the bookmark tree that is searched.

\item {} 
A character pointer that specifies the title of the bookmark.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} object that specifies the length of the character pointer.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} object that specifies the number of bookmark levels to search. The value \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}} specifies to search the entire sub\sphinxhyphen{}tree. The value \sphinxcode{\sphinxupquote{1}} specifies to search only child bookmarks of the current bookmark. The value \sphinxcode{\sphinxupquote{0}} specifies to look at the current bookmark.

\item {} 
Retrieving a specific bookmark

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{a} \PYG{n}{bookmark} \PYG{n}{whose} \PYG{n}{title} \PYG{o+ow}{is} \PYG{n}{Samples}
\PYG{n}{PDBookmark} \PYG{n}{rootBookmark}\PYG{p}{,} \PYG{n}{myBookmark}\PYG{p}{;}
\PYG{n}{char}\PYG{o}{*} \PYG{n}{bookmarkTitle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Samples}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{root} \PYG{n}{bookmark}
\PYG{n}{rootBookmark} \PYG{o}{=} \PYG{n}{PDDocGetBookmarkRoot}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{a} \PYG{n}{specific} \PYG{n}{bookmark}
\PYG{n}{myBookmark} \PYG{o}{=} \PYG{n}{PDBookmarkGetByTitle} \PYG{p}{(}\PYG{n}{rootBookmark}\PYG{p}{,} \PYG{n}{bookmarkTitle}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{bookmarkTitle}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{PDBookmarkIsValid} \PYG{p}{(}\PYG{n}{myBookmark}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The bookmark was retrieved}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The bookmark was not retrieved}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In the previous code example, a \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} is passed to the \sphinxcode{\sphinxupquote{PDDocGetBookmarkRoot}} method. For information about creating this object, see \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.
\end{sphinxadmonition}


\subsection{Retrieving all bookmarks}
\label{\detokenize{Plugins_Bookmark:retrieving-all-bookmarks}}
You can use the Acrobat core API to retrieve all bookmarks located within a PDF document. For example, you can retrieve the title of every bookmark that is located within a PDF document.

The following code example creates a recursive user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{VisitAllBookmarks}}. First it invokes the \sphinxcode{\sphinxupquote{PDBookmarkIsValid}} method to ensure that the bookmark that is passed is valid (the root bookmark is always valid.)

Second, this user\sphinxhyphen{}defined function retrieves the title of the bookmark by invoking the \sphinxcode{\sphinxupquote{PDBookmarkGetTitle}} method. This method requires the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDBookmark}} object that contains the title to retrieve.

\item {} 
A character pointer that is populated with the bookmarks title.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} object that represents the size of the character pointer.

\end{itemize}

Because the size of the bookmark’s title is unknown, the \sphinxcode{\sphinxupquote{PDBookmarkGetTitle}} is invoked twice. The first time it is invoked, \sphinxcode{\sphinxupquote{NULL}} is passed as the buffer address (second argument) and \sphinxcode{\sphinxupquote{0}} is specified as the buffer size (third argument). The text length is returned to an \sphinxcode{\sphinxupquote{ASInt32}} object named \sphinxcode{\sphinxupquote{bufSize}}. The \sphinxcode{\sphinxupquote{ASmalloc}} method is invoked which allocates \sphinxcode{\sphinxupquote{bufSize}} bytes to the character pointer.

The second time \sphinxcode{\sphinxupquote{PDBookmarkGetTitle}} is invoked, the allocated character pointer is passed as well as the \sphinxcode{\sphinxupquote{ASInt32}} object named \sphinxcode{\sphinxupquote{bufSize}}. The character pointer is populated with the bookmark’s title. The \sphinxcode{\sphinxupquote{AVAlertNote}} method is invoked and the character pointer is passed as an argument that results in the bookmark’s title being displayed within a message box.

The \sphinxcode{\sphinxupquote{PDBookmarkHasChildren}} method is invoked to determine whether there are any child bookmarks under the current bookmark. If there are child bookmarks, the \sphinxcode{\sphinxupquote{PDBookmarkGetFirstChild}} method is invoked to retrieve the first child bookmark. A recursive call is made to \sphinxcode{\sphinxupquote{VisitAllBookmarks}} (that is, the user\sphinxhyphen{}defined method is invoking itself) until there are no more children bookmarks. Then the \sphinxcode{\sphinxupquote{PDBookmarkGetNext}} method is invoked to get a sibling bookmark and the process continues until there are no more bookmarks within the PDF document.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
//Recursively go through bookmark tree to visit each bookmark
void VisitAllBookmarks (PDBookmark aBookmark)
\PYGZob{}
  PDBookmark treeBookmark;
  DURING

//Ensure that the bookmark is valid
 if (!PDBookmarkIsValid(aBookmark))
      E\PYGZus{}RTRN\PYGZus{}VOID

//Get the title of the bookmark
 char * bmBuf;
  ASInt32 bufSize = PDBookmarkGetTitle(aBookmark, NULL, 0) +1;

//Allocate the size of bufSize to the character pointer
 bmBuf = (char*)ASmalloc((os\PYGZus{}size\PYGZus{}t)bufSize);

//Populate bmBuf with the bookmark\PYGZsq{}s title
 PDBookmarkGetTitle(aBookmark, bmBuf, bufSize);


//Display the title of the bookmark within a message box
 AVAlertNote(bmBuf);

//Determine if the current bookmark has children bookmark
 if (PDBookmarkHasChildren (aBookmark))
  \PYGZob{}

//Get the first child of the bookmark
     treeBookmark = PDBookmarkGetFirstChild(aBookmark);
      while (PDBookmarkIsValid (treeBookmark))    \PYGZob{}
      VisitAllBookmarks (treeBookmark);
      treeBookmark = PDBookmarkGetNext(treeBookmark);
      \PYGZcb{}
  \PYGZcb{}
  HANDLER

  END\PYGZus{}HANDLER
\PYGZcb{}
\end{sphinxVerbatim}


\section{Deleting bookmarks}
\label{\detokenize{Plugins_Bookmark:deleting-bookmarks}}
You can use the Acrobat core API to delete an existing bookmark. Deleting a bookmark deletes child bookmarks; however, PDF document content is not affected. To delete a bookmark, you must invoke the \sphinxcode{\sphinxupquote{PDBookmarkDestroy}} method and pass a \sphinxcode{\sphinxupquote{PDBookmark}} object that represents the bookmark to delete. For example, consider the bookmark structure shown in the following diagram.

\noindent\sphinxincludegraphics{{bookmarkDel}.png}

Assume, for example, that you want to delete the bookmark titled Copying Print files. Once you delete this bookmark, the API files and XDC files bookmarks are also deleted. To delete the Copying Print files bookmark, you must create a \sphinxcode{\sphinxupquote{PDBookmark}} object that represents this bookmark and pass this object to the \sphinxcode{\sphinxupquote{PDBookmarkDestroy}} method.

The following code example deletes a bookmark. Included in this code example is application logic that retrieves a specific bookmark. (See \sphinxhref{Plugins\_Bookmark.html\#50618419\_90691}{Retrieving a specific bookmark}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{a} \PYG{n}{bookmark} \PYG{n}{whose} \PYG{n}{title} \PYG{o+ow}{is} \PYG{n}{Samples}
 \PYG{n}{PDBookmark} \PYG{n}{rootBookmark}\PYG{p}{,} \PYG{n}{myBookmark}\PYG{p}{;}
\PYG{n}{char}\PYG{o}{*} \PYG{n}{bookmarkTitle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Copying Print files}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{root} \PYG{n}{bookmark}
\PYG{n}{rootBookmark} \PYG{o}{=} \PYG{n}{PDDocGetBookmarkRoot}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{a} \PYG{n}{specific} \PYG{n}{bookmark}
\PYG{n}{myBookmark} \PYG{o}{=} \PYG{n}{PDBookmarkGetByTitle}\PYG{p}{(}\PYG{n}{rootBookmark}\PYG{p}{,} \PYG{n}{bookmarkTitle}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{bookmarkTitle}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{PDBookmarkIsValid} \PYG{p}{(}\PYG{n}{myBookmark}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The bookmark was retrieved}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The bookmark was not retrieved}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Delete} \PYG{n}{this} \PYG{n}{bookmark}
\PYG{n}{PDBookmarkDestroy}\PYG{p}{(}\PYG{n}{myBookmark}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In the previous code example, a \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} is passed to the \sphinxcode{\sphinxupquote{PDDocGetBookmarkRoot}} method. For information about creating this object, see \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.
\end{sphinxadmonition}


\chapter{Working with Page Views and Contents}
\label{\detokenize{Plugins_Pages:working-with-page-views-and-contents}}\label{\detokenize{Plugins_Pages::doc}}
A page view is the area of the Acrobat or Adobe Reader window that displays the visible content of a document page. An example of a page view is a PDF document page displayed within Adobe Reader or Acrobat at a 120\% magnification.


\section{About page coordinates}
\label{\detokenize{Plugins_Pages:about-page-coordinates}}
When working with page views and page contents, it is often necessary to specify page coordinates. Two coordinate systems are applicable to the Acrobat core API:
\begin{itemize}
\item {} 
User space

\item {} 
Device space

\end{itemize}

User space is the coordinate system used within PDF documents. It specifies coordinates for most objects in the PD layer. (See \sphinxhref{Plugins\_Introduction.html\#50618410\_55631}{Portable Document layer}.)

When working with the user space coordinate system, you use an \sphinxcode{\sphinxupquote{ASFixedRect}} object to represent a rectangle. For example, to place an annotation on a page, create an \sphinxcode{\sphinxupquote{ASFixedRect}} object and specify its coordinates. To specify a \sphinxcode{\sphinxupquote{ASFixedRect}} object’s coordinates, you must define its \sphinxcode{\sphinxupquote{top}}, \sphinxcode{\sphinxupquote{right}}, \sphinxcode{\sphinxupquote{bottom}}, and \sphinxcode{\sphinxupquote{left}} attributes. (See \sphinxhref{Plugins\_Annotations.html\#50618420\_15829}{Creating text annotations}.)

The following diagram shows a user space coordinate system.

\noindent\sphinxincludegraphics{{userspace}.png}

Device space specifies coordinates in screen pixels and is used in the AV layer to specify screen coordinates of windows. In device space, you use an \sphinxcode{\sphinxupquote{AVRect}} object to represent a specific coordinate. The following diagram shows a device space coordinate system.

\noindent\sphinxincludegraphics{{devicespace}.png}

The \sphinxcode{\sphinxupquote{AVPageViewRectToDevice}} method can transform a rectangle’s coordinates from user space to device space. For example, you can use PD methods to determine user space coordinates of a rectangle. However, to display an outline around the rectangle, you must convert user space coordinates to device space coordinates. (See \sphinxhref{Plugins\_Pages.html\#50618407\_23519}{Modifying page contents}.)


\section{About page views}
\label{\detokenize{Plugins_Pages:about-page-views}}
A page view is represented by an \sphinxcode{\sphinxupquote{AVPageView}} object. To create an \sphinxcode{\sphinxupquote{AVPageView}} object, invoke the \sphinxcode{\sphinxupquote{AVDocGetPageView}} method. (See \sphinxhref{Plugins\_Pages.html\#50618407\_52579}{Displaying page views}.)

Using \sphinxcode{\sphinxupquote{AVPageView}} methods, you can perform page\sphinxhyphen{}view tasks such as:
\begin{itemize}
\item {} 
Displaying a page.

\item {} 
Selecting a zoom factor.

\item {} 
Scrolling the displayed page.

\item {} 
Highlighting one or more words.

\item {} 
Controlling screen redrawing.

\item {} 
Traversing the view stack that records where users have been in a document.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
To control the size of the page view, you can invoke the \sphinxcode{\sphinxupquote{AVWindowSetFrame}} and \sphinxcode{\sphinxupquote{AVDocSetSplitterPosition}} methods. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)
\end{sphinxadmonition}


\section{Displaying page views}
\label{\detokenize{Plugins_Pages:displaying-page-views}}
Using the Acrobat core API, you can programmatically display a page view by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an \sphinxcode{\sphinxupquote{AVDoc}} object that represents the PDF document that contains the page on which the page view is based. (See \sphinxhref{Plugins\_Documents.html\#50618416\_65430}{Opening PDF documents}.)

\item {} 
If desired, ensure that the specified page number does not exceed the number of pages located in the document. Convert the \sphinxcode{\sphinxupquote{AVDoc}} object to a \sphinxcode{\sphinxupquote{PDDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVDocGetPDDoc}} method. This method requires an \sphinxcode{\sphinxupquote{AVDoc}} and returns a \sphinxcode{\sphinxupquote{PDDoc}} object. Get the total number of pages located within the document by invoking the \sphinxcode{\sphinxupquote{PDDocGetNumPages}} method. This method requires a \sphinxcode{\sphinxupquote{PDDoc}} object and returns an \sphinxcode{\sphinxupquote{ASInt32}} object representing the number of pages within the document.

\item {} 
Create an \sphinxcode{\sphinxupquote{AVPageView}} object that represents the page view by invoking the \sphinxcode{\sphinxupquote{AVDocGetPageView}} method. This method requires an \sphinxcode{\sphinxupquote{AVDoc}} object and returns an \sphinxcode{\sphinxupquote{AVPageView}} object.

\item {} 
Specify the page view’s page number by invoking the \sphinxcode{\sphinxupquote{AVPageViewGoTo}} method. This method requires an \sphinxcode{\sphinxupquote{AVPageView}} object that represents the page view and an \sphinxcode{\sphinxupquote{ASInt32}} object that specifies the page number. The page number uses a zero\sphinxhyphen{}based index value. Therefore the value of the first page is \sphinxcode{\sphinxupquote{0}}.

\item {} 
Display the page view by invoking the \sphinxcode{\sphinxupquote{AVPageViewDrawNow}} method and passing the \sphinxcode{\sphinxupquote{AVPageView}} object. When you invoke a method that affects a page view, you must invoke this method to redraw the page and display the page view. Otherwise, changes to a page view are not displayed.

\end{enumerate}

The following code example displays a page view that is based on an \sphinxcode{\sphinxupquote{AVDoc}} object named \sphinxcode{\sphinxupquote{myDocument}}. The specified page of the page view is 40 (which displays page 41). For information about creating an \sphinxcode{\sphinxupquote{AVDoc}} object, see \sphinxhref{Plugins\_Documents.html\#50618416\_65430}{Opening PDF documents}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{local} \PYG{n}{variables}
   \PYG{n}{ASInt32} \PYG{n}{totalPages}\PYG{p}{;}
   \PYG{n}{ASInt32} \PYG{n}{pageNum}\PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{;}
   \PYG{n}{AVPageView} \PYG{n}{pageView}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Convert} \PYG{n}{the} \PYG{n}{AVDoc} \PYG{n}{to} \PYG{n}{a} \PYG{n}{PDDoc} \PYG{o+ow}{and} \PYG{n}{get} \PYG{n}{the} \PYG{n}{page} \PYG{n}{count}
   \PYG{n}{PDDoc} \PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{myDocument}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{totalPages}\PYG{o}{=} \PYG{n}{PDDocGetNumPages}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{pageNum} \PYG{o}{\PYGZlt{}} \PYG{n}{totalPages}\PYG{p}{)}\PYG{p}{\PYGZob{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{a} \PYG{n}{AVPageView} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n}{display} \PYG{n}{it}
   \PYG{n}{pageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{myDocument}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVPageViewGoTo}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{,}\PYG{n}{pageNum}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVPageViewDrawNow} \PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Modifying page contents}
\label{\detokenize{Plugins_Pages:modifying-page-contents}}
Pages in a PDF document are represented by a \sphinxcode{\sphinxupquote{PDPage}} object. Pages can contain properties such as annotations, contents, resources, bounding box, media box, crop box, rotation state, and Cos objects. These properties make up the page’s content. \sphinxcode{\sphinxupquote{PDPage}} methods enable you to perform tasks such as retrieving objects such as annotations, adding new objects, removing objects, and modifying existing objects.

To access a \sphinxcode{\sphinxupquote{PDPage}} object, you must obtain the applicable \sphinxcode{\sphinxupquote{PDDoc}} object, either directly or by invoking the \sphinxcode{\sphinxupquote{AVDocGetPDDoc}} method. You can then invoke the \sphinxcode{\sphinxupquote{PDDocAcquirePage}} method to acquire the page (the \sphinxcode{\sphinxupquote{PDPage}} object).

To access the contents of PDF pages, you use \sphinxcode{\sphinxupquote{PD}} layer methods. In addition, the Acrobat core API provides the \sphinxcode{\sphinxupquote{PDFEdit}} typedef, which provides an easy way to access to the contents of a PDF page. \sphinxcode{\sphinxupquote{PDFEdit}} methods are useful when working with page items such as images, paths, graphics, and text objects. This API treats the contents of a page as a list of objects whose values and attributes can be modified.

Each \sphinxcode{\sphinxupquote{PDFEdit}} object encapsulates all the relevant information about itself. A \sphinxcode{\sphinxupquote{PDEText}} object, for example, contains text and its attributes such as font and position on the page. It can access single characters or multiple character strings, but not words. To access words, you need to use \sphinxcode{\sphinxupquote{PD}} layer methods. For information see \sphinxhref{Plugins\_Introduction.html\#50618410\_55631}{Portable Document layer}.


\subsection{Creating a PDEContent object}
\label{\detokenize{Plugins_Pages:creating-a-pdecontent-object}}
A \sphinxcode{\sphinxupquote{PDEContent}} object is a container object that contains modifiable contents of a \sphinxcode{\sphinxupquote{PDPage}} including \sphinxcode{\sphinxupquote{PDEText}}, \sphinxcode{\sphinxupquote{PDEPath}}, and \sphinxcode{\sphinxupquote{PDEImage}} objects. After you create a \sphinxcode{\sphinxupquote{PDEContent}} object, you can access and modify objects that it contains.

Create a \sphinxcode{\sphinxupquote{PDEContent}} object by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an \sphinxcode{\sphinxupquote{AVDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVAppGetActiveDoc}} method. This method gets the frontmost document located within Adobe Reader or Acrobat.

\item {} 
Create an \sphinxcode{\sphinxupquote{AVPageView}} object by invoking the \sphinxcode{\sphinxupquote{AVDocGetPageView}} method. This method requires an \sphinxcode{\sphinxupquote{AVDoc}} object and returns an \sphinxcode{\sphinxupquote{AVPageView}} object.

\item {} 
Get the current page number of the PDF document by invoking the \sphinxcode{\sphinxupquote{AVPageViewGetPageNum}} method. This method requires an \sphinxcode{\sphinxupquote{AVPageView}} object and returns a \sphinxcode{\sphinxupquote{PDPageNumber}} object that represents the current page number.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVDocGetPDDoc}} method. This method requires an \sphinxcode{\sphinxupquote{AVDoc}} object and returns a \sphinxcode{\sphinxupquote{PDDoc}} object.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDPage}} object by invoking the \sphinxcode{\sphinxupquote{PDDocAcquirePage}} method. This method requires a \sphinxcode{\sphinxupquote{PDDoc}} object and a \sphinxcode{\sphinxupquote{PDPageNumber}} object as arguments and returns a \sphinxcode{\sphinxupquote{PDPage}} object.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDEContent}} object by invoking the \sphinxcode{\sphinxupquote{PDPageAcquirePDEContent}} method and passing a \sphinxcode{\sphinxupquote{PDPageNumber}} object and an \sphinxcode{\sphinxupquote{ASExtension}} object that represents the identity of the caller. For plugins, you can use the \sphinxcode{\sphinxupquote{gExtensionID}} extension (this is defined in the PIMain.c file).

\end{enumerate}

The following code example creates a \sphinxcode{\sphinxupquote{PDEContent}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVDoc} \PYG{n}{avDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVPageView} \PYG{n}{pageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPageNumber}
\PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{*} \PYG{n}{Bridge} \PYG{n}{method} \PYG{n}{to} \PYG{n}{PD} \PYG{n}{doc}\PYG{o}{*}\PYG{o}{/}
\PYG{n}{PDDoc} \PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{*} \PYG{n}{Acquire} \PYG{n}{current} \PYG{n}{page} \PYG{o}{*}\PYG{o}{/}
\PYG{n}{PDPage}
\PYG{n}{pdPage} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{pageNum}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDEContent}
\PYG{n}{pdeContent} \PYG{o}{=} \PYG{n}{PDPageAcquirePDEContent}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Accessing page contents}
\label{\detokenize{Plugins_Pages:accessing-page-contents}}
Before you can modify page contents, you must access them by using a \sphinxcode{\sphinxupquote{PDEContent}} object, which is a collection object that stores page contents. Each page content is stored as an element within the \sphinxcode{\sphinxupquote{PDEContent}} object. An element is represented by a \sphinxcode{\sphinxupquote{PDEElement}} object. For example, a \sphinxcode{\sphinxupquote{PDEElement}} object can contain an annotation.

To access page contents, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{PDEContent}} object. (See \sphinxhref{Plugins\_Pages.html\#50618407\_91421}{Creating a PDEContent object}.)

\item {} 
Invoke the \sphinxcode{\sphinxupquote{PDEContentGetNumElems}} method to retrieve the number of elements located within the \sphinxcode{\sphinxupquote{PDEContent}} object. This method requires a \sphinxcode{\sphinxupquote{PDEContent}} object and returns an \sphinxcode{\sphinxupquote{ASInt32}} object that specifies the number of elements.

\item {} 
Iterate through the \sphinxcode{\sphinxupquote{PDEContent}} object and retrieve each element by invoking the \sphinxcode{\sphinxupquote{PDEContentGetElem}} method. This method requires a \sphinxcode{\sphinxupquote{PDEContent}} object and an \sphinxcode{\sphinxupquote{ASInt32}} object that specifies the element index (this is a zero\sphinxhyphen{}based value) and returns a \sphinxcode{\sphinxupquote{PDEElement}} object that represents a specific page property.

\end{enumerate}

The following code example accesses each element located in a \sphinxcode{\sphinxupquote{PDEContent}} object.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Accessing page contents

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{a} \PYG{n}{PDEElement} \PYG{n+nb}{object}
\PYG{n}{PDEElement} \PYG{n}{pdeElement}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{number} \PYG{n}{of} \PYG{n}{elements} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{PDEContent} \PYG{n+nb}{object}
\PYG{n}{ASInt32} \PYG{n}{eleNum} \PYG{o}{=}  \PYG{n}{PDEContentGetNumElems}\PYG{p}{(}\PYG{n}{pdeContent}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{each} \PYG{n}{element} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{PDEContent} \PYG{n+nb}{object}
\PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{n}{eleNum}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}

  \PYG{n}{pdeElement} \PYG{o}{=} \PYG{n}{PDEContentGetElem}\PYG{p}{(}\PYG{n}{pdeContent}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Determining page element types}
\label{\detokenize{Plugins_Pages:determining-page-element-types}}
You can determine the element type that a \sphinxcode{\sphinxupquote{PDEElement}} object represents by invoking the \sphinxcode{\sphinxupquote{PDEObjectGetType}} method. This method requires a \sphinxcode{\sphinxupquote{PDEObject}} ; however, you can pass a \sphinxcode{\sphinxupquote{PDEElement}} object and cast it to a \sphinxcode{\sphinxupquote{PDEObject}}. This method returns an \sphinxcode{\sphinxupquote{ASInt32}} object that specifies the element type. For example, if the element is a text element, this method returns \sphinxcode{\sphinxupquote{kPDEText}}. For a listing of all element types, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

The following code example determines the element type by adding application logic to the application logic introduced in \sphinxhref{Plugins\_Pages.html\#50618407\_26389}{Accessing page contents}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Determining page element types

//Declare a PDEElement object
PDEElement pdeElement;

//Get the number of elements located in the PDEContent object
ASInt32 eleNum =  PDEContentGetNumElems(pdeContent);

//Get each element located within the PDEContent object
for (int j=0; j<eleNum; j++)\{
\begin{quote}

pdeElement = PDEContentGetElem(pdeContent, j);
\end{quote}
\begin{description}
\item[{//Determine if the element is a text element}] \leavevmode
if (PDEObjectGetType((PDEObject)pdeElement) == kPDEText)\{

\end{description}

//Perform an action
\}

\end{enumerate}


\subsection{Modifying text elements}
\label{\detokenize{Plugins_Pages:modifying-text-elements}}
You can modify elements located within a \sphinxcode{\sphinxupquote{PDEContent}} object. This section discusses modifying text elements by placing a red border around them. To place a red border around a text element, you must create a \sphinxcode{\sphinxupquote{PDColorValueRec}} object and define its attributes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDColorValue} \PYG{o+ow}{and} \PYG{n}{define} \PYG{n}{red}
\PYG{n}{PDColorValueRec} \PYG{n}{red}\PYG{p}{;}
 \PYG{n}{red}\PYG{o}{.}\PYG{n}{space} \PYG{o}{=} \PYG{n}{PDDeviceRGB}\PYG{p}{;}
 \PYG{n}{red}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ASInt32ToFixed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{red}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
 \PYG{n}{red}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

After you create a \sphinxcode{\sphinxupquote{PDColorValueRec}} object, you can attach it to an \sphinxcode{\sphinxupquote{AVPageView}} object by invoking the \sphinxcode{\sphinxupquote{AVPageViewSetColor}} method. This method requires an \sphinxcode{\sphinxupquote{AVPageView}} object and a \sphinxcode{\sphinxupquote{PDVColorValueRec}} object. Once set, this color is used in drawing operations.

A text element is represented by a \sphinxcode{\sphinxupquote{PDEText}} object, which is a container of text runs. A text run can be a single character or multiple characters having the same attributes in a PDF file. You can get the number of text runs located within a \sphinxcode{\sphinxupquote{PDEElement}} object by invoking the \sphinxcode{\sphinxupquote{PDETextGetNumRuns}} method and passing the \sphinxcode{\sphinxupquote{PDEElement}} object and casting it as a \sphinxcode{\sphinxupquote{PDEText}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{numRuns} \PYG{o}{=} \PYG{n}{PDETextGetNumRuns}\PYG{p}{(}\PYG{p}{(}\PYG{n}{PDEText}\PYG{p}{)} \PYG{n}{pdeElement}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can draw a red border around each \sphinxcode{\sphinxupquote{PDEText}} object by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Get the bounding box of the \sphinxcode{\sphinxupquote{PDEText}} object by invoking the \sphinxcode{\sphinxupquote{PDETextGetBBox}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDEText}} object that represents the text element whose bounding box is obtained.

\item {} 
A \sphinxcode{\sphinxupquote{PDETextFlags}} value that specifies whether index refers to the character offset from the beginning of the text object or the index of the text run. Must be either \sphinxcode{\sphinxupquote{kPDETextChar}} for a text character or \sphinxcode{\sphinxupquote{kPDETextRun}} for a text run.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that specifies the index of the character or text run.

\item {} 
The address of an \sphinxcode{\sphinxupquote{ASFixedRect}} object that is populated with the coordinates of the bounding box of a specified character or text run.

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Transform the bounding box’s coordinates from user space to device space by invoking the \sphinxcode{\sphinxupquote{AVPageViewRectToDevice}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVPageView}} object that represents the page view for which the coordinates are transformed. Use the same \sphinxcode{\sphinxupquote{AVPageView}} object that was used to create a \sphinxcode{\sphinxupquote{PDEContent}} object. (See \sphinxhref{Plugins\_Pages.html\#50618407\_91421}{Creating a PDEContent object}.)

\item {} 
The address of the \sphinxcode{\sphinxupquote{ASFixedRect}} object that was passed to the \sphinxcode{\sphinxupquote{PDETextGetBBox}} method. This object contains coordinate data that is transformed.

\item {} 
The address of an \sphinxcode{\sphinxupquote{AVRect}} object that is populated with device space coordinates.

\end{itemize}

\item {} 
Draw a stroked, but not filled, rectangle by invoking the \sphinxcode{\sphinxupquote{AVPageViewDrawRectOutline}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVPageView}} object that represents the page view in which the rectangle is drawn.

\item {} 
The address of the \sphinxcode{\sphinxupquote{AVRect}} object that specifies device space coordinates. You can pass the address of the same \sphinxcode{\sphinxupquote{AVRect}} object that was passed to the \sphinxcode{\sphinxupquote{AVPageViewRectToDevice}} method.

\item {} 
An \sphinxcode{\sphinxupquote{AVDevSize}} object that specifies the border width in pixels.

\item {} 
The address of an \sphinxcode{\sphinxupquote{ASFixed}} object whose elements specify the length of dashes and gaps. You can specify \sphinxcode{\sphinxupquote{NULL}} to draw a solid outline.

\item {} 
An \sphinxcode{\sphinxupquote{AVTArraySize}} object that specifies the number of elements in the \sphinxcode{\sphinxupquote{ASFixed}} object. This value is ignored if you specified \sphinxcode{\sphinxupquote{Null}} as the previous argument. As a result, you can specify \sphinxcode{\sphinxupquote{0}} for this argument. The maximum allowed number of elements is currently 10.

\end{itemize}

\end{enumerate}

The following code example modifies page contents by placing a red border around text elements and places a blue border around other elements that are located within a \sphinxcode{\sphinxupquote{PDEContent}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{objects} \PYG{n}{used} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{code} \PYG{n}{example}
   \PYG{n}{PDEElement} \PYG{n}{pdeElement}\PYG{p}{;}
   \PYG{n}{ASFixedRect} \PYG{n}{bbox}\PYG{p}{;}
   \PYG{n}{AVRect} \PYG{n}{rect}\PYG{p}{;}
   \PYG{n}{PDColorValueRec} \PYG{n}{red}\PYG{p}{,} \PYG{n}{blue}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{red}
   \PYG{n}{red}\PYG{o}{.}\PYG{n}{space} \PYG{o}{=} \PYG{n}{PDDeviceRGB}\PYG{p}{;}
   \PYG{n}{red}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ASInt32ToFixed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{red}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{red}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{blue}
   \PYG{n}{blue}\PYG{o}{.}\PYG{n}{space} \PYG{o}{=} \PYG{n}{PDDeviceRGB}\PYG{p}{;}
   \PYG{n}{blue}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{blue}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{blue}\PYG{o}{.}\PYG{n}{value}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ASInt32ToFixed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDEContent} \PYG{n+nb}{object} \PYG{n}{based} \PYG{n}{on} \PYG{n}{the} \PYG{n}{current} \PYG{n}{page} \PYG{n}{view}
   \PYG{n}{AVDoc} \PYG{n}{avDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{AVPageView} \PYG{n}{pageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{PDPageNumber} \PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{PDDoc} \PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{PDPage} \PYG{n}{pdPage} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{pageNum}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{PDEContent} \PYG{n}{pdeContent} \PYG{o}{=} \PYG{n}{PDPageAcquirePDEContent}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{number} \PYG{n}{of} \PYG{n}{elements} \PYG{n}{located} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{PDEContent} \PYG{n+nb}{object}
   \PYG{n}{ASInt32} \PYG{n}{eleNum} \PYG{o}{=} \PYG{n}{PDEContentGetNumElems}\PYG{p}{(}\PYG{n}{pdeContent}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{each} \PYG{n}{element} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{PDEContent} \PYG{n+nb}{object}
   \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int}  \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{eleNum}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{a} \PYG{n}{specific} \PYG{n}{element}
   \PYG{n}{pdeElement} \PYG{o}{=} \PYG{n}{PDEContentGetElem}\PYG{p}{(}\PYG{n}{pdeContent}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Determine} \PYG{k}{if} \PYG{n}{the} \PYG{n+nb}{object} \PYG{o+ow}{is} \PYG{n}{of} \PYG{n+nb}{type} \PYG{n}{text}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{PDEObjectGetType}\PYG{p}{(}\PYG{p}{(}\PYG{n}{PDEObject}\PYG{p}{)} \PYG{n}{pdeElement}\PYG{p}{)} \PYG{o}{==} \PYG{n}{kPDEText}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{number} \PYG{n}{of} \PYG{n}{text} \PYG{n}{runs} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{text} \PYG{n}{element}
      \PYG{n+nb}{int} \PYG{n}{numTextRuns} \PYG{o}{=} \PYG{n}{PDETextGetNumRuns}\PYG{p}{(}\PYG{p}{(}\PYG{n}{PDEText}\PYG{p}{)} \PYG{n}{pdeElement}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Assign} \PYG{n}{red} \PYG{n}{to} \PYG{n}{the} \PYG{n}{page} \PYG{n}{view}
      \PYG{n}{AVPageViewSetColor}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{red}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numTextRuns}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{bounding} \PYG{n}{box} \PYG{n}{of} \PYG{n}{the} \PYG{n}{text} \PYG{n}{run}
      \PYG{n}{PDETextGetBBox} \PYG{p}{(}\PYG{p}{(}\PYG{n}{PDEText}\PYG{p}{)} \PYG{n}{pdeElement}\PYG{p}{,} \PYG{n}{kPDETextRun}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{bbox}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Convert} \PYG{k+kn}{from} \PYG{n+nn}{user} \PYG{n}{space} \PYG{n}{bbox} \PYG{n}{to} \PYG{n}{device} \PYG{n}{space} \PYG{n}{rect}
      \PYG{n}{AVPageViewRectToDevice} \PYG{p}{(}\PYG{n}{pageView}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{bbox}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{rect}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Draw} \PYG{n}{the} \PYG{n}{rect}
      \PYG{n}{AVPageViewDrawRectOutline} \PYG{p}{(}\PYG{n}{pageView}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{rect}\PYG{p}{,}  \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{else}
   \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Assign} \PYG{n}{blue} \PYG{n}{to} \PYG{n}{the} \PYG{n}{page} \PYG{n}{view}
      \PYG{n}{AVPageViewSetColor}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{blue}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{bounding} \PYG{n}{box} \PYG{n}{of} \PYG{n}{the} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{text} \PYG{n}{element}
      \PYG{n}{PDEElementGetBBox} \PYG{p}{(}\PYG{n}{pdeElement}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{bbox}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Convert} \PYG{k+kn}{from} \PYG{n+nn}{user} \PYG{n}{space} \PYG{n}{bbox} \PYG{n}{to} \PYG{n}{device} \PYG{n}{space} \PYG{n}{rect}
      \PYG{n}{AVPageViewRectToDevice} \PYG{p}{(}\PYG{n}{pageView}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{bbox}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{rect}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Draw} \PYG{n}{the} \PYG{n}{rect}
      \PYG{n}{AVPageViewDrawRectOutline} \PYG{p}{(}\PYG{n}{pageView}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{rect}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Release} \PYG{n}{objects}
   \PYG{n}{PDPageRelease}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{PDPageReleasePDEContent} \PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{n}{gExtensionID}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Working with Words}
\label{\detokenize{Plugins_Words:working-with-words}}\label{\detokenize{Plugins_Words::doc}}
You can use the Acrobat core API to search for words, extract and display words, and highlight words. Using the Acrobat core API, you can, for example, create application logic that extracts words from a PDF document and places each word in a repository.


\section{About searching for words}
\label{\detokenize{Plugins_Words:about-searching-for-words}}
The Acrobat core API provides typedefs and methods for working with words. Two primary typedefs that you will use when working with words located in a PDF document are \sphinxcode{\sphinxupquote{PDWord}} and \sphinxcode{\sphinxupquote{PDWordFinder}}. The following are two word\sphinxhyphen{}finding indicators:
\begin{itemize}
\item {} 
Presence of non\sphinxhyphen{}alphanumeric characters such as dashes.

\item {} 
Offsets between characters. (While character offsets are well\sphinxhyphen{}defined quantities in a PDF file, word numbers are calculated by the Acrobat or Adobe Reader word finder algorithm).

\end{itemize}


\subsection{About PDWord typedefs}
\label{\detokenize{Plugins_Words:about-pdword-typedefs}}
A \sphinxcode{\sphinxupquote{PDWord}} object represents a word in a PDF file. Each word contains a sequence of characters in one or more styles. All characters in a word are not necessarily physically adjacent. For example, words can be hyphenated across line breaks on a page.

Each character in a word has a character type. Character types include: control code, lowercase letter, uppercase letter, digit, punctuation mark, hyphen, soft hyphen, ligature, white space, comma, period, unmapped glyph, end\sphinxhyphen{}of\sphinxhyphen{}phrase glyph, wildcard, word break, and glyphs that cannot be represented in the destination font encoding. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

The \sphinxcode{\sphinxupquote{PDWordGetCharacterTypes}} method can get the character type for each character in a word. The \sphinxcode{\sphinxupquote{PDWordGetAttr}} method returns a mask containing information on the types of characters in a word. The mask is the logical OR of several flags, including the following:
\begin{itemize}
\item {} 
One or more characters in the word cannot be represented in the output encoding.

\item {} 
One or more characters in the word are punctuation marks.

\item {} 
The first character in the word is a punctuation mark.

\item {} 
The last character in the word is a punctuation mark.

\item {} 
The word contains a ligature (a special typographic symbol consisting of two or more characters such as the English ligature used to replace the two\sphinxhyphen{}character sequence, f followed by i). Ligatures are used to improve the appearance of a word.

\item {} 
One or more characters in the word are digits.

\item {} 
There is a hyphen in the word.

\item {} 
There is a soft hyphen in the word.

\end{itemize}

A word’s location is specified by the offset of its first character from the beginning of the page (known as the character offset). The characters are enumerated in the order in which they appear in page’s content stream in the PDF file (which is not necessarily the order in which the characters are read when displayed or printed).

A word also has a character delta, which is the difference between the number of characters representing the word in the PDF file and the number of characters in the word. The character delta is non\sphinxhyphen{}zero, for example, when a word contains a ligature.


\subsection{About PDWordFinder typedefs}
\label{\detokenize{Plugins_Words:about-pdwordfinder-typedefs}}
A \sphinxcode{\sphinxupquote{PDWordFinder}} extracts words from a PDF file, and enumerates the words on a single page or on all pages in a document. The Acrobat core API provides methods to extract words from a document, obtain information on the word finder, and to release a list of words.

Two primary methods of working with word finders are:
\begin{itemize}
\item {} 
Invoking the \sphinxcode{\sphinxupquote{PDWordFinderEnumWords}} method, which invokes a user\sphinxhyphen{}defined callback function each time a word is recognized on a page. (See \sphinxhref{Plugins\_Words.html\#50618422\_65675}{Extracting and displaying words}.)

\item {} 
Using \sphinxcode{\sphinxupquote{PDWordFinderAcquireWordList}}, which builds a word list for an entire page before it returns. This method can return the recognized words in two possible orders:
\begin{itemize}
\item {} 
The order in which the words are encountered in the PDF file.

\item {} 
According to word location on the page. For a page containing a single column of text, this generally is the same as reading order. For a page containing multiple columns of text, this is not true.

\end{itemize}

\end{itemize}


\section{Creating a PDWordFinder object}
\label{\detokenize{Plugins_Words:creating-a-pdwordfinder-object}}
To perform word operations, such as extracting and displaying words located in a PDF document, you must create a \sphinxcode{\sphinxupquote{PDWordFinder}} object. You can create a \sphinxcode{\sphinxupquote{PDWordFinder}} object by getting the active document (the frontmost document in Acrobat or Adobe Reader).

Optionally, you can create a \sphinxcode{\sphinxupquote{PDWordFinderConfigRec}} object when creating a \sphinxcode{\sphinxupquote{PDWordFinder}} object. A \sphinxcode{\sphinxupquote{PDWordFinderConfigRec}} object enables you to customize how text is extracted. After you create an \sphinxcode{\sphinxupquote{PDWordFinderConfigRec}} object, allocate its buffer size and set the following attributes:
\begin{itemize}
\item {} 
\sphinxstylestrong{recsize}: The size of the data structure. This attribute must be set to \sphinxcode{\sphinxupquote{sizeof(PDWordFinderConfigRec)}}.

\item {} 
\sphinxstylestrong{ignoreCharGaps}: If \sphinxcode{\sphinxupquote{true}}, this attribute disables the conversion of large character gaps to space characters, so that the word finder reports a character space only when a space character appears in the PDF content.

\item {} 
\sphinxstylestrong{ignoreLineGaps}: If true, this attribute disables the handling of vertical movements as line breaks, so that the word finder determines a line break only when a line break character or special tag information appears in the PDF content.

\item {} 
\sphinxstylestrong{noAnnots}: If true, this attribute disables the extraction of text from text annotations. Normally, the word finder extracts text from the normal appearances of text annotations that are inside the page crop box.

\item {} 
\sphinxstylestrong{noEncodingGuess}: If true, disables the guessing of the encoding of fonts that have unknown or custom encoding, when there is no ToUnicode table. Inappropriate encoding conversions can cause the word finder to mistakenly recognize non\sphinxhyphen{}Roman single\sphinxhyphen{}byte fonts as Standard Roman encoding fonts and extract the text in an unusable format. When this option is selected, the word finder avoids such unreliable encoding conversions and tries to provide the original characters without any encoding conversion for a client with its own encoding handling.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
For a complete list of attributes that belong to a \sphinxcode{\sphinxupquote{PDWordFinderConfigRec}} object, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.
\end{sphinxadmonition}

Create a \sphinxcode{\sphinxupquote{PDWordFinder}} object that is based on an active document by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an \sphinxcode{\sphinxupquote{AVDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVAppGetActiveDoc}} method. (See \sphinxhref{Plugins\_Documents.html\#50618416\_65430}{Opening PDF documents}.)

\item {} 
Create a \sphinxcode{\sphinxupquote{PDDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVDocGetPDDoc}} method and passing the \sphinxcode{\sphinxupquote{AVDoc}} object.

\item {} 
If desired, create a \sphinxcode{\sphinxupquote{PDWordFinderConfigRec}} object. If you do not create a \sphinxcode{\sphinxupquote{PDWordFinderConfigRec}} object, then default configuration is used. That is, all attributes that belong to an \sphinxcode{\sphinxupquote{PDWordFinderConfigRec}} object are false.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDWordFinder}} object by invoking the \sphinxcode{\sphinxupquote{PDDocCreateWordFinderEx}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} that represents the PDF document for which the word finder is applicable.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt16}} value that specifies the version of the word\sphinxhyphen{}finding algorithm to use. You can specify \sphinxcode{\sphinxupquote{WF\_LATEST\_VERSION}} to use the latest version. For information about other values for this argument, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether to return Unicode. When \sphinxcode{\sphinxupquote{true}}, the word finder encodes the extracted text in Unicode format. Otherwise, the word\sphinxhyphen{}finding algorithm extracts the text in the host encoding format.

\item {} 
The address of the \sphinxcode{\sphinxupquote{PDWordFinderConfigRec}} object to use. You can pass \sphinxcode{\sphinxupquote{NULL}}, which results in the default configuration being used.

\end{itemize}

\end{enumerate}

The following code example creates a \sphinxcode{\sphinxupquote{PDWordFinder}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{current} \PYG{n}{PDF} \PYG{n}{document}
\PYG{n}{AVDoc} \PYG{n}{currentAVDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{currentPDDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{currentAVDoc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDWordFinderConfigRec} \PYG{n+nb}{object}\PYG{p}{;}
\PYG{n}{PDWordFinderConfigRec} \PYG{n}{pConfig}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n}{DWordFinderConfigRec} \PYG{n+nb}{object}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s attributes}
\PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pConfig}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{PDWordFinderConfigRec}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{recSize} \PYG{o}{=} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{PDWordFinderConfigRec}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{ignoreCharGaps} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{ignoreLineGaps} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{noAnnots} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{noEncodingGuess} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDWordFinder} \PYG{n+nb}{object}
\PYG{n}{PDWordFinder} \PYG{n}{pdWordFinder} \PYG{o}{=} \PYG{n}{PDDocCreateWordFinderEx}\PYG{p}{(}\PYG{n}{currentPDDoc}\PYG{p}{,} \PYG{n}{WF\PYGZus{}LATEST\PYGZus{}VERSION}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pConfig}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Extracting and displaying words}
\label{\detokenize{Plugins_Words:extracting-and-displaying-words}}
You can use a \sphinxcode{\sphinxupquote{PDWordFinder}} object to extract and display all words that are located either in the entire document or the current page by creating a callback function that is invoked for each word found. To create a callback function that is invoked when a word is found, declare a \sphinxcode{\sphinxupquote{PDWordProc}} object that represents the callback:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDWordProc} \PYG{n}{wordProc}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{PDWordProc}} is a callback that is invoked when a word is located. After you create a \sphinxcode{\sphinxupquote{PDWordProc}} object, you can invoke the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro to convert a user\sphinxhyphen{}defined function to an Acrobat callback. For example, you can invoke \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} to convert a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{wordEnumerator}} to a callback function. The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro requires the following arguments:
\begin{itemize}
\item {} 
The callback type. In this situation, specify \sphinxcode{\sphinxupquote{PDWordProc}}.

\item {} 
The address of the user\sphinxhyphen{}defined function to convert to a callback function.

\end{itemize}

The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro returns a callback of the specified type that invokes the user\sphinxhyphen{}defined function whose address was passed as the second argument. The following lines of code shows the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro converting the \sphinxcode{\sphinxupquote{wordEnumerator}} user\sphinxhyphen{}defined function to a \sphinxcode{\sphinxupquote{PDWordProc}} callback.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{PDWordProc} \PYG{n}{wordProc}\PYG{p}{;}
  \PYG{n}{wordProc}\PYG{o}{=} \PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{PDWordProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{wordEnumerator}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

After you create a callback function, invoke the \sphinxcode{\sphinxupquote{PDWordFinderEnumWords}} method to extract all words from the specified page and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDWordFinder}} object that is responsible for finding and extracting words.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that represents the page number from which to extract words.

\item {} 
A \sphinxcode{\sphinxupquote{PDWordProc}} object that represents the callback function to invoke when a word is located.

\item {} 
A pointer to user\sphinxhyphen{}supplied data to pass to the callback function. Pass \sphinxcode{\sphinxupquote{NULL}} if you do not want to pass user\sphinxhyphen{}supplied data.

\end{itemize}

To illustrate how to display words that are located on a page, this section contains a code example that creates a callback function named \sphinxcode{\sphinxupquote{wordEnumerator}} that performs the following tasks:
\begin{itemize}
\item {} 
Removes punctuation characters from the word by invoking the \sphinxcode{\sphinxupquote{PDWordFilterWord}} method. The encoding information passed to the \sphinxcode{\sphinxupquote{PDDocCreateWordFinderEx}} method determines which characters are removed.

\item {} 
Invokes the \sphinxcode{\sphinxupquote{PDWordGetString}} method to get the word as a string.

\item {} 
Displays the string in an alert box by invoking the \sphinxcode{\sphinxupquote{AVAlertConfirm}} method. If the user clicks OK, the next word is displayed until all words for the document page have been displayed. If the user clicks Cancel, this callback function returns \sphinxcode{\sphinxupquote{false}}.

\end{itemize}

The following code example extracts and displays all words that are located on the current PDF document page. Included in this code example is application logic that creates a \sphinxcode{\sphinxupquote{PDWordFinder}} object. (See \sphinxhref{Plugins\_Words.html\#50618422\_28279}{Creating a PDWordFinder object}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{DisplayWords}\PYG{p}{(}\PYG{n}{void} \PYG{o}{*}\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{current} \PYG{n}{PDF} \PYG{n}{document} \PYG{n}{page} \PYG{n}{number}
\PYG{n}{AVDoc} \PYG{n}{currentAVDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{currentPDDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{currentAVDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVPageView} \PYG{n}{currentPageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView} \PYG{p}{(}\PYG{n}{currentAVDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{currentPageView}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDWordFinderConfigRec} \PYG{n+nb}{object}\PYG{p}{;}
\PYG{n}{PDWordFinderConfigRec} \PYG{n}{pConfig}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n}{DWordFinderConfigRec} \PYG{n+nb}{object}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s attributes}
\PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pConfig}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{PDWordFinderConfigRec}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{recSize} \PYG{o}{=} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{PDWordFinderConfigRec}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{ignoreCharGaps} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{ignoreLineGaps} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{noAnnots} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{pConfig}\PYG{o}{.}\PYG{n}{noEncodingGuess} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDWordFinder} \PYG{n+nb}{object}
\PYG{n}{PDWordFinder} \PYG{n}{pdWordFinder} \PYG{o}{=} \PYG{n}{PDDocCreateWordFinderEx}\PYG{p}{(}\PYG{n}{currentPDDoc}\PYG{p}{,} \PYG{n}{WF\PYGZus{}LATEST\PYGZus{}VERSION}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pConfig}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{callback} \PYG{n}{function}
\PYG{n}{PDWordProc} \PYG{n}{wordProc} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{wordProc}\PYG{o}{=} \PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{PDWordProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{wordEnumerator}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Extract} \PYG{o+ow}{and} \PYG{n}{display} \PYG{n}{words}
\PYG{n}{PDWordFinderEnumWords}\PYG{p}{(}\PYG{n}{pdWordFinder}\PYG{p}{,} \PYG{n}{pageNum}\PYG{p}{,} \PYG{n}{wordProc}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDWordFinderDestroy}\PYG{p}{(}\PYG{n}{pdWordFinder}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{wordEnumerator}\PYG{p}{(}\PYG{n}{PDWordFinder} \PYG{n}{wObj}\PYG{p}{,} \PYG{n}{PDWord} \PYG{n}{wInfo}\PYG{p}{,} \PYG{n}{ASInt32} \PYG{n}{pgNum}\PYG{p}{,} \PYG{n}{void} \PYG{o}{*}\PYG{n}{clientData}\PYG{p}{)}

\PYG{p}{\PYGZob{}}
\PYG{n}{char} \PYG{n}{stringBuffer}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{ASInt16} \PYG{n}{wordLength}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Remove} \PYG{n}{punctuation}
\PYG{n}{PDWordFilterWord}\PYG{p}{(}\PYG{n}{wInfo}\PYG{p}{,} \PYG{n}{stringBuffer}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{wordLength}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{stringBuffer}\PYG{p}{[}\PYG{n}{wordLength}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Populate} \PYG{n}{the} \PYG{n}{char} \PYG{n}{array} \PYG{k}{with} \PYG{n}{text} \PYG{n}{that} \PYG{n}{represents} \PYG{n}{the} \PYG{n}{word}
\PYG{n}{PDWordGetString} \PYG{p}{(}\PYG{n}{wInfo}\PYG{p}{,} \PYG{n}{stringBuffer}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{return} \PYG{n}{AVAlertConfirm}\PYG{p}{(}\PYG{n}{stringBuffer}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In the previous code example, assume that the \sphinxcode{\sphinxupquote{DisplayWords}} function was invoked from a menu item. (See \sphinxhref{Plugins\_Menu.html\#50618409\_98126}{Creating Menus and Menu Commands}.)
\end{sphinxadmonition}

\begin{sphinxadmonition}{caution}{Caution:}
If you pass \sphinxcode{\sphinxupquote{true}} as the \sphinxcode{\sphinxupquote{PDDocCreateWordFinderEx}} method’s third argument, then the word finder encodes the extracted text in Unicode format. As a result, words will not be displayed within the alert box. Notice in this code example, the value \sphinxcode{\sphinxupquote{false}} is passed as the \sphinxcode{\sphinxupquote{PDDocCreateWordFinderEx}} method’s third argument.
\end{sphinxadmonition}


\section{Highlighting words}
\label{\detokenize{Plugins_Words:highlighting-words}}
You can use the Acrobat core API to highlight a word or a group of words located within a PDF document. By highlighting a word, you can make a specific word or group of words stand out. The following illustration shows the word \sphinxstyleemphasis{Adobe} highlighted.

\noindent\sphinxincludegraphics{{highlight}.png}

To highlight a word you must create a \sphinxcode{\sphinxupquote{HiliteEntry}} object and set its \sphinxcode{\sphinxupquote{offset}} and length \sphinxcode{\sphinxupquote{attributes}}. The \sphinxcode{\sphinxupquote{offset}} attribute specifies the location of the word from the beginning of the document. For example, if you specify 1, then the second word in the document is highlighted (this value is a 0\sphinxhyphen{}based index). The \sphinxcode{\sphinxupquote{length}} attribute specifies the number of words that are highlighted. If you specify 1, then a single word is highlighted.

You can highlight a word that is located in the current page by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{HiliteEntry}} object and set its \sphinxcode{\sphinxupquote{offset}} and length \sphinxcode{\sphinxupquote{attributes}}.

\item {} 
Create an \sphinxcode{\sphinxupquote{AVDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVAppGetActiveDoc}} method. (See \sphinxhref{Plugins\_Documents.html\#50618416\_65430}{Opening PDF documents}.)

\item {} 
Create a \sphinxcode{\sphinxupquote{PDDoc}} object by invoking the \sphinxcode{\sphinxupquote{AVDocGetPDDoc}} method and passing the \sphinxcode{\sphinxupquote{AVDoc}} object.

\item {} 
Get the page view by invoking the \sphinxcode{\sphinxupquote{AVDocGetPageView}} method and passing the \sphinxcode{\sphinxupquote{AVDoc}} object. This method returns an \sphinxcode{\sphinxupquote{AVPageView}} object. (See \sphinxhref{Plugins\_Pages.html\#50618407\_52579}{Displaying page views}.)

\item {} 
Get the current page number by invoking the \sphinxcode{\sphinxupquote{AVPageViewGetPageNum}} method and passing the \sphinxcode{\sphinxupquote{AVPageView}} object. This method returns the page number of the current page view, which is required to highlight a word or group of words.

\item {} 
Create a \sphinxcode{\sphinxupquote{PDPage}} object by invoking the \sphinxcode{\sphinxupquote{PDDocAcquirePage}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} object.

\item {} 
The page number of the current page view.

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{PDDocAcquirePage}} method returns a \sphinxcode{\sphinxupquote{PDPage}} object.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Highlight a word or group of words by invoking the \sphinxcode{\sphinxupquote{PDTextSelectCreateWordHilite}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDPage}} object that represents the page that will contain the highlighted word(s).

\item {} 
The address of the \sphinxcode{\sphinxupquote{HiliteEntry}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that specifies the number of highlight entries.

\end{itemize}

\end{enumerate}

This method returns a \sphinxcode{\sphinxupquote{PDTextSelect}} object.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Set the PDF document’s text selection type by invoking the \sphinxcode{\sphinxupquote{AVDocSetSelection}} method. This method does not have a return value and requires the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVDoc}} object that represents the PDF document in which the highlighted words appear.

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that specifies the selection type. Because words are highlighted, you can specify \sphinxcode{\sphinxupquote{text}}.

\item {} 
A \sphinxcode{\sphinxupquote{PDTextSelect}} object that represents the text selection. Cast the \sphinxcode{\sphinxupquote{PDTextSelect}} object as a void pointer.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether to highlight the selection. Pass the value \sphinxcode{\sphinxupquote{true}} to highlight the specified word(s).

\end{itemize}

\item {} 
Display the current selection by invoking the \sphinxcode{\sphinxupquote{AVDocShowSelection}} method and passing the \sphinxcode{\sphinxupquote{AVDoc}} that represents the PDF document that contains the highlighted word(s).

\item {} 
Release the \sphinxcode{\sphinxupquote{PDPage}} object by invoking the \sphinxcode{\sphinxupquote{PDPageRelease}} method and passing the \sphinxcode{\sphinxupquote{PDPage}} object.

\end{enumerate}

The following code example highlights the tenth word that is located in the page of the current PDF document.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{HiliteEntry} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n+nb}{set} \PYG{n}{its} \PYG{n}{attributes}
\PYG{n}{HiliteEntry} \PYG{n}{hilite}\PYG{p}{;}
\PYG{n}{hilite}\PYG{o}{.}\PYG{n}{offset} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{n}{hilite}\PYG{o}{.}\PYG{n}{length} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{page} \PYG{n}{number} \PYG{n}{of} \PYG{n}{the} \PYG{n}{current} \PYG{n}{page} \PYG{n}{view}
\PYG{n}{AVDoc} \PYG{n}{currentAVDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{currentPDDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{currentAVDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVPageView} \PYG{n}{currentPageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{currentAVDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{currentPageView}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Highlight} \PYG{n}{the} \PYG{n}{tenth} \PYG{n}{word}
\PYG{n}{PDPage} \PYG{n}{pdPage} \PYG{o}{=} \PYG{n}{PDDocAcquirePage} \PYG{p}{(}\PYG{n}{currentPDDoc}\PYG{p}{,} \PYG{n}{pageNum}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDTextSelect} \PYG{n}{textSelection} \PYG{o}{=} \PYG{n}{PDTextSelectCreateWordHilite}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,}

\PYG{o}{\PYGZam{}}\PYG{n}{hilite}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVDocSetSelection}\PYG{p}{(}\PYG{n}{currentAVDoc}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}

\PYG{p}{(}\PYG{n}{void} \PYG{o}{*}\PYG{p}{)}\PYG{n}{textSelection}\PYG{p}{,} \PYG{n}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVDocShowSelection} \PYG{p}{(}\PYG{n}{currentAVDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPageRelease} \PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Creating Handlers}
\label{\detokenize{Plugins_Handlers:creating-handlers}}\label{\detokenize{Plugins_Handlers::doc}}
Adobe Reader and Acrobat plugins and PDF Library applications can add new types of tools, annotations, actions, file systems, and so on, thereby expanding the number of supported object types. To accomplish this task, the Acrobat core API provides a collection of callback routines called handlers that support objects. Handlers perform operations, such as creating and destroy objects, handling mouse clicks, handling keyboard events, and so on.


\section{About handlers}
\label{\detokenize{Plugins_Handlers:about-handlers}}
To add a new handler, you must write callback functions, create the appropriate data structure containing the callbacks and other data, and pass the structure to Acrobat by invoking the appropriate method. Subsequently, Acrobat automatically invokes the correct callback when it encounters an object of the type handled by the handler.

It is possible to subclass existing handlers or to create entirely new handler types. For example, a plugin can subclass the built\sphinxhyphen{}in text annotation handler by adding the ability to hide annotations. To accomplish this task, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Obtain the built\sphinxhyphen{}in text annotation handler structure by invoke the \sphinxcode{\sphinxupquote{AVAppGetAnnotHandlerByName}} method.

\item {} 
Copy the structure before modifying it (not modifying the original).

\item {} 
Replace the handler’s \sphinxcode{\sphinxupquote{Draw}} callback with one that invokes the built\sphinxhyphen{}in \sphinxcode{\sphinxupquote{Draw}} callback (obtained from the structure) if annotations are visible, or simply return without drawing anything if annotations are hidden.

\item {} 
Register the new handler by invoking the \sphinxcode{\sphinxupquote{AVAppRegisterAnnotHandler}} method with a new type.

\end{enumerate}

If a handler requires more data than provided in the predefined structures that are described in this section, you can append additional data to the predefined structures. To do this, create a new structure type with the predefined structure as its first member and the additional data as subsequent members. Before passing the expanded structure to an Acrobat method, cast the structure to the predefined structure type. Upon return of the structure from Acrobat, re\sphinxhyphen{}cast the structure to its expanded type to access the appended data.

Each handler data structure contains a size field, which specifies the structure’s size. This field provides future compatibility. Different versions of the structure have different sizes, allowing Acrobat to determine which version your plugin was written to use.

\begin{sphinxadmonition}{note}{Note:}
Regardless of whether your plugin adds data to the predefined structures, it must pass the size of the predefined structure (rather than the size of its expanded structure) in the size field.
\end{sphinxadmonition}


\section{Action handlers}
\label{\detokenize{Plugins_Handlers:action-handlers}}
Support for action types can be added by defining and registering an action handler. For example, the Acrobat Weblink plugin uses this ability to add support for URL links.

To add a new action type, you must provide a set of callbacks. Specify them in the \sphinxcode{\sphinxupquote{AVActionHandlerProcs}} structure, and invoke the \sphinxcode{\sphinxupquote{AVAppRegisterActionHandler}} method to register them.

By using an action handler, you can perform the following tasks:
\begin{itemize}
\item {} 
Perform an action, such as setting a specific view, by invoking the \sphinxcode{\sphinxupquote{AVActionPerformProc}} method.

\item {} 
Allow the user to set the action’s properties (if the properties can be set) by invoking the \sphinxcode{\sphinxupquote{AVActionDoPropertiesProc}} method.

\item {} 
Initialize an action’s dictionary with default values by invoking the \sphinxcode{\sphinxupquote{AVActionFillActionDictProc}} method.

\item {} 
Display a string containing brief instructions for the action by invoking the \sphinxcode{\sphinxupquote{AVActionGetInstructionsProc}} method.

\item {} 
Display various text strings to be used in dialog boxes by invoking one of the following methods: \sphinxcode{\sphinxupquote{AVActionGetButtonTextProc}}, \sphinxcode{\sphinxupquote{AVActionGetStringOneTextProc}}, or \sphinxcode{\sphinxupquote{AVActionGetStringTwoTextProc}}.

\item {} 
Copy the action by invoking the \sphinxcode{\sphinxupquote{AVActionCopyProc}} method.

\end{itemize}


\section{Annotation handlers}
\label{\detokenize{Plugins_Handlers:annotation-handlers}}
Support for annotation types in Acrobat can be added by defining and registering an annotation handler. For example, the Acrobat movie plugin uses an annotation handler to support video annotations.

To add an annotation type, you must provide a set of callbacks, specify them in the \sphinxcode{\sphinxupquote{AVAnnotHandler}} structure, and register them with \sphinxcode{\sphinxupquote{AVAppRegisterAnnotHandler}}.

By using an annotation handler, you can perform the following tasks:
\begin{itemize}
\item {} 
Draw the annotation by using the \sphinxcode{\sphinxupquote{AVAnnotHandlerDrawProc}} callback method.

\item {} 
Handle mouse clicks in the annotation by using the \sphinxcode{\sphinxupquote{AVAnnotHandlerDoClickProc}} callback method.

\item {} 
Control the cursor shape when the cursor is over the annotation by using the \sphinxcode{\sphinxupquote{AVAnnotHandlerAdjustCursorProc}} callback method.

\item {} 
Determine whether or not a specified point is within the annotation boundary by using the \sphinxcode{\sphinxupquote{AVAnnotHandlerPtInAnnotViewBBoxProc}} callback method.

\item {} 
Return the rectangle bounding that the annotation occupies by using the \sphinxcode{\sphinxupquote{AVAnnotHandlerGetAnnotViewBBoxProc}} callback method.

\item {} 
Highlight (unhighlight) the annotation when it is added to (removed from) the selection by using the following callback methods: \sphinxcode{\sphinxupquote{AVAnnotHandlerNotifyAnnotAddedToSelectionProc}} or \sphinxcode{\sphinxupquote{AVAnnotHandlerNotifyAnnotRemovedFromSelectionProc}}.

\item {} 
Return the annotation’s subtype by using the \sphinxcode{\sphinxupquote{AVAnnotHandlerGetTypeProc}} callback method.

\item {} 
Get the annotation’s layer by using the \sphinxcode{\sphinxupquote{AVAnnotHandlerGetLayerProc}} callback method.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
For information about working with annotations, see \sphinxhref{Plugins\_Annotations.html\#50618420\_98126}{Creating Annotations}.
\end{sphinxadmonition}


\section{AVCommand handlers}
\label{\detokenize{Plugins_Handlers:avcommand-handlers}}
An \sphinxcode{\sphinxupquote{AVCommand}} represents an action that a user can perform on the current document or the current selection in the current document. \sphinxcode{\sphinxupquote{AVCommands}} are exposed to Adobe Reader or Acrobat through \sphinxcode{\sphinxupquote{AVCommand}} handlers. You can add new command types by defining and registering an \sphinxcode{\sphinxupquote{AVCommand}} handler. Commands can be executed interactively, programmatically, or through batch processing.


\subsection{Creating an AVCommand handler}
\label{\detokenize{Plugins_Handlers:creating-an-avcommand-handler}}
\sphinxcode{\sphinxupquote{AVCommand}} handlers consist of a series of callback functions contained in the \sphinxcode{\sphinxupquote{AVCommandHandlerRec}} structure (see AVExpt.h). To create a command handler, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Initialize an instance of the \sphinxcode{\sphinxupquote{AVCommandHandlerRec}} structure.

\item {} 
Register the \sphinxcode{\sphinxupquote{AVCommandHandlerRec}} structure by invoking the \sphinxcode{\sphinxupquote{AVAppRegisterCommandHandler}} method.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{AVCommandHandlerRec} \PYG{n}{gAVCmdHandler}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{kCmdName} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MinimalCommand}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

\PYG{n}{static} \PYG{n}{ACCB1} \PYG{n}{AVCommandStatus} \PYG{n}{ACCB2} \PYG{n}{DoWorkImpl} \PYG{p}{(}\PYG{n}{AVCommand} \PYG{n}{cmd}\PYG{p}{)}

\PYG{p}{\PYGZob{}}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The DoWorkImpl method was invoked}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{kAVCommandDone}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{void} \PYG{n}{InitializeCommandHandler}\PYG{p}{(}\PYG{p}{)}

\PYG{p}{\PYGZob{}}
  \PYG{n}{memset} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{gAVCmdHandler}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{AVCommandHandlerRec}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{gAVCmdHandler}\PYG{o}{.}\PYG{n}{size} \PYG{o}{=} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{AVCommandHandlerRec}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{gAVCmdHandler}\PYG{o}{.}\PYG{n}{Work} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto} \PYG{p}{(}\PYG{n}{AVCommandWorkProc}\PYG{p}{,}
  \PYG{o}{\PYGZam{}}\PYG{n}{DoWorkImpl}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{AVAppRegisterCommandHandler} \PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{n}{kCmdName}\PYG{p}{)}\PYG{p}{,}
  \PYG{o}{\PYGZam{}}\PYG{n}{gAVCmdHandler}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
To view a complete example, see \sphinxhref{Plugins\_Handlers.html\#50618413\_55225}{Running commands}.
\end{sphinxadmonition}


\subsection{Invoking AVCommands}
\label{\detokenize{Plugins_Handlers:invoking-avcommands}}
To programmatically invoke \sphinxcode{\sphinxupquote{AVCommands}} using \sphinxcode{\sphinxupquote{AVCommand}} methods, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Instantiate the command by invoking the \sphinxcode{\sphinxupquote{AVCommandNew}} method, providing the registered name of the command:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASAtom} \PYG{n}{cmdName}\PYG{p}{;}
 \PYG{n}{AVCommand} \PYG{n}{cmd}\PYG{p}{;}
 \PYG{n}{cmdName} \PYG{o}{=} \PYG{n}{ASAtomFromString} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MinimalCommand}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{cmd} \PYG{o}{=} \PYG{n}{AVCommandNew}\PYG{p}{(}\PYG{n}{cmdName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Configure the command by setting required and optional parameters.

\item {} 
Run the command by invoking the \sphinxcode{\sphinxupquote{AVCommandExecute}} or \sphinxcode{\sphinxupquote{AVCommandWork}} method.

\end{enumerate}


\subsection{Configuring AVCommands}
\label{\detokenize{Plugins_Handlers:configuring-avcommands}}
Prior to executing an \sphinxcode{\sphinxupquote{AVCommand}}, you configure three categories of properties:
\begin{itemize}
\item {} 
Input parameters (required)

\item {} 
Configuration parameters (optional \sphinxhyphen{} initialized to defaults)

\item {} 
AVCommand parameters (optional \sphinxhyphen{} initialized to defaults)

\end{itemize}


\subsubsection{Setting input parameters}
\label{\detokenize{Plugins_Handlers:setting-input-parameters}}
At minimum, you must configure input parameters. The command must be provided with a \sphinxcode{\sphinxupquote{PDDoc}} object that represents the PDF document on which to operate, as shown in the following example. For information about a \sphinxcode{\sphinxupquote{PDDoc}} object, see \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDDoc} \PYG{n+nb}{object} \PYG{n}{based} \PYG{n}{on} \PYG{n}{the} \PYG{n}{current} \PYG{n}{PDF} \PYG{n}{document}
\PYG{n}{AVDoc} \PYG{n}{avDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVPageView} \PYG{n}{pageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPageNumber} \PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASCab} \PYG{n+nb}{object} \PYG{n}{to} \PYG{n}{store} \PYG{n+nb}{input} \PYG{n}{parameters}
\PYG{n}{ASCab} \PYG{n}{inputs} \PYG{o}{=} \PYG{n}{ASCabNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutPointer} \PYG{p}{(}\PYG{n}{inputs}\PYG{p}{,} \PYG{n}{kAVCommandKeyPDDoc}\PYG{p}{,} \PYG{n}{PDDoc}\PYG{p}{,} \PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n+nb}{input} \PYG{n}{parameters}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{kAVCommandReady} \PYG{o}{!=} \PYG{n}{AVCommandSetInputs}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{,} \PYG{n}{inputs}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Handle} \PYG{n}{error}
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Destroy} \PYG{n}{the} \PYG{n}{ASCab} \PYG{n}{container}
\PYG{n}{ASCabDestroy} \PYG{p}{(}\PYG{n}{inputs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For more information about the \sphinxcode{\sphinxupquote{AVCommandSetInputs}} method, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.
\end{sphinxadmonition}


\subsubsection{Setting configuration parameters}
\label{\detokenize{Plugins_Handlers:setting-configuration-parameters}}
Optionally you can set configuration parameters. The default UI policy is for commands to be fully interactive. To invoke the command programmatically, create an \sphinxcode{\sphinxupquote{ASCab}} object and populate it with the appropriate parameters, as shown in the following example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASCab} \PYG{n+nb}{object} \PYG{n}{to} \PYG{n}{store} \PYG{n}{config} \PYG{n}{parameters}
\PYG{n}{ASCab} \PYG{n}{config} \PYG{o}{=} \PYG{n}{ACabNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutInt} \PYG{p}{(}\PYG{n}{config}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UIPolicy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kAVCommandUISilent}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{kAVCommandReady} \PYG{o}{!=} \PYG{n}{AVCommandSetConfig} \PYG{p}{(}\PYG{n}{cmd}\PYG{p}{,} \PYG{n}{config}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Handle} \PYG{n}{error}
\PYG{n}{ASCabDestroy} \PYG{p}{(}\PYG{n}{config}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Setting AVCommand parameters}
\label{\detokenize{Plugins_Handlers:setting-avcommand-parameters}}
An \sphinxcode{\sphinxupquote{AVCommand}} parameter set is specific to each command. For example, the Document Summary command accepts values for these parameters: \sphinxcode{\sphinxupquote{Title}}, \sphinxcode{\sphinxupquote{Subject}}, \sphinxcode{\sphinxupquote{Author}}, \sphinxcode{\sphinxupquote{Keywords}}, \sphinxcode{\sphinxupquote{Binding}}, and \sphinxcode{\sphinxupquote{LeaveAsIs}}. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

You can create an \sphinxcode{\sphinxupquote{ASCab}} object to store the appropriate parameters; then create empty \sphinxcode{\sphinxupquote{ASText}} objects to hold the parameter values and place these values into the \sphinxcode{\sphinxupquote{ASCabs}} object. The following example uses this approach to set the Document Summary \sphinxcode{\sphinxupquote{Title}} and \sphinxcode{\sphinxupquote{Subject}} values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{docTitleValue} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Document Title}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{docSubjectValue} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Document Subject}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASCab} \PYG{n+nb}{object} \PYG{n}{to} \PYG{n}{hold} \PYG{n}{command} \PYG{n}{parameters}
\PYG{n}{ASCab} \PYG{n}{params} \PYG{o}{=} \PYG{n}{ASCabNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASText} \PYG{n}{text} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextSetEncoded}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{docTitleValue}\PYG{p}{,}\PYG{p}{(}\PYG{n}{ASHostEncoding}\PYG{p}{)}\PYG{n}{PDGetHostEncoding}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutText} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{docTitleValue}\PYG{p}{,} \PYG{n}{text}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Clear} \PYG{n}{the} \PYG{n}{ASText} \PYG{n+nb}{object}
\PYG{n}{text} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextSetEncoded}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{docSubjectValue}\PYG{p}{,}\PYG{p}{(}\PYG{n}{ASHostEncoding}\PYG{p}{)}\PYG{n}{PDGetHostEncoding}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutText}\PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{docSubjectValue}\PYG{p}{,} \PYG{n}{text}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Running commands}
\label{\detokenize{Plugins_Handlers:running-commands}}
The following code example shows an entire example of creating an \sphinxcode{\sphinxupquote{AVCommand}} and running it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{InitializeCommandHandler}\PYG{p}{(}\PYG{p}{)}

\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{local} \PYG{n}{variables}
\PYG{n}{static} \PYG{n}{AVCommandHandlerRec} \PYG{n}{gAVCmdHandler}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{kCmdName} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MinimalCommand}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{ASAtom} \PYG{n}{cmdName}\PYG{p}{;}
\PYG{n}{AVCommand} \PYG{n}{cmd}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{docTitleValue} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Document Title}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{docSubjectValue} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Document Subject}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDDoc} \PYG{n+nb}{object} \PYG{n}{based} \PYG{n}{on} \PYG{n}{the} \PYG{n}{current} \PYG{n}{PDF} \PYG{n}{document}
\PYG{n}{AVDoc} \PYG{n}{avDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVPageView} \PYG{n}{pageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPageNumber} \PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{AVCommandHandlerRec} \PYG{n+nb}{object}
\PYG{n}{memset} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{gAVCmdHandler}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{AVCommandHandlerRec}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gAVCmdHandler}\PYG{o}{.}\PYG{n}{size} \PYG{o}{=} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{AVCommandHandlerRec}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gAVCmdHandler}\PYG{o}{.}\PYG{n}{Work} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto} \PYG{p}{(}\PYG{n}{AVCommandWorkProc}\PYG{p}{,} \PYG{n}{DoWorkImpl}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVAppRegisterCommandHandler} \PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{n}{kCmdName}\PYG{p}{)}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{gAVCmdHandler}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Invoke} \PYG{n}{the} \PYG{n}{AVCommand}
\PYG{n}{cmdName} \PYG{o}{=} \PYG{n}{ASAtomFromString} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MinimalCommand}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd} \PYG{o}{=} \PYG{n}{AVCommandNew}\PYG{p}{(}\PYG{n}{cmdName}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n+nb}{input} \PYG{n}{parameters}
\PYG{n}{ASCab} \PYG{n}{inputs} \PYG{o}{=} \PYG{n}{ASCabNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutPointer} \PYG{p}{(}\PYG{n}{inputs}\PYG{p}{,} \PYG{n}{kAVCommandKeyPDDoc}\PYG{p}{,} \PYG{n}{PDDoc}\PYG{p}{,} \PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Set} \PYG{n}{the} \PYG{n+nb}{input} \PYG{n}{parameters} \PYG{o+ow}{and} \PYG{n}{destroy} \PYG{n}{the} \PYG{n}{container} \PYG{n}{ASCab}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{kAVCommandReady} \PYG{o}{!=} \PYG{n}{AVCommandSetInputs} \PYG{p}{(}\PYG{n}{cmd}\PYG{p}{,} \PYG{n}{inputs}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{o}{/}\PYG{o}{/} \PYG{n}{Handle} \PYG{n}{error}
\PYG{p}{\PYGZcb{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASCab} \PYG{n+nb}{object} \PYG{n}{to} \PYG{n}{hold} \PYG{n}{command} \PYG{n}{parameters}
\PYG{n}{ASCab} \PYG{n}{params} \PYG{o}{=} \PYG{n}{ASCabNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASText} \PYG{n}{text} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextSetEncoded}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{docTitleValue}\PYG{p}{,}\PYG{p}{(}\PYG{n}{ASHostEncoding}\PYG{p}{)}\PYG{n}{PDGetHostEncoding}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutText} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{docTitleValue}\PYG{p}{,} \PYG{n}{text}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Clear} \PYG{n}{the} \PYG{n}{ASText} \PYG{n+nb}{object}
\PYG{n}{text} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextSetEncoded}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{docSubjectValue}\PYG{p}{,}\PYG{p}{(}\PYG{n}{ASHostEncoding}\PYG{p}{)}\PYG{n}{PDGetHostEncoding}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutText}\PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{docSubjectValue}\PYG{p}{,} \PYG{n}{text}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Invoke} \PYG{n}{the} \PYG{n}{command}
\PYG{n}{AVCommandExecute}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{n}{static} \PYG{n}{ACCB1} \PYG{n}{AVCommandStatus} \PYG{n}{ACCB2} \PYG{n}{DoWorkImpl} \PYG{p}{(}\PYG{n}{AVCommand} \PYG{n}{cmd}\PYG{p}{)}

\PYG{p}{\PYGZob{}}
\PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The DoWorkImpl method was invoked}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{return} \PYG{n}{kAVCommandDone}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Exposing AVCommands to the batch framework}
\label{\detokenize{Plugins_Handlers:exposing-avcommands-to-the-batch-framework}}
Acrobat or Adobe Reader builds the list of commands that users see in the \sphinxcode{\sphinxupquote{Batch Sequences}} and \sphinxcode{\sphinxupquote{Batch Edit Sequence}} dialog boxes from an internal list of \sphinxcode{\sphinxupquote{AVCommands}} referred to as the global command list.


\subsubsection{Adding a handler to the global command list}
\label{\detokenize{Plugins_Handlers:adding-a-handler-to-the-global-command-list}}
To expose a command to the batch framework, the \sphinxcode{\sphinxupquote{AVCommand}} handler must first add an instance of the command to this global list by invoking the \sphinxcode{\sphinxupquote{AVAppRegisterGlobalCommand}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVCommand} \PYG{n}{cmd} \PYG{o}{=} \PYG{n}{AVCommandNew}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{n}{kCmdName}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{AVAppRegisterGlobalCommand}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Although this step can be performed at any time once the command handler is registered, handlers commonly register commands from within the \sphinxcode{\sphinxupquote{AVCommandRegisterCommandsProc}} callback (of the \sphinxcode{\sphinxupquote{AVCommandHandlerRec}} structure).


\subsubsection{Supporting properties}
\label{\detokenize{Plugins_Handlers:supporting-properties}}
When building a list of batchable commands, Adobe Reader or Acrobat iterates through its internal command list, querying each command for the \sphinxcode{\sphinxupquote{CanBatch}} and \sphinxcode{\sphinxupquote{GroupTitle}} properties. To be exposed through the batch framework user interface, a command must support these properties (that is, return \sphinxcode{\sphinxupquote{true}} and a valid \sphinxcode{\sphinxupquote{ASText}} object, respectively). The \sphinxcode{\sphinxupquote{AVCommand}} handler must implement the \sphinxcode{\sphinxupquote{GetProps}} callback of the \sphinxcode{\sphinxupquote{AVCommandHandlerRec}} structure.

If an \sphinxcode{\sphinxupquote{AVCommand}} supports these properties, Adobe Reader or Acrobat queries a number of additional properties as the user interacts with the batch framework. Of these additional properties, only two are required: \sphinxcode{\sphinxupquote{Title}} and \sphinxcode{\sphinxupquote{Generic Title}}. A command must provide the title strings that will be displayed in the Batch Sequences and Batch Edit Sequence dialog boxes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{kCmdTitle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Command Title}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{kGroupTitle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Group Title}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{kCmdGenericTitle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Generic Title}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

\PYG{n}{ASBool} \PYG{n}{doItAll} \PYG{o}{=} \PYG{n}{false}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ASCabNumEntries}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{doItAll} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{doItAll} \PYG{o}{|}\PYG{o}{|} \PYG{n}{ASCabKnown} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{kAVCommandKeyGroupTitle}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{text} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n}{insert} \PYG{n}{it} \PYG{n}{into} \PYG{n}{the} \PYG{n}{ASCab}
\PYG{n}{text} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextSetEncoded} \PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{kGroupTitle}\PYG{p}{,} \PYG{p}{(}
\PYG{n}{ASHostEncoding}\PYG{p}{)}\PYG{n}{PDGetHostEncoding}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutText}\PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{kAVCommandKeyGroupTitle}\PYG{p}{,} \PYG{n}{text}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{doItAll} \PYG{o}{|}\PYG{o}{|} \PYG{n}{ASCabKnown} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{kAVCommandKeyCanBatch}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ASCabPutBool} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{kAVCommandKeyCanBatch}\PYG{p}{,} \PYG{n}{true} \PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{doItAll} \PYG{o}{|}\PYG{o}{|} \PYG{n}{ASCabKnown} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{kAVCommandKeyGenericTitle}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{text} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n}{insert} \PYG{n}{it} \PYG{n}{into} \PYG{n}{the} \PYG{n}{ASCab}
\PYG{n}{text} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextSetEncoded} \PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{kCmdGenericTitle}\PYG{p}{,}
\PYG{p}{(}\PYG{n}{ASHostEncoding}\PYG{p}{)}\PYG{n}{PDGetHostEncoding}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutText} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{kAVCommandKeyGenericTitle}\PYG{p}{,} \PYG{n}{text}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{doItAll} \PYG{o}{|}\PYG{o}{|} \PYG{n}{ASCabKnown} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{kAVCommandKeyTitle}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Create} \PYG{n}{another} \PYG{n}{text} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n}{insert} \PYG{n}{it} \PYG{n}{into} \PYG{n}{the} \PYG{n}{ASCab}
\PYG{n}{text} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextSetEncoded} \PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{kCmdTitle}\PYG{p}{,}
\PYG{p}{(}\PYG{n}{ASHostEncoding}\PYG{p}{)}\PYG{n}{PDGetHostEncoding}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASCabPutText} \PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{kAVCommandKeyTitle}\PYG{p}{,} \PYG{n}{text}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{params}} object was declared in \sphinxhref{Plugins\_Handlers.html\#50618413\_70559}{Running an AVCommand}.
\end{sphinxadmonition}


\section{File format conversion handlers}
\label{\detokenize{Plugins_Handlers:file-format-conversion-handlers}}
A plugin can add file conversion handlers to Acrobat (but not Adobe Reader) for performing the following file conversion operations:
\begin{itemize}
\item {} 
To import a PDF document from another file format.

\item {} 
To export a PDF document to another file format.

\end{itemize}

To add a new file conversion handler, you provide a set of callback functions, specify them in the \sphinxcode{\sphinxupquote{AVConversionToPDFHandler}} or \sphinxcode{\sphinxupquote{AVConversionFromPDFHandler}} structures, and invoke the \sphinxcode{\sphinxupquote{AVAppRegisterToPDFHandler}} or \sphinxcode{\sphinxupquote{AVAppRegisterFromPDFHandler}} methods to register them.

Specify the file types that the plugin can convert and whether it can perform synchronous conversion (required for the handler to be accessible from the batch framework). Upon registration, the conversion handlers are automatically added to the respective Open and Save As dialog boxes.

By using a file format conversion handler, you can perform the following tasks:
\begin{itemize}
\item {} 
Provide default settings for the conversion by using the \sphinxcode{\sphinxupquote{AVConversionDefaultSettingsProc}} callback method.

\item {} 
Provide conversion parameter information by using the \sphinxcode{\sphinxupquote{AVConversionParamDescProc}} callback method.

\item {} 
Display a settings dialog box by using the \sphinxcode{\sphinxupquote{AVConversionSettingsDialogProc}} callback method.

\item {} 
Convert a non\sphinxhyphen{}PDF file to or from a PDF file by invoking either the \sphinxcode{\sphinxupquote{AVConversionConvertToPDFProc}} or \sphinxcode{\sphinxupquote{AVConversionConvertFromPDFProc}} callback methods.

\end{itemize}


\section{File specification handlers}
\label{\detokenize{Plugins_Handlers:file-specification-handlers}}
A file specification handler converts between a \sphinxcode{\sphinxupquote{PDFileSpec}} object and an \sphinxcode{\sphinxupquote{ASPathName}} object. Each file specification handler works with a single file system, which the handler specifies.

To create a new file specification handler, a plugin or application must provide callbacks that:
\begin{itemize}
\item {} 
Convert an \sphinxcode{\sphinxupquote{ASPathName}} to a \sphinxcode{\sphinxupquote{PDFileSpec}}. It is called by \sphinxcode{\sphinxupquote{PDFileSpecNewFromASPath}}.

\item {} 
Convert a \sphinxcode{\sphinxupquote{PDFileSpec}} to an \sphinxcode{\sphinxupquote{ASPathName}}.

\end{itemize}


\section{Selection servers}
\label{\detokenize{Plugins_Handlers:selection-servers}}
A selection server enables the selection of specific data types such as annotations, text, or graphics. You can also create selection servers to enable the selection of data types not already supported. To add a new selection server, you must provide a set of callbacks, specify them in the \sphinxcode{\sphinxupquote{AVDocSelectionServer}} data structure, and register them using an \sphinxcode{\sphinxupquote{AVDocRegisterSelectionServer}} object.

By using a selection server, you can perform the following tasks:
\begin{itemize}
\item {} 
Return the selection type serviced by the handler by using the \sphinxcode{\sphinxupquote{AVDocSelectionGetTypeProc}} callback method.

\item {} 
Highlight or unhighlight a selection by using the \sphinxcode{\sphinxupquote{AVDocSelectionHighlightSelectionProc}} callback method.

\item {} 
Handle key presses by using the \sphinxcode{\sphinxupquote{AVDocSelectionKeyDownProc}} callback method.

\item {} 
Delete the selection by invoking the \sphinxcode{\sphinxupquote{AVDocSelectionDeleteProc}} method.

\item {} 
Cut the selection to the clipboard by using the \sphinxcode{\sphinxupquote{AVDocSelectionCutProc}} callback method.

\item {} 
Copy the selection to the clipboard by using the \sphinxcode{\sphinxupquote{AVDocSelectionCopyProc}} callback method.

\item {} 
Paste the selection from the clipboard by using the \sphinxcode{\sphinxupquote{AVDocSelectionPasteProc}} callback method.

\item {} 
Enumerate the items in the current selection by using the \sphinxcode{\sphinxupquote{AVDocSelectionEnumSelectionProc}} callback method.

\item {} 
Scroll the view so that the current selection is available by using the \sphinxcode{\sphinxupquote{AVDocSelectionShowSelectionProc}} callback method.

\item {} 
Determine whether or not the Properties menu item is enabled by using the \sphinxcode{\sphinxupquote{AVDocSelectionCanPropertiesProc}} callback method.

\item {} 
If the selection type has a properties dialog box, display the dialog box by using the \sphinxcode{\sphinxupquote{AVDocSelectionPropertiesProc}} callback method.

\end{itemize}

For a complete list of the callbacks in a selection server, see the description of \sphinxcode{\sphinxupquote{AVDocSelectionServer}} in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\begin{sphinxadmonition}{note}{Note:}
The SelectionServer sample plugin that is located in the Acrobat SDK shows an example of a selection server.
\end{sphinxadmonition}


\section{Tool callbacks}
\label{\detokenize{Plugins_Handlers:tool-callbacks}}
To add a new tool, you must provide a set of callbacks, specify them in the \sphinxcode{\sphinxupquote{AVTool}} data structure, and register them using \sphinxcode{\sphinxupquote{AVAppRegisterTool}}. By using tool callbacks, you can perform the following tasks:
\begin{itemize}
\item {} 
Activate the tool when the tool is selected by using the \sphinxcode{\sphinxupquote{ActivateProcType}} callback method.

\item {} 
Deactivate the tool when another tool is selected by using the \sphinxcode{\sphinxupquote{DeactivateProcType}} callback method.

\item {} 
Handle mouse clicks by using the \sphinxcode{\sphinxupquote{DoClickProcType}} callback method.

\item {} 
Handle key presses by using the \sphinxcode{\sphinxupquote{DoKeyDownProcType}} callback method.

\item {} 
Control the cursor shape by using the \sphinxcode{\sphinxupquote{AdjustCursorProcType}} callback method.

\item {} 
Return the tool’s name by using the \sphinxcode{\sphinxupquote{GetTypeProcType}} callback method.

\item {} 
Indicate whether the tool stays active after it is used by using the \sphinxcode{\sphinxupquote{IsPersistentProcType}} callback method.

\item {} 
Determine whether the tool is enabled by using the \sphinxcode{\sphinxupquote{AVComputeEnabledProc}} callback method. For example, if a tool is meant to be used within documents, but there are no documents open, it does not make sense to activate the tool.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
For a complete list of callbacks, see the description of \sphinxcode{\sphinxupquote{AVTool}} in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.
\end{sphinxadmonition}


\section{Window handlers}
\label{\detokenize{Plugins_Handlers:window-handlers}}
When a plugin creates a window, it can register the window, so that it behaves like other windows in Acrobat; for example, when Adobe Reader or Acrobat is minimized or hidden. For each window that a plugin provides, a window handler must be provided. Window handlers are used only in the Mac OS version of Adobe Reader or Acrobat. Windows versions of Acrobat instead use the platform’s native window handling mechanisms. (See \sphinxhref{Plugins\_Documents.html\#50618416\_74021}{Opening a PDF document in an external window}.)

To define a window handler, you must provide a set of callbacks, specify them in an \sphinxcode{\sphinxupquote{AVWindowHandler}} structure, and pass the structure to \sphinxcode{\sphinxupquote{AVWindowNew}} or \sphinxcode{\sphinxupquote{AVWindowNewFromPlatformThing}}. The window handler’s callbacks are automatically called by Acrobat. Default behavior is used for any missing callbacks.

By using a window handler, you can perform the following tasks:
\begin{itemize}
\item {} 
Handle mouse clicks in the window by using the \sphinxcode{\sphinxupquote{AVWindowMouseDownProc}} callback method.

\item {} 
Handle keystrokes in the window by using the \sphinxcode{\sphinxupquote{AVWindowKeyDownProc}} callback method.

\item {} 
Draw the window’s contents by using the \sphinxcode{\sphinxupquote{AVWindowDrawProc}} callback method.

\item {} 
Permit or prevent closing of the window by using the \sphinxcode{\sphinxupquote{AVWindowWillCloseProc}} callback method.

\item {} 
Clean up after the window has been closed by using the \sphinxcode{\sphinxupquote{AVWindowDidCloseProc}} callback method.

\item {} 
Do anything that must be done when the window is activated or deactivated by using the following callback methods: \sphinxcode{\sphinxupquote{AVWindowDidActivateProc}} or \sphinxcode{\sphinxupquote{AVWindowWillDeactivateProc}}.

\item {} 
Permit or constrain window size changes by using the \sphinxcode{\sphinxupquote{AVWindowWillBeResizedProc}} callback method.

\item {} 
Determine whether the Cut, Copy, Paste, Clear, SelectAll, and Undo menu items are enabled by using the \sphinxcode{\sphinxupquote{AVWindowCanPerformEditOpProc}} callback method.

\item {} 
Perform Cut, Copy, Paste, Clear, SelectAll, and Undo operations by using the \sphinxcode{\sphinxupquote{AVWindowPerformEditOpProc}} callback method.

\item {} 
Control the shape of the cursor when it is within the window by using the \sphinxcode{\sphinxupquote{AVWindowAdjustCursorProc}} callback method.

\end{itemize}

For a complete list of callbacks in a window handler, see the description of \sphinxcode{\sphinxupquote{AVWindowHandler}} in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{File systems}
\label{\detokenize{Plugins_Handlers:file-systems}}
Plugins can add new file systems to Acrobat or Adobe Reader, to access files on a device that cannot be accessed as a local hard disk, such as a socket or a modem line.

To add a new file system, you must provide a set of callbacks and specify them in the \sphinxcode{\sphinxupquote{ASFileSysRec}} structure. This structure is passed as a parameter to calls that require a file system. A file system handler does not require explicit registration.

By using a file system handler, you can perform the following tasks:
\begin{itemize}
\item {} 
Open a file by using the \sphinxcode{\sphinxupquote{ASFileSysOpenProc}} callback method.

\item {} 
Close a file by using the \sphinxcode{\sphinxupquote{ASFileSysCloseProc}} callback method.

\item {} 
Flush a file’s buffered data to disk by using the \sphinxcode{\sphinxupquote{ASFileSysFlushProc}} callback method.

\item {} 
Get or set the current position in a file by using one of the following callback methods: \sphinxcode{\sphinxupquote{ASFileSysSetPosProc}} or \sphinxcode{\sphinxupquote{ASFileSysGetPosProc}}.

\item {} 
Get or set a file’s logical size by using one of the following callback methods: \sphinxcode{\sphinxupquote{ASFileSysGetEofProc}} or \sphinxcode{\sphinxupquote{ASFileSysSetEofProc}}.

\item {} 
Read data from a file by using the \sphinxcode{\sphinxupquote{ASFileSysReadProc}} callback method.

\item {} 
Write data to a file by using the \sphinxcode{\sphinxupquote{ASFileSysWriteProc}} callback method.

\item {} 
Delete a file by using the \sphinxcode{\sphinxupquote{ASFileSysRemoveProc}} callback method.

\item {} 
Rename a file by using the \sphinxcode{\sphinxupquote{ASFileSysRenameProc}} callback method.

\item {} 
Get a file’s name by using the \sphinxcode{\sphinxupquote{ASFileSysGetNameProc}} callback method.

\item {} 
Get a file system’s name by using the \sphinxcode{\sphinxupquote{ASFileSysGetFileSysNameProc}} callback method.

\item {} 
Determine whether two files are the same by using the \sphinxcode{\sphinxupquote{ASFileSysIsSameFileProc}} callback method.

\item {} 
Get a path to a temporary file by using the \sphinxcode{\sphinxupquote{ASFileSysGetTempPathNameProc}} callback method.

\item {} 
Copy a path (not the underlying file) by using the \sphinxcode{\sphinxupquote{ASFileSysCopyPathNameProc}} callback method.

\item {} 
Convert between device\sphinxhyphen{}independent and device\sphinxhyphen{}dependent path by using the \sphinxcode{\sphinxupquote{ASFileSysDiPathFromPathProc}} callback method.

\item {} 
Dispose of a path (not the underlying file) by using the \sphinxcode{\sphinxupquote{ASFileSysDisposePathNameProc}} callback method.

\item {} 
Flush data on a volume by using the \sphinxcode{\sphinxupquote{ASFileSysFlushVolumeProc}} callback method.

\item {} 
Handle asynchronous I/O operations by using the following callback methods: \sphinxcode{\sphinxupquote{ASFileSysAsyncReadProc}} or \sphinxcode{\sphinxupquote{ASFileSysAsyncWriteProc}}.

\item {} 
Handle multiple read requests by using the \sphinxcode{\sphinxupquote{ASFileSysMReadRequestProc}} callback method.

\end{itemize}

For details about each of the callbacks in a file system, see the description of \sphinxcode{\sphinxupquote{ASFileSysRec}} in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{Progress monitors}
\label{\detokenize{Plugins_Handlers:progress-monitors}}
Progress monitors provide feedback to a user on the progress of a time\sphinxhyphen{}consuming operation. Some potentially time\sphinxhyphen{}consuming methods in the Acrobat core API require a progress monitor as a parameter. Acrobat has a default progress monitor, which generally is sufficient for plugins to use. The built\sphinxhyphen{}in progress monitor can be obtained by using the \sphinxcode{\sphinxupquote{AVAppGetDocProgressMonitor}} method.

Plugins can use the default progress monitor or implement their own by providing a set of callbacks, specifying them in the \sphinxcode{\sphinxupquote{ASProgressMonitorRec}} data structure, and passing a pointer to the structure to the methods that require a progress monitor (there is no explicit registration method).

Using a progress monitor, you can perform the following tasks:
\begin{itemize}
\item {} 
Initialize the progress monitor and display it with a current value of zero by invoking the \sphinxcode{\sphinxupquote{PMBeginOperationProc}} method.

\item {} 
Draw a full progress monitor, then remove the progress monitor from the display by invoking the \sphinxcode{\sphinxupquote{PMEndOperationProc}} method.

\item {} 
Set the value that corresponds to a full progress monitor display by invoking the \sphinxcode{\sphinxupquote{PMSetDurationProc}} method.

\item {} 
Set the current value of the progress monitor and update the display by invoking the \sphinxcode{\sphinxupquote{PMSetCurrValueProc}} method.

\item {} 
Get the progress monitor’s maximum value by invoking the \sphinxcode{\sphinxupquote{PMGetDurationProc}} method.

\item {} 
Get the progress monitor’s current value by invoking the \sphinxcode{\sphinxupquote{PMGetCurrValueProc}} method.

\end{itemize}

For details, see the description of \sphinxcode{\sphinxupquote{ASProgressMonitorRec}} in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{Transition handlers}
\label{\detokenize{Plugins_Handlers:transition-handlers}}
Transitions allow effects such as dissolves or wipe\sphinxhyphen{}downs when displaying a new page. New transition types can be added by defining and registering a transition handler.

To add a new transition, you must provide a set of callbacks, specify them in the \sphinxcode{\sphinxupquote{AVTransHandler}} data structure, and register them by invoking the \sphinxcode{\sphinxupquote{AVAppRegisterTransHandler}} method.

Using a transition handler, you can perform the following tasks:
\begin{itemize}
\item {} 
Get the transition type by invoking the \sphinxcode{\sphinxupquote{AVTransHandlerGetTypeProc}} method.

\item {} 
Perform the transition (change to the next page with this transition style) by invoking the \sphinxcode{\sphinxupquote{AVTransHandlerExecuteProc}} method.

\item {} 
Fill in the transition dictionary in the PDF file by using either the \sphinxcode{\sphinxupquote{AVTransHandlerInitTransDictProc}} or \sphinxcode{\sphinxupquote{AVTransHandlerCompleteTransDictProc}} methods.

\item {} 
Provide information for the user interface that sets the attributes of the transition by invoking the \sphinxcode{\sphinxupquote{AVTransHandlerGetUINameProc}} method.

\end{itemize}


\section{Adding message handling}
\label{\detokenize{Plugins_Handlers:adding-message-handling}}
Plugins can add their own DDE messages and Apple events to those supported by Acrobat and Adobe Reader. On Windows, plugins can register to receive DDE messages directly. On Mac OS, plugins must hook into Acrobat or Adobe Reader’s Apple event handling loop to handle Apple events. To do this, replace the API’s AVAppHandleAppleEvent method. For information about replacing methods, see \sphinxhref{Plugins\_Hft.html\#50618412\_19489}{Replacing HFT methods}.

If a plugin receives an Apple event it does not want to handle, it should invoke the implementation of the method it replaced, allowing other plugins or Acrobat or Adobe Reader the opportunity to handle the Apple event.

\begin{sphinxadmonition}{note}{Note:}
Plugins should use the DDEML library to handle DDE messages. Problems may arise if they do not.
\end{sphinxadmonition}


\chapter{Registering for Event Notifications}
\label{\detokenize{Plugins_Notification:registering-for-event-notifications}}\label{\detokenize{Plugins_Notification::doc}}
This chapter explains how to register for notification of a specific event. The Acrobat core API provides a notification mechanism so that plugins can synchronize their actions with Acrobat or Adobe Reader. Notifications enable plugins to indicate that they are interested in a specified event (such as the initialization of Adobe Reader or Acrobat) and to provide a callback function that is invoked by Adobe Reader or Acrobat each time an event occurs.

The order in which notifications occur may vary depending on the platform. For example, after opening a PDF document on the Windows platform, notifications occur in this order:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{AVPageViewDidChange}}

\item {} 
\sphinxcode{\sphinxupquote{AVDocDidOpen}}

\item {} 
\sphinxcode{\sphinxupquote{AVDocDidActivate}}

\item {} 
\sphinxcode{\sphinxupquote{AVPageViewDidChange}}

\end{enumerate}

In contrast, after opening a PDF document in Mac OS, notifications occur in this order:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{AVPageViewDidChange}}

\item {} 
\sphinxcode{\sphinxupquote{AVDocDidActivate}}

\item {} 
\sphinxcode{\sphinxupquote{AVPageViewDidChange}}

\item {} 
\sphinxcode{\sphinxupquote{AVDocDidOpen}}

\end{enumerate}


\section{Registering event notifications}
\label{\detokenize{Plugins_Notification:registering-event-notifications}}
Register for an event notification when you want your plugin to be notified when a specific event occurs. For example, you can register for a notification when Acrobat or Adobe Reader is finished initializing. To register for an event notification, you provide a callback function that Acrobat or Adobe Reader invokes when the event occurs. To view a list of notification methods used to register an event notification, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

You can register for an event notification by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a user\sphinxhyphen{}defined function that is invoked when the event occurs.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{AVAppRegisterNotification}} method and pass the following arguments:
\begin{itemize}
\item {} 
The name of the Acrobat core API method that corresponds to the event notification. For example, to register for the event that occurs when Adobe Reader or Acrobat is finished initializing, pass \sphinxcode{\sphinxupquote{AVAppDidInitialize}}. Append the value \sphinxcode{\sphinxupquote{NSEL}} to the end of the method name.

\item {} 
An \sphinxcode{\sphinxupquote{ASExtension}} object that represents the identity of the caller. For plugins, you can use \sphinxcode{\sphinxupquote{gExtensionID}} (this is defined in the PIMain.c file).

\item {} 
The callback function that is invoked when the event occurs. You can invoke the \sphinxcode{\sphinxupquote{ASCallbackCreateNotification}} macro and pass the following arguments:

\end{itemize}

\item {} 
The name of the Acrobat core API method that corresponds to the event notification. Do not append a value to the method name.

\item {} 
The address of the user\sphinxhyphen{}defined function that is invoked when the event occurs.
\begin{itemize}
\item {} 
A pointer to user\sphinxhyphen{}supplied data. Pass \sphinxcode{\sphinxupquote{NULL}} if you do not want to supply user\sphinxhyphen{}supplied data.

\end{itemize}

\end{enumerate}

The following code example registers for the event that occurs when Adobe Reader or Acrobat is finished initializing. The name of the callback function is \sphinxcode{\sphinxupquote{myNotificationCallback}}. This function simply displays an alert box. Note that \sphinxcode{\sphinxupquote{AVAppRegisterNotification}} is invoked within the \sphinxcode{\sphinxupquote{PluginInit}} method. For information about this method, see \sphinxhref{Plugins\_Pimech.html\#50618406\_89824}{Handshaking}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Registering for an event notification

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginInit}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Register} \PYG{k}{for} \PYG{n}{an} \PYG{n}{event} \PYG{n}{notification}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVAppRegisterNotification}\PYG{p}{(}\PYG{n}{AVAppDidInitializeNSEL}\PYG{p}{,}

\PYG{n}{gExtensionID}\PYG{p}{,}\PYG{n}{ASCallbackCreateNotification}\PYG{p}{(}\PYG{n}{AVAppDidInitialize}\PYG{p}{,}

\PYG{o}{\PYGZam{}}\PYG{n}{myNotificationCallback}\PYG{p}{)}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{user}\PYG{o}{\PYGZhy{}}\PYG{n}{defined} \PYG{n}{function} \PYG{n}{that} \PYG{o+ow}{is} \PYG{n}{invoked} \PYG{n}{when} \PYG{n}{Adobe} \PYG{n}{Reader} \PYG{o+ow}{or} \PYG{n}{Acrobat}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{has} \PYG{n}{finished} \PYG{n}{initializing}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{myNotificationCallback}\PYG{p}{(}\PYG{n}{void} \PYG{o}{*}\PYG{n}{clientData}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Acrobat has finished initializing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Unregistering event notifications}
\label{\detokenize{Plugins_Notification:unregistering-event-notifications}}
You can unregister an event notification that you previously registered for by using the Acrobat core API. To unregister an event notification, invoke the \sphinxcode{\sphinxupquote{AVAppUnregisterNotification}} method and pass the following arguments:
\begin{itemize}
\item {} 
The name of the Acrobat core API method that corresponds to the event notification. For example, to register for the event that occurs when Adobe Reader or Acrobat has initialized, pass \sphinxcode{\sphinxupquote{AVAppDidInitialize}}. Append the value \sphinxcode{\sphinxupquote{NSEL}} to the end of the method name.

\item {} 
An \sphinxcode{\sphinxupquote{ASExtension}} object that represents the identity of the caller. For plugins, you can use \sphinxcode{\sphinxupquote{gExtensionID}} (this is defined in the PIMain.c file).

\item {} 
The callback function that is invoked when the event occurs. You can invoke the \sphinxcode{\sphinxupquote{ASCallbackCreateNotification}} macro and pass the following arguments:
\begin{itemize}
\item {} 
The name of the Acrobat core API method that corresponds to the event notification. Do not append a value to the method name.

\item {} 
The address of the user\sphinxhyphen{}defined function that is invoked when the event occurs.

\end{itemize}

\item {} 
A pointer to user\sphinxhyphen{}supplied data. Pass \sphinxcode{\sphinxupquote{NULL}} if you do not want to supply user\sphinxhyphen{}supplied data.

\end{itemize}

The following example unregisters the event notification that occurs when Adobe Reader or Acrobat has initialized.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Unregistering an event notification

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVAppUnregisterNotification}\PYG{p}{(}\PYG{n}{AVAppDidInitializeNSEL}\PYG{p}{,}

\PYG{n}{gExtensionID}\PYG{p}{,}\PYG{n}{ASCallbackCreateNotification}\PYG{p}{(}\PYG{n}{AVAppDidInitialize}\PYG{p}{,}

\PYG{o}{\PYGZam{}}\PYG{n}{myNotificationCallback}\PYG{p}{)}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Pass the same arguments that you specified when you registered for the event notification. (See \sphinxhref{Plugins\_Notification.html\#50618408\_85504}{Registering event notifications}.)
\end{sphinxadmonition}


\chapter{Working with Document Security}
\label{\detokenize{Plugins_Security:working-with-document-security}}\label{\detokenize{Plugins_Security::doc}}

\section{About document security}
\label{\detokenize{Plugins_Security:about-document-security}}
Encryption is controlled by an encryption dictionary in the PDF file. The Acrobat core API uses RC4 (a proprietary algorithm provided by RSA Data Security, Inc.) to encrypt document data, and a standard (proprietary) method to encrypt, decrypt, and verify user passwords to determine whether or not a user is authorized to open a document.

Each stream or string object in a PDF file is individually encrypted. This level of encryption improves performance because objects can be individually decrypted as needed rather than decrypting an entire file. All objects, except for the encryption dictionary (which contains the security handler’s private data), are encrypted using the RC4 algorithm Adobe licenses from RSA Data Security, Inc. A plugin may not substitute another encryption scheme for RC4.

A plugin that implements a security handler is responsible for encrypting the values it places into the encryption dictionary, and it may use any encryption scheme. If the security handler does not encrypt the values it places into the encryption dictionary, the values are in plain text.

The core API provides two Cos layer methods to encrypt and decrypt data using the RC4 algorithm. These methods are \sphinxcode{\sphinxupquote{CosEncryptData}} and \sphinxcode{\sphinxupquote{CosDecryptData}}. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

Security handlers may use these methods to encrypt data they want to put into the PDF file’s encryption dictionary and decrypt data when it is read from the dictionary. Security handlers may instead choose to ignore these methods and use their own encryption algorithms.


\section{About security handlers}
\label{\detokenize{Plugins_Security:about-security-handlers}}
Application logic that performs user authorization and sets permissions is known as a security handler. Acrobat has these built\sphinxhyphen{}in security handlers: password, Adobe and public key security handler. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

A security handler supports two passwords:
\begin{itemize}
\item {} 
A user password that enables a user to open and read a protected document with whatever permissions the owner chose

\item {} 
An owner password that allows a document’s owner to also change the permissions granted to users

\end{itemize}

You can use the Acrobat core API’s built\sphinxhyphen{}in security handler or write your own security handlers to perform user authorization (for example, by the presence of a specific hardware key or file, or by reading a magnetic card reader).

Security handlers are responsible for performing the following tasks:
\begin{itemize}
\item {} 
Setting permissions on a file

\item {} 
Authorizing access to a file

\item {} 
Setting up a file’s encryption and decryption keys

\item {} 
Maintaining the encryption dictionary of the PDF file containing the document

\end{itemize}

Security handlers are used in the following situations:
\begin{itemize}
\item {} 
A document is opened. The security handler determines whether a user is authorized to open the file and sets up the decryption key that is used to decrypt the PDF file.

\item {} 
A document is saved. The security handler sets up the encryption key and writes extra security\sphinxhyphen{}related information into the PDF file’s encryption dictionary.

\item {} 
A user attempts to change a document’s security settings. The security handler determines whether the user is permitted to perform this task.

\end{itemize}

A document may have zero, one, or two security handlers associated with it. A document has zero security handlers if no security is used on the file. When security is applied to a file, or the user selects a different security handler for a secured file, the newly\sphinxhyphen{}chosen security handler is not put in place immediately. Instead this new security handler is simply associated with the document; it is a pending security handler until the document is saved.

The new security handler is not put in place immediately because it is responsible for decrypting the contents of the document’s encryption dictionary, and that dictionary is re\sphinxhyphen{}encrypted in the correct format for the new security handler only when the document is saved. As a result, a document may have both a current and a new security handler associated with it.

A security handler has two names: one that is placed in each PDF file that is saved by the handler (for example, ADBE\_Crypt), and another name that Acrobat can use in any user interface items in which the security handler appears (for example, Acrobat Developer Technologies default encryption). This is similar to the two\sphinxhyphen{}name scheme used for menu items: a language\sphinxhyphen{}independent name that the application logic can refer to regardless of the user interface language, and another name that appears in the user interface. (See \sphinxhref{Plugins\_Menu.html\#50618409\_63428}{Adding menu commands to menus}.)


\subsection{Adding a security handler}
\label{\detokenize{Plugins_Security:adding-a-security-handler}}
You can add a security handler by performing the following tasks:
\begin{itemize}
\item {} 
Writing a set of callback routines to perform security\sphinxhyphen{}related functions.

\item {} 
Specifying the callbacks in a \sphinxcode{\sphinxupquote{PDCryptHandlerRec}} structure.

\item {} 
Registering the handler by passing the structure to \sphinxcode{\sphinxupquote{PDRegisterCryptHandlerEx}}.

\end{itemize}


\subsubsection{Security handlers data}
\label{\detokenize{Plugins_Security:security-handlers-data}}
The following list describes three types of data used by security handlers:
\begin{itemize}
\item {} 
Authorization data is the data the security handler needs to determine the user’s authorization level for a particular file (for example, not authorized to open the file, authorized to access the file with user permissions, authorized to access the file with owner permissions). Passwords are a common type of authorization data.

\item {} 
Security data is whatever internal data the security handler uses. It includes security information, internal flag values, seed values, and so on.

\item {} 
Security information is a subset of the security data. Specifically, it is a collection of flags that contains the information that Acrobat uses to display the current permissions to the user. This information includes permissions and the user’s authorization level (user or owner).

\end{itemize}


\subsubsection{Security handler callbacks}
\label{\detokenize{Plugins_Security:security-handler-callbacks}}
A security handler must provide callbacks that performs the following tasks:
\begin{itemize}
\item {} 
Determines whether a user is authorized to open a particular file and what permissions the user has once the file is open (\sphinxcode{\sphinxupquote{PDCryptAuthorizeExProc}} ).

\item {} 
Creates and fills an authorization data structure, using whatever user interface is needed to obtain the data. For example, displaying a dialog box into which the user can type a password (\sphinxcode{\sphinxupquote{PDCryptGetAuthDataExProc}} ).

\item {} 
Creates, fills, and verifies a security data structure (\sphinxcode{\sphinxupquote{PDCryptNewSecurityDataProc}} ).

\item {} 
Extracts security information from the security data structure (\sphinxcode{\sphinxupquote{PDCryptGetSecurityInfoProc}} ).

\item {} 
Allows the user to request different security settings, usually by displaying a dialog box. (\sphinxcode{\sphinxupquote{PDCryptDisplaySecurityDataProc}} )

\item {} 
Sets up the encryption key used to encrypt the file (\sphinxcode{\sphinxupquote{PDCryptNewCryptDataProc}} ).

\item {} 
Fills or reads the PDF filefs encryption dictionary (\sphinxcode{\sphinxupquote{PDCryptFillEncryptDictProc}} ).

\item {} 
Displays the current document’s permissions (required with \sphinxcode{\sphinxupquote{PDCryptAuthorizeExProc}} and \sphinxcode{\sphinxupquote{PDCryptGetAuthDataExProc}} callbacks).

\end{itemize}

With Acrobat 5.0 and later, a finer granularity of permissions has been predefined for objects supported by a PDF document. Plugins can invoke the \sphinxcode{\sphinxupquote{PDDocPermRequest}} method to request whether a particular operation is authorized to be performed on a specified object in a document.

To support the \sphinxcode{\sphinxupquote{PDDocPermRequest}} method, there are two new callback methods: \sphinxcode{\sphinxupquote{PDCryptAuthorizeExProc}} and \sphinxcode{\sphinxupquote{PDCryptGetAuthDataExProc}}. Acrobat 5.0 and later also includes optional security handling for batch operations (actions on one or more files). There are a number of callbacks (indicated by PDCryptBatch… ) that a security handler must provide to support batch processing. These callbacks are part of a \sphinxcode{\sphinxupquote{PDCryptBatchHandler}} structure. The \sphinxcode{\sphinxupquote{PDCryptHandlerRec}} structure contains a new member \sphinxcode{\sphinxupquote{CryptBatchHandler}}, which points to this structure.

To support batch processing, a security handler should provide a non\sphinxhyphen{}NULL value for \sphinxcode{\sphinxupquote{CryptBatchHandler}} and implement the batch callbacks. Prior to Acrobat 5.0, the maximum length of the encryption key that Acrobat accepted was 40 bits. Acrobat version 5.0 or later accommodates an encryption key length of 128 bits. These length limitations are imposed to comply with export restrictions.


\subsubsection{Acrobat’s authorization procedure}
\label{\detokenize{Plugins_Security:acrobat-s-authorization-procedure}}
Acrobat’s built\sphinxhyphen{}in authorization procedure works as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Acrobat invokes the security handler’s authorize callback (which is either \sphinxcode{\sphinxupquote{PDCryptAuthorizeExProc}}, introduced with Acrobat 5.0, or the older \sphinxcode{\sphinxupquote{PDCryptAuthorizeProc}} ) to determine whether the user is allowed to open the file. It passes NULL authorization data, to handle the case where no authorization data is needed. Acrobat also passes the following values:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{PDPermReqObjDoc}} and \sphinxcode{\sphinxupquote{PDPermReqOprOpen}} when invoking \sphinxcode{\sphinxupquote{PDCryptAuthorizeExProc}}.

\item {} 
\sphinxcode{\sphinxupquote{pdPermOpen}} when calling \sphinxcode{\sphinxupquote{PDCryptAuthorizeProc}}.

\end{itemize}

\item {} 
If the authorize callback returns \sphinxcode{\sphinxupquote{true}}, the file is opened. Otherwise, the authorization procedure executes the following steps up to three times, to give the user three chances to enter a password, or whatever authorization the security handler uses.
\begin{itemize}
\item {} 
It calls the security handler’s get authorization data callback (\sphinxcode{\sphinxupquote{PDCryptGetAuthDataExProc}} or the older \sphinxcode{\sphinxupquote{PDCryptGetAuthDataProc)}}. This callback should obtain the authorization data using whatever user interface (for example, a dialog box used to obtain a password) or other means necessary, and then creates and fills the authorization data structure.

\item {} 
It calls the security handler’s authorize callback, passing the authorization data returned by the get authorization data callback. If the authorization succeeds, the authorize callback returns the permissions granted to the user, and the authorization procedure returns.

\end{itemize}

\end{enumerate}

The authorize callback can access the encrypted PDF document, allowing it to encrypt the authorization data using a mechanism that depends on the document’s contents. By doing this, someone who knows a document’s password cannot easily find out which other documents use the same password. The authorize callback can return permissions that depend on the password as well as the permissions specified when encryption was set up. This allows, for example, more rights to be granted to someone who knows a document’s owner password than to someone who knows the document’s user password.


\subsection{Opening a secured file}
\label{\detokenize{Plugins_Security:opening-a-secured-file}}
The Acrobat core API has several methods for opening files. The \sphinxcode{\sphinxupquote{PDDocOpen}} (or \sphinxcode{\sphinxupquote{PDDocOpenEx}} ) method is used to open PDF files, even when a plugin calls AV layer methods such as \sphinxcode{\sphinxupquote{AVDocOpenFromASFileWithParams}}. As a result, the sequence of operations is largely the same regardless of whether the document is being opened from the PD layer or from the AV layer. The difference is that if you call \sphinxcode{\sphinxupquote{PDDocOpen}} directly, you must pass your own authorization procedure (\sphinxcode{\sphinxupquote{PDAuthProc}} ), while AV layer methods always use Acrobat’s built\sphinxhyphen{}in authorization procedure.

The authorization procedure must implement the authorization strategy, such as giving the user three chances to enter a password. The \sphinxcode{\sphinxupquote{PDAuthProc}} is not part of a security handler, but it must call the security handler’s methods to authorize the user (for example, to get the password from the user and to check whether or not the password is valid).

Acrobat performs the following steps to open a secured PDF file:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Searches for an Encrypt key in the PDF document’s trailer, to determine whether or not the document is encrypted. If there is no Encrypt key, Acrobat opens the document immediately.

\item {} 
If there is an Encrypt key, its value is an encryption dictionary. Acrobat gets the value of the Filter key in the dictionary to determine which security handler was used when the file was saved. It looks in the list of registered security handlers (which contains Acrobat’s built\sphinxhyphen{}in handler and any handlers that plugins or applications have registered) for one whose name matches the name found in the PDF file. For information about a dictionary, see \sphinxhref{Plugins\_Cos.html\#50618418\_96656}{Working with Cos dictionaries}.

\item {} 
If Acrobat finds no match, indicating that the necessary handler could not be found, it does not open the document. If it finds a matching security handler, it invokes that handler’s P \sphinxcode{\sphinxupquote{DCryptNewSecurityDataProc}} callback to extract and decrypt information from the PDF file’s encryption dictionary.

\item {} 
Acrobat invokes the security handler’s authorize callback (\sphinxcode{\sphinxupquote{PDCryptAuthorizeExProc}} ) with NULL authorization data, and with the requested permissions set to \sphinxcode{\sphinxupquote{PDPermReqOprOpen}} or \sphinxcode{\sphinxupquote{pdPermOpen}} (requesting that the user be allowed to open the file). This allows support for authorization schemes that do not need authorization data.

\item {} 
If authorization succeeds, the handler’s authorization callback must return the \sphinxcode{\sphinxupquote{PDPermReqStatus}} (when the callback is \sphinxcode{\sphinxupquote{PDCryptAuthorizeExProc}} ) or \sphinxcode{\sphinxupquote{pdPermOpen}} (when the callback is \sphinxcode{\sphinxupquote{PDCryptAuthorizeProc}} ) indicating that the user is permitted to open the file.

\item {} 
If authorization fails, the authorization procedure passed in the call to open the \sphinxcode{\sphinxupquote{PDDoc}} is called.

\item {} 
If authorization still fails, the file is not opened.

\item {} 
If authorization succeeds, Acrobat calls the security handler’s \sphinxcode{\sphinxupquote{PDCryptNewCryptDataProc}} callback to create the decryption key that is used to decrypt the file. The \sphinxcode{\sphinxupquote{PDCryptNewCryptDataProc}} callback can construct the decryption key in any way it chooses, but generally performs some calculation based on the contents of the security data structure filled previously by the handler’s \sphinxcode{\sphinxupquote{PDCryptNewSecurityDataProc}} callback.

\end{enumerate}


\subsection{Saving a secured file}
\label{\detokenize{Plugins_Security:saving-a-secured-file}}
When saving a file, it is important to remember the following information:
\begin{itemize}
\item {} 
When a user selects document encryption for the first time or has selected a different security handler for an already encrypted file, the newly\sphinxhyphen{}selected handler does not take effect until the document is saved.

\item {} 
To be allowed to save a file, the user must have \sphinxcode{\sphinxupquote{PDPermReqOprModify}} or either \sphinxcode{\sphinxupquote{pdPermEdit}} or \sphinxcode{\sphinxupquote{pdPermEditNotes}} permission.

\item {} 
In Acrobat 5.0, a save operation forces a complete encrypted copy of the file to be written.

\end{itemize}

The following information is applicable to when a secured file is saved:
\begin{itemize}
\item {} 
If the file is being saved in an encrypted form for the first time or if a different security handler is selected, Acrobat calls the new security handler’s \sphinxcode{\sphinxupquote{PDCryptNewSecurityDataProc}} callback. This action creates a new copy of the new security handler’s security data structure.

\item {} 
If the file is saved in an encrypted form for the first time or if a different security handler is selected, Acrobat calls the new security handlerfs \sphinxcode{\sphinxupquote{PDCryptUpdateSecurityDataProc}} callback. This presents whatever user interface the security handler has for enabling the user to set permissions.

\item {} 
Acrobat invokes the new security handler’s \sphinxcode{\sphinxupquote{PDCryptFillEncryptDictProc}} callback to encrypt and write into the PDF file’s encryption dictionary whatever data the security handler wants to save in the PDF file.

\item {} 
Acrobat writes out the encrypted file.

\item {} 
Acrobat sets the new security handler as the document’s current security handler.

\end{itemize}


\section{Setting security for a document}
\label{\detokenize{Plugins_Security:setting-security-for-a-document}}
Acrobat calls the new security handler’s \sphinxcode{\sphinxupquote{PDCryptUpdateSecurityDataProc}} callback to present whatever user interface the security handler has for allowing the user to set security, passwords, and so forth.

When security is set, the security handler obtains the permissions and authorization data (such as passwords) to be used for the file. The settings do not take effect until the file is saved, as described in the previous section.


\subsection{Saving a file with an encryption dictionary}
\label{\detokenize{Plugins_Security:saving-a-file-with-an-encryption-dictionary}}
To save a file with a new encryption dictionary, use the following callbacks in the \sphinxcode{\sphinxupquote{PDCryptHandlerRec}} :
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{PDCryptNewSecurityDataProc}} creates and initializes a security data structure. It is called with \sphinxcode{\sphinxupquote{encryptDict}} (a Cos object) set either to NULL or to a valid encryption dictionary, in which case the fields of the encryption dictionary are read and placed into the security data structure. For information about a Cos object, see \sphinxhref{Plugins\_Cos.html\#50618418\_86959}{Working with Cos Objects}.

\item {} 
\sphinxcode{\sphinxupquote{PDCryptUpdateSecurityDataProc}} gets the current security data structure by invoking the \sphinxcode{\sphinxupquote{PDDocGetNewSecurityData}} method. It then makes a copy of the structure with which to work. This new copy is freed if an error or cancel condition is encountered. The user is requested to log in to their PKI infrastructure to access the user’s keys and certificates.

\end{enumerate}

If the security data structure was seeded with information from \sphinxcode{\sphinxupquote{encryptDict}}, an internal authorize procedure is called. This procedure decrypts and examines the data fields in the security data structure copy that are set to indicate the user’s permissions and, possibly, information relating to the document symmetric key.

A user interface is provided to enable your plugin to specify a list of recipients for the document. If all goes well, the \sphinxcode{\sphinxupquote{secDataP}} argument to \sphinxcode{\sphinxupquote{PDCryptUpdateSecurityDataProc}} is sent to the copy of the security data structure, and Acrobat frees the original security data structure.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{PDCryptFillEncryptDictProc}} writes data from the security data structure into the encryption dictionary. When Acrobat is done with the security data structure, it invokes the \sphinxcode{\sphinxupquote{PDCryptFreeSecurityDataPro}} c method.

\end{enumerate}


\subsection{Opening an encrypted file}
\label{\detokenize{Plugins_Security:opening-an-encrypted-file}}
The following callbacks are used when opening an encrypted file:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{PDCryptNewSecurityDataPr}} oc is invoked as described in the previous section.

\item {} 
\sphinxcode{\sphinxupquote{PDCryptAuthorizeExProc}} is invoked and returns NULL since the authorization permissions have not been determined. This callback should not present a user interface.

\item {} 
The plugin does not use the authorization data structure, but instead only the security data structure. It calls an internal authorization procedure that determines the authorization level of the logged\sphinxhyphen{}in user. This authorization procedure is the same procedure as is called by \sphinxcode{\sphinxupquote{PDCryptUpdateSecurityDataProc}} in the previous section.

\item {} 
\sphinxcode{\sphinxupquote{PDCryptAuthorizeEx}} or \sphinxcode{\sphinxupquote{PDCryptAuthorize}}. The authorization permissions have now been established (by the call to get the authorization data) and are returned. Acrobat opens the file.

\end{enumerate}


\chapter{Working with Unicode Paths}
\label{\detokenize{Plugins_Unicode:working-with-unicode-paths}}\label{\detokenize{Plugins_Unicode::doc}}
This chapter explains how to work with Acrobat or Adobe Reader’s support of Unicode paths. Using this feature, you can programmatically open and save Unicode\sphinxhyphen{}named files and select Unicode\sphinxhyphen{}named folders. You can, for example, enable a user to open a Unicode\sphinxhyphen{}named file and view the corresponding PDF document in Acrobat or Adobe Reader.


\section{About Unicode paths}
\label{\detokenize{Plugins_Unicode:about-unicode-paths}}
The Unicode file path feature takes effect when an end user selects a Unicode\sphinxhyphen{}named PDF file to open or save. This feature is also used when a Unicode\sphinxhyphen{}named file path is passed as an argument to an Acrobat core API method. However, this feature is in effect only when it is required. That is, when a non\sphinxhyphen{}Unicode file system is used, the Unicode path feature is not in effect. As a result, the Unicode file system is separate from the default file system, which is non\sphinxhyphen{}Unicode.

You can programmatically use this feature by obtaining a pointer to the Unicode file system \sphinxcode{\sphinxupquote{fileSys}} argument and then invoking a method that accepts the \sphinxcode{\sphinxupquote{fileSys}} argument. The Windows Unicode file system can be obtained by either invoking the \sphinxcode{\sphinxupquote{ASGetDefaultUnicodeFileSys}} method or by invoking the \sphinxcode{\sphinxupquote{ASFileGetFileSysByName}} method and passing either \sphinxcode{\sphinxupquote{ASAtomFromString("Win")}}.


\section{Creating Unicode file path application logic}
\label{\detokenize{Plugins_Unicode:creating-unicode-file-path-application-logic}}
When creating application logic that requires a file system argument (either a Unicode file system or the default file system), do not pass \sphinxcode{\sphinxupquote{Null}} and avoid invoking the \sphinxcode{\sphinxupquote{ASGetDefaultFileSys}} method. A file system argument must be provided along with the path name argument.

Never assume that the \sphinxcode{\sphinxupquote{ASPathName}} argument is a character pointer. Do not typecast any character value to an \sphinxcode{\sphinxupquote{ASPathName}}, and do not typecast a returned \sphinxcode{\sphinxupquote{ASPathName}} value to a character pointer. If you are passing an \sphinxcode{\sphinxupquote{ASPathName}} argument without a file system argument, then ensure that you add the file system argument.

Never assume that path and file names can be stored and passed as character pointers (\sphinxcode{\sphinxupquote{char}} \sphinxcode{\sphinxupquote{*}} values). If you have limited code that passes file names, then change them to an \sphinxcode{\sphinxupquote{ASText}} value or to something that is capable of storing a full Unicode path. If you have a lot of code that passes character pointer values as file names, then consider changing the internal representation of those character pointer values to UTF\sphinxhyphen{}8 encoded file names.

The following table lists Acrobat core API methods that should be replaced by newer methods in order to work with Unicode paths.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Old method
&\sphinxstyletheadfamily 
New method
\\
\hline
ASGetDefaultFileSys
&
ASGetDefaultFileSysForPath
\\
\hline
ASPathFromPlatformPath
&
ASFileSysCreatePathName
\\
\hline
ASPathFromPlatformPathEx
&
ASFileSysCreatePathName
\\
\hline
ASFileSysCreatePathName(“Cstring”)
&
ASFileSysCreatePathName(“ASTextPath”)
\\
\hline
ASFileSysCreatePathName(“Folder

PathName”)
&
ASFileSysCreatePathName(“FolderPathName

WithASText”)
\\
\hline
ASFileSysCreatePathName(“DIPath”)
&
ASFileSysCreatePathName(“DIPathWithAS

Text”)
\\
\hline
ASFileSysGetNameFromPath
&
ASFileSysGetNameFromPathAsASText
\\
\hline
ASFileSysDisplayStringFromPath
&
ASFileSysDisplayASTextFromPath
\\
\hline
ASFileSysDIPathFromPath
&
ASFileSysDIPathFromPathEx
\\
\hline
ASFileSysPathFromDIPath
&
ASFileSysPathFromDIPathEx
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

If you have Windows\sphinxhyphen{}specific application logic that uses \sphinxcode{\sphinxupquote{ASPlatformPathGetCstringPtr}} to get the native path name, invoke the \sphinxcode{\sphinxupquote{ASFileSysAcquirePlatformPath}} method and pass \sphinxcode{\sphinxupquote{WinUnicodePath}} as the \sphinxcode{\sphinxupquote{platformPathType}} argument. The \sphinxcode{\sphinxupquote{ASPlatformPathGetCstringPtr}} method will return an \sphinxcode{\sphinxupquote{ASUTF16}} path.

If you use any of the following methods \sphinxcode{\sphinxupquote{AVAppOpenDialog}}, \sphinxcode{\sphinxupquote{AVAppSaveDialog}}, \sphinxcode{\sphinxupquote{AVAppChooseFolderDialog}}, \sphinxcode{\sphinxupquote{CUIOpenDialog}}, \sphinxcode{\sphinxupquote{CUISaveDialog}}, or \sphinxcode{\sphinxupquote{CUIFolderDialog}} then ensure that the flag argument passed to these includes the \sphinxcode{\sphinxupquote{kAVOpenSaveAllowForeignFileSystems}} flag so the Unicode file system can be used. (See \sphinxhref{Plugins\_Documents.html\#50618416\_74021}{Opening a PDF document in an external window}.)


\section{Retrieving Unicode path values}
\label{\detokenize{Plugins_Unicode:retrieving-unicode-path-values}}
You can use the Acrobat core API to retrieve a Unicode path value. The Unicode file system is essentially the same as the classic Windows file system except that its \sphinxcode{\sphinxupquote{ASPathName}} object supports a few additional calls (through the file system call table) and the implementation uses the wide\sphinxhyphen{}char (Unicode) version of the Window’s APIs to access the native file system.

You can create an \sphinxcode{\sphinxupquote{ASPathName}} object by using one of the following methods:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ASFileSysCreatePathName}}

\item {} 
\sphinxcode{\sphinxupquote{ASFileSysPathFromDIPathEx}}

\end{itemize}

When you invoke either one of these methods, you must create an \sphinxcode{\sphinxupquote{ASFileSys}} object to use as an argument.


\subsection{Creating an ASFileSys object}
\label{\detokenize{Plugins_Unicode:creating-an-asfilesys-object}}
Regardless whether you are working with Unicode paths or non\sphinxhyphen{}Unicode paths, you must create an \sphinxcode{\sphinxupquote{ASFileSys}} object when performing tasks that manipulate files, such as opening a PDF file. An \sphinxcode{\sphinxupquote{ASFileSys}} object represents the file system in which the file that you are manipulating is located.

To create an \sphinxcode{\sphinxupquote{ASFileSys}} object, invoke the \sphinxcode{\sphinxupquote{ASGetDefaultFileSysForPath}} method and specify the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that defines the format of the \sphinxcode{\sphinxupquote{pathSpec}} argument (second argument). To create an \sphinxcode{\sphinxupquote{ASAtom}} object, invoke the \sphinxcode{\sphinxupquote{ASAtomFromString}} method and pass one of the following values:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DIPathWithASText}} if the \sphinxcode{\sphinxupquote{pathSpec}} is a \sphinxcode{\sphinxupquote{DIPath}} being passed to \sphinxcode{\sphinxupquote{ASFileSysPathFromDIPathEx}}.

\item {} 
\sphinxcode{\sphinxupquote{ASTextPath}} for Windows

\item {} 
\sphinxcode{\sphinxupquote{FSRef}}, \sphinxcode{\sphinxupquote{CFURLRef}}, \sphinxcode{\sphinxupquote{POSIXPath}}, \sphinxcode{\sphinxupquote{FSSpec}} or \sphinxcode{\sphinxupquote{Cstring}} for Mac OS

\end{itemize}

\item {} 
A void pointer that specifies the location of the file.

\end{itemize}

On Windows, the \sphinxcode{\sphinxupquote{ASGetDefaultFileSysForPath}} method checks the specified path values and decides if the classic default file system is used works or if the Unicode file system is used. On Mac OS, the default file system is always returned (because neither has a separate Unicode file system; Mac OS already supports Unicode\sphinxhyphen{}named paths).

The following code example creates an \sphinxcode{\sphinxupquote{ASFileSys}} object as part of the process of opening a PDF file. (See \sphinxhref{Plugins\_Documents.html\#50618416\_65430}{Opening PDF documents}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}if NOT\PYGZus{}USING\PYGZus{}UNICODE}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Specify} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{file} \PYG{n}{to} \PYG{n+nb}{open} \PYG{p}{(}\PYG{n}{host} \PYG{n}{encoded} \PYG{n}{names} \PYG{n}{only}\PYG{p}{)}
\PYG{o}{/}\PYG{o}{/}    \PYG{n}{const} \PYG{n}{char}\PYG{o}{*} \PYG{n}{myPath} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:PurchaseOrder.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{ASAtom} \PYG{n}{pathType} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ASTextPath}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{);}
\PYG{c+c1}{\PYGZsh{}else}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Specify} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{file} \PYG{n}{to} \PYG{n+nb}{open} \PYG{p}{(}\PYG{n}{Unicode}\PYG{p}{)}
\PYG{o}{/}\PYG{o}{/}    \PYG{n}{const} \PYG{n}{ASUns16}\PYG{o}{*} \PYG{n}{myPath} \PYG{o}{=} \PYG{n}{L}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:PurchaseOrder(assumeUnicodeCharacters).pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{ASAtom} \PYG{n}{pathType} \PYG{o}{=} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ASTextPath}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASText} \PYG{n+nb}{object}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{ASText} \PYG{n}{titleText} \PYG{o}{=} \PYG{n}{ASTextNew}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextSetPDText}\PYG{p}{(}\PYG{n}{titleText}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This PDF was opened by using the Acrobat SDK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASPathName} \PYG{n+nb}{object}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{ASFileSys} \PYG{n}{fileSys} \PYG{o}{=} \PYG{n}{ASGetDefaultFileSysForPath}\PYG{p}{(}\PYG{n}{pathType}\PYG{p}{,} \PYG{n}{myPath}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASPathName} \PYG{n}{pathName} \PYG{o}{=} \PYG{n}{ASFileSysCreatePathName}\PYG{p}{(}\PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{pathType}\PYG{p}{,} \PYG{n}{myPath}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Open} \PYG{n}{the} \PYG{n}{PDF} \PYG{n}{file}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{AVDoc} \PYG{n}{myDoc} \PYG{o}{=} \PYG{n}{AVDocOpenFromFile}\PYG{p}{(}\PYG{n}{pathName}\PYG{p}{,} \PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{titleText}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Do} \PYG{n}{some} \PYG{n}{clean} \PYG{n}{up}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{ASFileSysReleasePath}\PYG{p}{(}\PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{pathName}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASTextDestroy}\PYG{p}{(}\PYG{n}{titleText}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Creating an ASFileSys object that supports Unicode paths}
\label{\detokenize{Plugins_Unicode:creating-an-asfilesys-object-that-supports-unicode-paths}}
You can invoke the \sphinxcode{\sphinxupquote{ASGetDefaultUnicodeFileSys}} method to create an \sphinxcode{\sphinxupquote{ASFileSys}} object that represents a file system that supports Unicode paths. On Windows, this method returns an \sphinxcode{\sphinxupquote{ASFileSys}} object that uses Unicode paths. On Mac OS, this method returns the value that the \sphinxcode{\sphinxupquote{ASGetDefaultFileSys}} method returns because the Mac OS default file system already supports Unicode paths.

A Unicode file system can be retrieved by using the \sphinxcode{\sphinxupquote{ASFileGetFileSysByName}} method if you pass \sphinxcode{\sphinxupquote{Win}} (or \sphinxcode{\sphinxupquote{ASAtomFromString("Win"}} )) for the \sphinxcode{\sphinxupquote{ASAtom}} name argument.

As of Acrobat 8, a new \sphinxcode{\sphinxupquote{platformPathType}} type named \sphinxcode{\sphinxupquote{WinUnicodePath}} is supported. This is the Unicode version of the \sphinxcode{\sphinxupquote{Cstring platformPathType}} type. It is used to get the Unicode platform path on Windows.

\begin{sphinxadmonition}{note}{Note:}
The classic Windows file system supports both \sphinxcode{\sphinxupquote{Cstring}} and \sphinxcode{\sphinxupquote{WinUnicodePath}} in its implementation of the \sphinxcode{\sphinxupquote{ASFileSysAcquirePlatformPath}} and \sphinxcode{\sphinxupquote{ASPlatformPathGetCstringPtr}} methods.
\end{sphinxadmonition}

The SnippetRunner samples include a shared snippet named OpenUnicodeNamedDocSnip that demonstrates how to open a file with a Unicode (UTF\sphinxhyphen{}8) file name. The SnippetRunner samples are available at \sphinxhref{http://www.adobe.com/go/acrobat\_developer}{Acrobat Developer Center}.

The following code example retrieves the host encoded platform path on Windows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{char}\PYG{o}{*} \PYG{n}{path} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{ASPlatformPath} \PYG{n}{platformPath} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{result} \PYG{o}{=} \PYG{n}{ASFileSysAcquirePlatformPath}\PYG{p}{(}
\PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{pathName}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cstring}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{platformPath}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{result} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{platformPath} \PYG{o}{!=} \PYG{n}{NULL}\PYG{p}{)}
  \PYG{n}{path} \PYG{o}{=} \PYG{n}{ASPlatformPathGetCstringPtr}\PYG{p}{(}\PYG{n}{platformPath}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASFileSysReleasePlatformPath}\PYG{p}{(}\PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{platformPath}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In contrast, the following code example retrieves a Unicode platform path on Windows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASUTF16}\PYG{o}{*} \PYG{n}{path} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{ASPlatformPath} \PYG{n}{platformPath} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{result} \PYG{o}{=} \PYG{n}{ASFileSysAcquirePlatformPath}\PYG{p}{(}
\PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{pathName}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{WinUnicodePath}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{platformPath}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{result} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{platformPath} \PYG{o}{!=} \PYG{n}{NULL}\PYG{p}{)}
  \PYG{n}{path} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ASUTF16}\PYG{o}{*}\PYG{p}{)}\PYG{n}{ASPlatformPathGetCstringPtr}\PYG{p}{(}\PYG{n}{platformPath}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASFileSysReleasePlatformPath}\PYG{p}{(}\PYG{n}{fileSys}\PYG{p}{,} \PYG{n}{platformPath}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that the \sphinxcode{\sphinxupquote{ASPlatformPathGetCstringPtr}} method is still called to get the path string, but that a wide\sphinxhyphen{}char string is returned since \sphinxcode{\sphinxupquote{WinUnicodePath}} was passed to the \sphinxcode{\sphinxupquote{ASFileSysAcquirePlatformPath}} method.


\chapter{Working with Host Function Tables}
\label{\detokenize{Plugins_Hft:working-with-host-function-tables}}\label{\detokenize{Plugins_Hft::doc}}
A host function table (HFT) is the mechanism through which plugins and PDF Library applications invoke methods in Adobe Reader and Acrobat, as well as other plugins. Acrobat and Adobe Reader have HFTs containing pointers to all Acrobat core API methods. In addition, a plugin may create its own HFT to export its methods to other plugins. This chapter illustrates how to export and import HFTs.


\section{About host function tables}
\label{\detokenize{Plugins_Hft:about-host-function-tables}}
An HFT is a table of function pointers where each HFT contains the following information:
\begin{itemize}
\item {} 
A name

\item {} 
A version number

\item {} 
An array of one or more entries

\end{itemize}

Each entry represents a single method that a plugin can invoke, and is defined as a linked list of function pointers. Adobe Reader or Acrobat uses linked lists because some HFT entries may be marked so that they can be replaced by a plugin. Also, it is useful to keep a list of each implementation of a method that was replaced to allow methods to call the implementations they replaced.

The following diagram shows the relationship between Adobe Reader or Acrobat, other plugins, and HFTs.

\noindent\sphinxincludegraphics{{hft}.png}

Plugins must use the \sphinxcode{\sphinxupquote{ASExtensionMgrGetHFT}} method to import each HFT they intend to use. A plugin requests an HFT by its name and version number. An HFT is imported during plugin initialization. (See \sphinxhref{Plugins\_Pimech.html\#50618406\_19533}{Importing HFTs and registering for notifications}.)

When a plugin invokes a method in Adobe Reader, Acrobat, or another plugin, the function pointer at the appropriate location in the appropriate HFT is dereferenced and executed. Macros in the Acrobat SDK header files hide this functionality so that plugins contain only what appear to be normal function calls.

Each HFT is serviced by an HFT server. The HFT server is responsible for handling requests to obtain or destroy its HFT. As part of its responsibility to handle requests, an HFT server can choose to support multiple versions of the HFT. These versions generally correspond to versions of Acrobat, Adobe Reader or the plugin that exposes the HFT.

The ability to provide more than one version of an HFT improves backward\sphinxhyphen{}compatibility by allowing existing plugins to continue to work when new versions of Acrobat or Adobe Reader (or other plugins whose HFTs they use) become available. It is expected that HFT versions typically will differ only in the number, not the order, of methods they contain.


\section{Exporting host function tables}
\label{\detokenize{Plugins_Hft:exporting-host-function-tables}}
You can use the Acrobat core API to export HFTs that result in a plugin’s methods being available to other plugins. To export an HFT, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create the HFT methods that you want to make available to other plugins.

\item {} 
Create HFT method definitions.

\item {} 
Create HFT callback functions.

\item {} 
Create new HFTs.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
The remaining parts of this section examine each task in detail.
\end{sphinxadmonition}


\subsection{Creating HFT methods}
\label{\detokenize{Plugins_Hft:creating-hft-methods}}
The first step in exporting HFTs is to create the methods that will be exported and made available to other plugins. For the purpose of this discussion, assume that the following three methods exist.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{BeepOnceImplementation}\PYG{p}{(}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
     \PYG{n}{AVSysBeep} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
     \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{In the BeepOnce method.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
 \PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{BeepTwiceImplementation}\PYG{p}{(}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
     \PYG{n}{AVSysBeep} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
     \PYG{n}{AVSysBeep} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
     \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{In the BeepTwice method.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
 \PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{BeepNTimesImplementation}\PYG{p}{(}\PYG{n}{ASInt32} \PYG{n}{numtimes}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
     \PYG{n}{ASInt32} \PYG{n}{i}\PYG{p}{;}
     \PYG{k}{for} \PYG{p}{(}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numtimes}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
         \PYG{n}{AVSysBeep} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{In the BeepNTimes method.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Creating HFT method definitions}
\label{\detokenize{Plugins_Hft:creating-hft-method-definitions}}
When you invoke a method in an HFT, the methods are accessed through a function pointer. Part of the process of defining a function pointer through which HFT methods are accessed is to create an enumeration that specifies the index of each method that you want to include within an HFT. The following enumeration enables indexing into the HFT. Note that the first element is not used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{enum}
 \PYG{p}{\PYGZob{}}
 \PYG{n}{DUMMYBLANKSELECTOR}\PYG{p}{,} \PYG{o}{/}\PYG{o}{*} \PYG{l+m+mi}{0} \PYG{o}{*}\PYG{o}{/}
 \PYG{n}{BeepOnceSEL}\PYG{p}{,}    \PYG{o}{/}\PYG{o}{*} \PYG{l+m+mi}{1} \PYG{o}{*}\PYG{o}{/}
 \PYG{n}{BeepTwiceSEL}\PYG{p}{,} \PYG{o}{/}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{/}
 \PYG{n}{BeepNTimesSEL}\PYG{p}{,} \PYG{o}{/}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{*}\PYG{o}{/}
 \PYG{n}{NUMSELECTORSPlusOne} \PYG{o}{/}\PYG{o}{*} \PYG{l+m+mi}{4} \PYG{o}{*}\PYG{o}{/}
 \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The indexes are called selectors, hence the \sphinxcode{\sphinxupquote{SEL}} at the end of the method names. \sphinxcode{\sphinxupquote{BeepOnce}} is at index 1; \sphinxcode{\sphinxupquote{BeepTwice}}, at index 2; and \sphinxcode{\sphinxupquote{BeepNTimes}}, at index 3. You can specify the number of indexes in the HFT by defining the following statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}define NUMSELECTORS (NUMSELECTORSPlusOne \PYGZhy{} 1);}
\end{sphinxVerbatim}

Also declare a global \sphinxcode{\sphinxupquote{HFT}} object that is used in various tasks:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{extern} \PYG{n}{HFT} \PYG{n}{gMyHFT}
\end{sphinxVerbatim}

For example, to define an HFT method name, you must specify an HFT object. (See \sphinxhref{Plugins\_Hft.html\#50618412\_60887}{Defining an HFT method name}.)


\subsubsection{Defining function prototypes}
\label{\detokenize{Plugins_Hft:defining-function-prototypes}}
After you define an enumeration and an HFT object, you can define a function pointer for each method by using the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{typdef} \PYG{n}{ACCBPROTO1} \PYG{n}{return\PYGZus{}type} \PYG{p}{(}\PYG{n}{ACCBPROTO2}   \PYG{o}{*}\PYG{n}{function\PYGZus{}nameSELPROTO}\PYG{p}{)}\PYG{p}{(}\PYG{n}{parameters}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The following table describes this syntax.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

return\_type
&
The return type of the HFT method
\\
\hline
function\_name
&
The name of the HFT method
\\
\hline
parameters
&
The HFT method’s parameters with their types
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

For example, to define a function pointer to the \sphinxcode{\sphinxupquote{BeepNTimes}} method, specify the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{typedef} \PYG{n}{ACCBPROTO1} \PYG{n}{void} \PYG{p}{(}\PYG{n}{ACCBPROTO2} \PYG{o}{*}\PYG{n}{BeepNTimesSELPROTO}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ASInt32} \PYG{n}{numtimes}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{ACCBPROTO1}} and \sphinxcode{\sphinxupquote{ACCBPROTO2}} are macros whose definitions are platform\sphinxhyphen{}specific (for example, in Mac OS, \sphinxcode{\sphinxupquote{ACCBPROTO1}} is defined as \sphinxcode{\sphinxupquote{pascal}} ). \sphinxcode{\sphinxupquote{BeepNTimesSELPROTO}} specifies a pointer to the \sphinxcode{\sphinxupquote{BeepNTimes}} method. Without using these macros, you would have to use the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{typedef} \PYG{n}{void} \PYG{p}{(}\PYG{o}{*}\PYG{n}{func}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ASInt32} \PYG{n}{numtimes}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Defining an HFT method name}
\label{\detokenize{Plugins_Hft:defining-an-hft-method-name}}
You must specify a name for each method that is used to invoke the HFT method from other plugins. You can define an HFT method name by using the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}define method\PYGZus{}name (*((method\PYGZus{}nameSELPROTO)(HFTname [method\PYGZus{}nameSEL])))}
\end{sphinxVerbatim}

The following table describes this syntax.


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{Plugins_Hft:section-1}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

method\_name
&
The name of the HFT method that is used to invoke the method from external plugins
\\
\hline
HFTname
&
The name of the HFT object
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

For example, to define a method name for the \sphinxcode{\sphinxupquote{BeepNTimesImplementation}} method, specify the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}define BeepNTimes (*((BeepNTimesSELPROTO)(gMyHFT[BeepNTimesSEL])))}
\end{sphinxVerbatim}

This macro defines the symbol \sphinxcode{\sphinxupquote{BeepNTimes}}, which is the HFT method name. \sphinxcode{\sphinxupquote{gMyHFT{[}BeepNTimesSEL{]}}} is the function pointer obtained by indexing the HFT and \sphinxcode{\sphinxupquote{BeepNTimesSELPROTO}} casts the pointer to the right type. The end result is that the method can be invoked by specifying the HFT method name:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BeepNTimes}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

HFT method names and the implementation method names must be different to avoid conflict between the \sphinxcode{\sphinxupquote{\#define}} statement and the corresponding method name.


\subsection{Creating HFT callback functions}
\label{\detokenize{Plugins_Hft:creating-hft-callback-functions}}
You must create an HFT callback function in order to successfully export an HFT. It is recommended that you place the application logic to create an HFT callback in the \sphinxcode{\sphinxupquote{PluginExportHFTs}} method. This is a handshaking method that enables your plugin to export an HFT. For information about handshaking, see \sphinxhref{Plugins\_Pimech.html\#50618406\_89824}{Handshaking}.

To create an HFT callback function, declare an HFT \sphinxcode{\sphinxupquote{ServerProvideHFTProc}} object that represents the callback:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HFTServerProvideHFTProc} \PYG{n}{provideMyHFTCallback}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{HFTServerProvideHFTProc}} is a callback for an HFT server. After you create an \sphinxcode{\sphinxupquote{HFTServerProvideHFTProc}} object, you can invoke the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro to convert a user\sphinxhyphen{}defined function to an HFT callback function. For example, you can invoke \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} to convert a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{ProvideMyHFT}} to a callback function.

The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro requires the following arguments:
\begin{itemize}
\item {} 
The callback type. In this situation, specify \sphinxcode{\sphinxupquote{HFTServerProvideHFTProc}}.

\item {} 
The address of the user\sphinxhyphen{}defined function that you want to convert to a callback function.

\end{itemize}

The \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro returns a callback of the specified type that invokes the user\sphinxhyphen{}defined function whose address was passed as the second argument. The following lines of code show the \sphinxcode{\sphinxupquote{ASCallbackCreateProto}} macro converting the \sphinxcode{\sphinxupquote{ProvideMyHFT}} user\sphinxhyphen{}defined function to a \sphinxcode{\sphinxupquote{PDWordProc}} callback.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HFTServerProvideHFTProc} \PYG{n}{provideMyHFTCallback} \PYG{o}{=}
 \PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{HFTServerProvideHFTProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ProvideMyHFT}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The callback function is invoked when another plugin attempts to use the HFT. After you create an HFT callback function, you can invoke the \sphinxcode{\sphinxupquote{HFTServerNew}} method to obtain an HFT \sphinxcode{\sphinxupquote{Server}} object, which is responsible for handling requests to obtain or destroy its HFT. An \sphinxcode{\sphinxupquote{HFTServe}} r object is required in order to create a new \sphinxcode{\sphinxupquote{HFT}} object.

The \sphinxcode{\sphinxupquote{HFTServerNew}} method requires the following arguments:
\begin{itemize}
\item {} 
A character pointer that specifies the name of the HFT server. An HFT server name is used to import the HFT. (See \sphinxhref{Plugins\_Hft.html\#50618412\_72145}{Importing an existing HFT}.)

\item {} 
An \sphinxcode{\sphinxupquote{HFTServerProvideHFTProc}} object that specifies the HFT callback function.

\item {} 
An \sphinxcode{\sphinxupquote{HFTServerDestroyProc}} object that specifies the HFT callback function that releases memory from the HFT. This argument is optional and you can specify \sphinxcode{\sphinxupquote{NULL}}.

\item {} 
A pointer to user\sphinxhyphen{}supplied data to pass to the HFT server. This argument is optional and you can specify \sphinxcode{\sphinxupquote{NULL}}.

\end{itemize}

The following code example creates an HFT callback function within the \sphinxcode{\sphinxupquote{PluginExportHFTs}} method. After the \sphinxcode{\sphinxupquote{HFTServerProvideHFTProc}} object is created, the \sphinxcode{\sphinxupquote{HFTServerNew}} method is invoked which creates an \sphinxcode{\sphinxupquote{HFTServer}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginExportHFTs}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{n}{gMyHFT} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{gMyHFTServer} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{DURING}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{HFT} \PYG{n}{callback} \PYG{n}{function}
\PYG{o}{/}\PYG{o}{/}    \PYG{n}{provideMyHFTCallback} \PYG{o}{=} \PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{HFTServerProvideHFTProc}\PYG{p}{,}
  \PYG{o}{\PYGZam{}}\PYG{n}{ProvideMyHFT}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{HFT} \PYG{n}{server}
\PYG{o}{/}\PYG{o}{/}    \PYG{n}{gMyHFTServer} \PYG{o}{=} \PYG{n}{HFTServerNew}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyHFT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{provideMyHFTCallback}\PYG{p}{,}
  \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{HANDLER}
  \PYG{n}{gSomethingWentWrong}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
\PYG{n}{END\PYGZus{}HANDLER}
\PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In the previous code example, the \sphinxcode{\sphinxupquote{gMyHFT}}, \sphinxcode{\sphinxupquote{gMyHFTServer}}, and \sphinxcode{\sphinxupquote{gSomethingWentWrong}} variables are declared as global variables. To view the complete code example, including the location of where these global variables are declared, see \sphinxhref{Plugins\_Hft.html\#50618412\_55636}{Examining HFT header and source files}.
\end{sphinxadmonition}


\subsection{Creating new Host Function Tables}
\label{\detokenize{Plugins_Hft:creating-new-host-function-tables}}
You can create a new HFT by performing the following tasks within the HFT callback function that you define:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an \sphinxcode{\sphinxupquote{HFT}} object by invoking the \sphinxcode{\sphinxupquote{HFTNew}} method. This method requires an \sphinxcode{\sphinxupquote{HFTServer}} object and the number of entries in the new HFT as arguments. The number of entries determines how many methods that the HFT contains. Each method occupies one entry.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{HFTReplaceEntry}} method to populate the entries in the \sphinxcode{\sphinxupquote{HFT}} object with pointers to the HFT methods. This method requires the following arguments:
\begin{itemize}
\item {} 
An HFT object that you want to populate.

\item {} 
The entry in the \sphinxcode{\sphinxupquote{HFT}} object to replace. You can specify an index value that is specified in the enumeration that you created. For example, you can specify \sphinxcode{\sphinxupquote{BeepTwiceSEL}}. (See \sphinxhref{Plugins\_Hft.html\#50618412\_49266}{Creating HFT method definitions}.)

\item {} 
An \sphinxcode{\sphinxupquote{HFTEntry}} object that represents a method that will become available through the HFT. You can, for example, reference the \sphinxcode{\sphinxupquote{BeepTwiceImplementation}} method by passing the \sphinxcode{\sphinxupquote{ASCallbackCreateReplacement}} method, as shown in the following example:

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASCallbackCreateReplacement}\PYG{p}{(}\PYG{n}{BeepTwiceSEL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{BeepTwiceImplementation}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The new entry’s properties. Currently, only \sphinxcode{\sphinxupquote{HFTEntryReplaceable}} is defined.

\end{itemize}

You must invoke the \sphinxcode{\sphinxupquote{HFTReplaceEntry}} method for each method that you expose through the HFT. For example, if you expose three methods through the HFT, then you invoke the \sphinxcode{\sphinxupquote{HFTReplaceEntry}} method three times.

The following code example shows the syntax of the \sphinxcode{\sphinxupquote{ProvideMyHFT}} method, which is the HFT callback function defined in the previous section. Within this method, a new HFT is created. For information about HFT callback methods, see \sphinxhref{Plugins\_Hft.html\#50618412\_88064}{Creating HFT callback functions}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{HFT} \PYG{n}{ACCB2} \PYG{n}{ProvideMyHFT}\PYG{p}{(}\PYG{n}{HFTServer} \PYG{n}{server}\PYG{p}{,} \PYG{n}{ASUns32} \PYG{n}{version}\PYG{p}{,}\PYG{n}{void} \PYG{o}{*}\PYG{n}{rock}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Ensure} \PYG{n}{version} \PYG{o+ow}{is} \PYG{l+m+mi}{1}
\PYG{o}{/}\PYG{o}{/}    \PYG{k}{if} \PYG{p}{(}\PYG{n}{version} \PYG{o}{!=} \PYG{l+m+mi}{1}\PYG{p}{)}
      \PYG{k}{return} \PYG{n}{NULL}\PYG{p}{;}

  \PYG{n}{DURING}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{HFT}
\PYG{n}{gMyHFT} \PYG{o}{=} \PYG{n}{HFTNew}\PYG{p}{(}\PYG{n}{gMyHFTServer}\PYG{p}{,} \PYG{n}{NUMSELECTORS}\PYG{p}{)}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{*}
\PYG{o}{*}\PYG{o}{*} \PYG{n}{Replace} \PYG{n}{the} \PYG{n}{entries} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{HFT}
\PYG{o}{*}\PYG{o}{*} \PYG{k}{with} \PYG{n}{the} \PYG{n}{methods} \PYG{n}{that} \PYG{n}{you} \PYG{n}{want} \PYG{n}{to} \PYG{n}{make} \PYG{n}{available}\PYG{o}{.}
\PYG{o}{*}\PYG{o}{/}
\PYG{n}{HFTReplaceEntry} \PYG{p}{(}\PYG{n}{gMyHFT}\PYG{p}{,}

\PYG{n}{BeepOnceSEL}\PYG{p}{,}\PYG{n}{ASCallbackCreateReplacement}\PYG{p}{(}\PYG{n}{BeepOnceSEL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{BeepOnce}

\PYG{n}{Implementation}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{HFTReplaceEntry} \PYG{p}{(}\PYG{n}{gMyHFT}\PYG{p}{,}

\PYG{n}{BeepTwiceSEL}\PYG{p}{,}\PYG{n}{ASCallbackCreateReplacement}\PYG{p}{(}\PYG{n}{BeepTwiceSEL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{BeepTwice}

\PYG{n}{Implementation}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{HFTReplaceEntry} \PYG{p}{(}\PYG{n}{gMyHFT}\PYG{p}{,}

\PYG{n}{BeepNTimesSEL}\PYG{p}{,}\PYG{n}{ASCallbackCreateReplacement}\PYG{p}{(}\PYG{n}{BeepNTimesSEL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{BeepNTimes}

\PYG{n}{Implementation}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{HANDLER}
          \PYG{k}{return} \PYG{n}{NULL}\PYG{p}{;}

  \PYG{n}{END\PYGZus{}HANDLER}
\PYG{k}{return} \PYG{n}{gMyHFT}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Examining HFT header and source files}
\label{\detokenize{Plugins_Hft:examining-hft-header-and-source-files}}
To make it clear how to create HFTs, this section shows a typical header and source file that is used to create an HFT. All concepts that are discussed up to this point are shown.


\subsubsection{Examining an HFT header file}
\label{\detokenize{Plugins_Hft:examining-an-hft-header-file}}
The following code example shows the syntax of a header file named myhft.h that is used to define HFT constructs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}corcalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}avcalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}coscalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}pdcalls.h\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}ascalls.h\PYGZdq{}}

\PYG{n}{enum}
\PYG{p}{\PYGZob{}}
\PYG{n}{DUMMYBLANKSELECTOR}\PYG{p}{,}
\PYG{n}{BeepOnceSEL}\PYG{p}{,}
\PYG{n}{BeepTwiceSEL}\PYG{p}{,}
\PYG{n}{BeepNTimesSEL}\PYG{p}{,}
\PYG{n}{NUMSELECTORSPlusOne}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{extern} \PYG{n}{HFT} \PYG{n}{gMyHFT}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{}define NUMSELECTORS (NUMSELECTORSPlusOne \PYGZhy{} 1)}

\PYG{n}{typedef} \PYG{n}{ACCBPROTO1} \PYG{n}{void} \PYG{p}{(}\PYG{n}{ACCBPROTO2} \PYG{o}{*}\PYG{n}{BeepOnceSELPROTO}\PYG{p}{)}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{}define BeepOnce (*((BeepOnceSELPROTO)(gMyHFT[BeepOnceSEL])))}

\PYG{n}{typedef} \PYG{n}{ACCBPROTO1} \PYG{n}{void} \PYG{p}{(}\PYG{n}{ACCBPROTO2} \PYG{o}{*}\PYG{n}{BeepTwiceSELPROTO}\PYG{p}{)}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{}define BeepTwice (*((BeepTwiceSELPROTO)(gMyHFT[BeepTwiceSEL])))}

\PYG{n}{typedef} \PYG{n}{ACCBPROTO1} \PYG{n}{void} \PYG{p}{(}\PYG{n}{ACCBPROTO2} \PYG{o}{*}\PYG{n}{BeepNTimesSELPROTO}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ASInt32} \PYG{n}{numtimes}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{}define BeepNTimes (*((BeepNTimesSELPROTO)(gMyHFT[BeepNTimesSEL])))}
\PYG{o}{/}\PYG{o}{*} \PYG{n}{End} \PYG{n}{of} \PYG{n}{MyHFT}\PYG{o}{.}\PYG{n}{h} \PYG{o}{*}\PYG{o}{/}
\end{sphinxVerbatim}


\subsubsection{Examining an HFT source file}
\label{\detokenize{Plugins_Hft:examining-an-hft-source-file}}
The following code example shows the syntax of a source file used to create an HFT. Notice that the methods (\sphinxcode{\sphinxupquote{BeepOnceImplementation}}, \sphinxcode{\sphinxupquote{BeepTwiceImplementation}}, and \sphinxcode{\sphinxupquote{BeepNTimesImplementation}} ) that the HFT will make available to other plugins are defined. Also notice that the \sphinxcode{\sphinxupquote{PluginExportHFTs}} method is defined. For information about this method, see \sphinxhref{Plugins\_Pimech.html\#50618406\_19533}{Importing HFTs and registering for notifications}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{c+c1}{\PYGZsh{}include \PYGZdq{}corcalls.h\PYGZdq{}}
 \PYG{c+c1}{\PYGZsh{}include \PYGZdq{}avcalls.h\PYGZdq{}}
 \PYG{c+c1}{\PYGZsh{}include \PYGZdq{}coscalls.h\PYGZdq{}}
 \PYG{c+c1}{\PYGZsh{}include \PYGZdq{}pdcalls.h\PYGZdq{}}
 \PYG{c+c1}{\PYGZsh{}include \PYGZdq{}ascalls.h\PYGZdq{}}
 \PYG{c+c1}{\PYGZsh{}include \PYGZdq{}myhft.h\PYGZdq{}}


 \PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{k}{global} \PYG{n}{variables}
 \PYG{o}{/}\PYG{o}{/}   \PYG{n}{HFTServer} \PYG{n}{gMyHFTServer} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{HFT} \PYG{n}{gMyHFT} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

 \PYG{o}{/}\PYG{o}{*} \PYG{n}{The} \PYG{n}{implementation} \PYG{k}{for} \PYG{n}{the} \PYG{n}{BeepOnce}\PYG{p}{(}\PYG{p}{)} \PYG{n}{function}\PYG{o}{.} \PYG{n}{Note} \PYG{n}{it} \PYG{n}{has} \PYG{n}{a} \PYG{n}{different} \PYG{n}{name} \PYG{n}{than} \PYG{n}{the} \PYG{c+c1}{\PYGZsh{}define for the function in MyHFT.h */}

 \PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{BeepOnceImplementation} \PYG{p}{(}\PYG{p}{)}

 \PYG{p}{\PYGZob{}}
 \PYG{n}{AVSysBeep} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{In BeepOnceImplementation function.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{*} \PYG{n}{The} \PYG{n}{implementation} \PYG{k}{for} \PYG{n}{the} \PYG{n}{BeepTwice}\PYG{p}{(}\PYG{p}{)} \PYG{n}{function}\PYG{o}{.} \PYG{n}{Note} \PYG{n}{it} \PYG{n}{has} \PYG{n}{a} \PYG{n}{different} \PYG{n}{name} \PYG{n}{than} \PYG{n}{the} \PYG{c+c1}{\PYGZsh{}define for the function in MyHFT.h*/}
 \PYG{o}{/}\PYG{o}{/}   \PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{BeepTwiceImplementation}\PYG{p}{(}\PYG{p}{)}

 \PYG{p}{\PYGZob{}}
 \PYG{n}{AVSysBeep} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{AVSysBeep} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{In BeepTwiceImplementation function.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}

 \PYG{o}{/}\PYG{o}{*} \PYG{n}{The} \PYG{n}{implementation} \PYG{k}{for} \PYG{n}{the} \PYG{n}{BeepNTimes}\PYG{p}{(}\PYG{p}{)} \PYG{n}{function}\PYG{o}{.} \PYG{n}{Note} \PYG{n}{it} \PYG{n}{has} \PYG{n}{a}
 \PYG{o}{*}\PYG{o}{*} \PYG{n}{different} \PYG{n}{name} \PYG{n}{than} \PYG{n}{the} \PYG{c+c1}{\PYGZsh{}define for the function in MyHFT.h}
 \PYG{o}{*}\PYG{o}{/}
 \PYG{n}{ACCB1} \PYG{n}{void} \PYG{n}{ACCB2} \PYG{n}{BeepNTimesImplementation} \PYG{p}{(}\PYG{n}{ASInt32} \PYG{n}{numtimes}\PYG{p}{)}

 \PYG{p}{\PYGZob{}}
   \PYG{n}{ASInt32} \PYG{n}{i}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numtimes}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
       \PYG{n}{AVSysBeep} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
       \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{In BeepNTimesImplementation function.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}

    \PYG{o}{/}\PYG{o}{*}
    \PYG{o}{*}\PYG{o}{*} \PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{HFT} \PYG{n}{of} \PYG{n}{NUMSELECTORS} \PYG{n}{entries}
    \PYG{o}{*}\PYG{o}{*} \PYG{n}{Then} \PYG{n}{put} \PYG{n}{the} \PYG{n}{methods} \PYG{n}{into} \PYG{n}{the} \PYG{n}{table} \PYG{n}{via} \PYG{n}{HFTReplaceEntry}
    \PYG{o}{*}\PYG{o}{/}
 \PYG{n}{ACCB1} \PYG{n}{HFT} \PYG{n}{ACCB2} \PYG{n}{ProvideMyHFT}\PYG{p}{(}\PYG{n}{HFTServer} \PYG{n}{server}\PYG{p}{,} \PYG{n}{ASUns32} \PYG{n}{version}\PYG{p}{,}\PYG{n}{void} \PYG{o}{*}\PYG{n}{rock}\PYG{p}{)}

 \PYG{p}{\PYGZob{}}
 \PYG{n}{ACCB1} \PYG{n}{HFT} \PYG{n}{ACCB2} \PYG{n}{ProvideMyHFT}\PYG{p}{(}\PYG{n}{HFTServer} \PYG{n}{server}\PYG{p}{,} \PYG{n}{ASUns32} \PYG{n}{version}\PYG{p}{,}\PYG{n}{void} \PYG{o}{*}\PYG{n}{rock}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Ensure} \PYG{n}{version} \PYG{o+ow}{is} \PYG{l+m+mi}{1}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{version} \PYG{o}{!=} \PYG{l+m+mi}{1}\PYG{p}{)}
       \PYG{k}{return} \PYG{n}{NULL}\PYG{p}{;}

   \PYG{n}{DURING}

       \PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{HFT}
       \PYG{n}{gMyHFT} \PYG{o}{=} \PYG{n}{HFTNew}\PYG{p}{(}\PYG{n}{gMyHFTServer}\PYG{p}{,} \PYG{n}{NUMSELECTORS}\PYG{p}{)}\PYG{p}{;}

       \PYG{o}{/}\PYG{o}{*}
       \PYG{o}{*}\PYG{o}{*} \PYG{n}{Replace} \PYG{n}{the} \PYG{n}{entries} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{HFT}
       \PYG{o}{*}\PYG{o}{*} \PYG{k}{with} \PYG{n}{the} \PYG{n}{methods} \PYG{n}{that} \PYG{n}{you} \PYG{n}{want} \PYG{n}{to} \PYG{n}{make} \PYG{n}{available}\PYG{o}{.}
       \PYG{o}{*}\PYG{o}{/}
       \PYG{n}{HFTReplaceEntry} \PYG{p}{(}\PYG{n}{gMyHFT}\PYG{p}{,}

 \PYG{n}{BeepOnceSEL}\PYG{p}{,}\PYG{n}{ASCallbackCreateReplacement}\PYG{p}{(}\PYG{n}{BeepOnceSEL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{BeepOnce}

 \PYG{n}{Implementation}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
       \PYG{n}{HFTReplaceEntry} \PYG{p}{(}\PYG{n}{gMyHFT}\PYG{p}{,}

 \PYG{n}{BeepTwiceSEL}\PYG{p}{,}\PYG{n}{ASCallbackCreateReplacement}\PYG{p}{(}\PYG{n}{BeepTwiceSEL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{BeepTwice}

 \PYG{n}{Implementation}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
       \PYG{n}{HFTReplaceEntry} \PYG{p}{(}\PYG{n}{gMyHFT}\PYG{p}{,}

 \PYG{n}{BeepNTimesSEL}\PYG{p}{,}\PYG{n}{ASCallbackCreateReplacement}\PYG{p}{(}\PYG{n}{BeepNTimesSEL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{BeepNTimes}

 \PYG{n}{Implementation}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{HANDLER}
           \PYG{k}{return} \PYG{n}{NULL}\PYG{p}{;}
   \PYG{n}{END\PYGZus{}HANDLER}
   \PYG{k}{return} \PYG{n}{gMyHFT}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}

 \PYG{o}{/}\PYG{o}{*}
 \PYG{o}{*}\PYG{o}{*} \PYG{n}{Called} \PYG{n}{by} \PYG{n}{viewer} \PYG{n}{to} \PYG{n+nb}{set} \PYG{n}{up} \PYG{k}{for} \PYG{n}{exporting} \PYG{n}{an} \PYG{n}{HFT}\PYG{o}{.} \PYG{n}{This} \PYG{n}{method}
 \PYG{o}{*}\PYG{o}{*} \PYG{n}{creates} \PYG{n}{a} \PYG{n}{new} \PYG{n}{HFT} \PYG{n}{server} \PYG{o+ow}{and} \PYG{n}{provides} \PYG{n}{a} \PYG{n}{callback} \PYG{n}{that} \PYG{n}{provides} \PYG{n}{the} \PYG{n}{HFT}\PYG{o}{.}
 \PYG{o}{*}\PYG{o}{/}
 \PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginExportHFTs}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}

 \PYG{p}{\PYGZob{}}
 \PYG{n}{gMyHFTServer} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{DURING}


 \PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{HFT} \PYG{n}{callback} \PYG{n}{function}
 \PYG{o}{/}\PYG{o}{/}    \PYG{n}{HFTServerProvideHFTProc} \PYG{n}{provideMyHFTCallback} \PYG{o}{=}
   \PYG{n}{ASCallbackCreateProto}\PYG{p}{(}\PYG{n}{HFTServerProvideHFTProc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ProvideMyHFT}\PYG{p}{)}\PYG{p}{;}


 \PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{HFT} \PYG{n}{server}
 \PYG{o}{/}\PYG{o}{/}    \PYG{n}{gMyHFTServer} \PYG{o}{=} \PYG{n}{HFTServerNew}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyHFT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{provideMyHFTCallback}\PYG{p}{,}\PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}

 \PYG{n}{HANDLER}
   \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
 \PYG{n}{END\PYGZus{}HANDLER}
 \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Importing an existing HFT}
\label{\detokenize{Plugins_Hft:importing-an-existing-hft}}
You must import an existing HFT to invoke methods that are exposed through the HFT. To import an existing HFT, you must invoke the \sphinxcode{\sphinxupquote{ASExtensionMgrGetHFT}} method within the \sphinxcode{\sphinxupquote{PluginImportReplaceAndRegister}} handshaking method. The \sphinxcode{\sphinxupquote{ASExtensionMgrGetHFT}} method requires the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that specifies the HFT server that corresponds to the HFT to import

\item {} 
An \sphinxcode{\sphinxupquote{ASVersion}} object that specifies the version of the HFT

\end{itemize}

The \sphinxcode{\sphinxupquote{ASExtensionMgrGetHFT}} method returns an \sphinxcode{\sphinxupquote{HFT}} object. The following code example shows the \sphinxcode{\sphinxupquote{PluginImportReplaceAndRegister}} handshaking method that contains application logic that imports the \sphinxcode{\sphinxupquote{MyHFT}} HFT.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginImportReplaceAndRegister}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{gMyHFT} \PYG{o}{=} \PYG{n}{ASExtensionMgrGetHFT}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyHFT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{p}{(}\PYG{n}{gMyHFT} \PYG{o}{!=} \PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Both the exporting and importing plugins must be located in Acrobat or Adobe Reader’s plugins directory. If the exporting plugin is not located in this directory, the importing plugin cannot successfully import an HFT.
\end{sphinxadmonition}


\section{Invoking HFT methods}
\label{\detokenize{Plugins_Hft:invoking-hft-methods}}
After you import an HFT, you can invoke a method that it has made available. For example, after you import the \sphinxcode{\sphinxupquote{MyHFT}} HFT, you can invoke the following methods:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{BeepOnce}}

\item {} 
\sphinxcode{\sphinxupquote{BeepTwice}}

\item {} 
\sphinxcode{\sphinxupquote{BeepNTimes}}

\end{itemize}

However, you must include the header file that defines the HFT method name in the source file in which an HFT method is invoked. Because the above methods are declared in a header file named myhft.h, you must specify the following statement to successfully invoke these methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}myhft.h\PYGZdq{}}
\end{sphinxVerbatim}

If you do not include the appropriate header file, you will receive a compile error.


\section{Replacing HFT methods}
\label{\detokenize{Plugins_Hft:replacing-hft-methods}}
You can use the Acrobat core API to replace methods that are located in existing HFTs. For example, a plugin could use this mechanism to change the appearance of all alert boxes displayed by Acrobat or Adobe Reader, or to override file opening behavior.

The following table lists all the replaceable Acrobat and Adobe Reader methods.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{AVAlert}}
&
\sphinxcode{\sphinxupquote{AVAppCanQuit}}
\\
\hline
\sphinxcode{\sphinxupquote{AVAppChooseFolderDialog}}
&
\sphinxcode{\sphinxupquote{AVAppHandleAppleEvent}}
\\
\hline
\sphinxcode{\sphinxupquote{AVAppOpenDialog}}
&
\sphinxcode{\sphinxupquote{AVAppSaveDialog}}
\\
\hline
AVDocClose
&
AVDocDoPrint
\\
\hline
\sphinxcode{\sphinxupquote{AVDocDoSave}}
&
\sphinxcode{\sphinxupquote{AVDocDoSaveAs}}

(not replaceable in Adobe Reader)
\\
\hline
\sphinxcode{\sphinxupquote{AVDocDoSaveAsWithParams}}

(not replaceable in Adobe Reader)
&
\sphinxcode{\sphinxupquote{AVDocOpenFromASFileWithParams}}
\\
\hline
\sphinxcode{\sphinxupquote{AVDocPrintPages}}
&
\sphinxcode{\sphinxupquote{AVDocPrintPagesWithParams}}
\\
\hline
\sphinxcode{\sphinxupquote{AVPageViewGetNextView}}
&
\sphinxcode{\sphinxupquote{PDDocSave}}

(not replaceable in Adobe Reader)
\\
\hline
\sphinxcode{\sphinxupquote{PDDocSaveWithParams}}

(not replaceable in Adobe Reader)
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

To replace one of these methods, a plugin invokes the \sphinxcode{\sphinxupquote{HFTReplaceEntry}} method. In some cases, when the replacement method is finished executing, it should invoke the previous implementation of the method, using the \sphinxcode{\sphinxupquote{CALL\_REPLACED\_PROC}} macro, to allow previously\sphinxhyphen{}registered implementations of the method (including Acrobat and Adobe Reader’s built\sphinxhyphen{}in implementation) to execute. Previous implementations of the method are not invoked automatically; it is up to the replacement implementation to invoke them.

When you replace an Acrobat HFT method, the replaced method is available from other plugins. For example, assume you replace the \sphinxcode{\sphinxupquote{AVAlert}} method. When other plugins invoke the \sphinxcode{\sphinxupquote{AVAlert}} method, the replacement version of \sphinxcode{\sphinxupquote{AVAlert}} is invoked.

When an HFT entry is replaced, the entry’s linked list is updated so that the newly\sphinxhyphen{}added implementation is at the head of the linked list. Previous implementations, if any, follow in order, as shown in the following diagram.

\noindent\sphinxincludegraphics{{hftreplace}.png}

To replace an HFT method, perform the following tasks:
\begin{itemize}
\item {} 
Invoke the \sphinxcode{\sphinxupquote{ASCallbackCreateReplacement}} macro to create the callback pointer.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{REPLACE}} macro to replace the desired method and pass the following arguments:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{HFT}} object in which the method is replaced.

\item {} 
The entry in the HFT to replace. Append SEL to the method’s name. For example, to replace the \sphinxcode{\sphinxupquote{AVAppCanQuit}} method, specify \sphinxcode{\sphinxupquote{AVAppCanQuitSEL}}.

\item {} 
The address of the replacement method.

\end{itemize}

\end{itemize}

The following example shows how to replace the \sphinxcode{\sphinxupquote{AVAppCanQuit}} method with a custom method named \sphinxcode{\sphinxupquote{MyAvAppCanQuit}}. The \sphinxcode{\sphinxupquote{MyAVAppCanQuit}} method’s arguments and return value are identical to those of the \sphinxcode{\sphinxupquote{AVAppCanQuit}} method. Replaceable methods must be replaced with methods that have the same arguments and return type.

The first statement in the following code example initializes a global pointer named \sphinxcode{\sphinxupquote{gMyAVAppCanQuitPtr}} to your replacement method. You can use this pointer to invoke the original method. For example, you can invoke your replacement method to exhibit custom functionality and then invoke the original method. To invoke the original method, use the \sphinxcode{\sphinxupquote{CALL\_REPLACED\_PROC}} macro and pass the pointer to your replacement method. For more information about this macro, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void}\PYG{o}{*} \PYG{n}{gMyAVAppCanQuitPtr} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{*}
\PYG{o}{*}\PYG{o}{*} \PYG{n}{A} \PYG{n}{function} \PYG{n}{that} \PYG{n}{informs} \PYG{n}{the} \PYG{n}{application} \PYG{n}{whether} \PYG{n}{it}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s OK to quit.}
\PYG{o}{*}\PYG{o}{*} \PYG{n}{When} \PYG{n}{quitting}\PYG{p}{,} \PYG{n}{only} \PYG{n}{allow} \PYG{n}{exit} \PYG{n}{when} \PYG{n+nb}{all} \PYG{n}{docs} \PYG{n}{are} \PYG{n}{closed}\PYG{o}{.}
\PYG{o}{*}\PYG{o}{/}

\PYG{o}{/}\PYG{o}{/}   \PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{MyAVAppCanQuit} \PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{AVAppGetNumDocs} \PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{true}\PYG{p}{;}
\PYG{k}{else}
  \PYG{k}{return} \PYG{n}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{void} \PYG{n}{ReplaceAVAppCanQuit} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{n}{DURING}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{the} \PYG{n}{callback}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{gMyAVAppCanQuitPtr} \PYG{o}{=}
\PYG{n}{ASCallbackCreateReplacement} \PYG{p}{(}\PYG{n}{AVAppCanQuitSEL}\PYG{p}{,}
\PYG{o}{\PYGZam{}}\PYG{n}{MyAVAppCanQuit}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Invoke} \PYG{n}{the} \PYG{n}{Replace} \PYG{n}{macro}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{REPLACE} \PYG{p}{(}\PYG{n}{gMyHFT}\PYG{p}{,} \PYG{n}{AVAppCanQuitSEL}\PYG{p}{,} \PYG{n}{gMyAVAppCanQuitPtr}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{HANDLER}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Trying to replace AVAppCanQuit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{END\PYGZus{}HANDLER}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In the previous code example, an \sphinxcode{\sphinxupquote{HFT}} object named \sphinxcode{\sphinxupquote{gMyHTF}} is passed to the \sphinxcode{\sphinxupquote{REPLACE}} macro. To execute this example, you must create this object. (See \sphinxhref{Plugins\_Hft.html\#50618412\_31298}{Exporting host function tables}.)
\end{sphinxadmonition}


\section{Migrating non\sphinxhyphen{}HFT PDF Library applications to HFT applications}
\label{\detokenize{Plugins_Hft:migrating-non-hft-pdf-library-applications-to-hft-applications}}
In previous versions of Acrobat, a PDF Library application did not support use of HFTs. However, as of Acrobat 8, PDF Library applications are able to link to the PDF Library DLL file using HFTs. As a result, the PDF Library API is more closely aligned to the Acrobat core API.

You can migrate existing non\sphinxhyphen{}HFT PDF Library applications to HFT PDF Library applications by performing the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Change your project settings from \sphinxcode{\sphinxupquote{PRODUCT}} \sphinxcode{\sphinxupquote{=}} “\sphinxcode{\sphinxupquote{Library.h}} ” to \sphinxcode{\sphinxupquote{PRODUCT}} \sphinxcode{\sphinxupquote{=}} “\sphinxcode{\sphinxupquote{HFTLibrary.h}} ” (the header files include the necessary code to translate from direct calls into calls though HFTs).

\item {} 
Add the following files to your PDF Library application: PDFLInitHFT.c and PDFLInitCommon.c.

\item {} 
Compile and link your project with the new source files (PDFLInitHFT.c and PDFLInitCommon.c).

\item {} 
Invoke the \sphinxcode{\sphinxupquote{PDFLInitHFT}} method instead of the \sphinxcode{\sphinxupquote{PDFLInit}} to initialize the HFT mechanism and the PDF Library. The PDFLInitHFT method is defined in PDFLInitHFT.c file and the prototype for this function is defined in PDFInit.h along with the prototype for the \sphinxcode{\sphinxupquote{PDFLInit}} method. The \sphinxcode{\sphinxupquote{PDFLInitHFT}} method can be called more than once and a count of the initializations will be maintained by PDF Library.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{PDFLTermHFT}} method instead of the \sphinxcode{\sphinxupquote{PDFLTerm}} method to shutdown the HFT mechanism and PDF Library. The \sphinxcode{\sphinxupquote{PDFLTermHFT}} method is defined in the PDFLInitHFT.c file. The prototype for this function is defined in the PDFInit.h file along with the prototype of the \sphinxcode{\sphinxupquote{PDFLTerm}} method. In case of multiple initializations, the library shuts down after the number of terminations matches the number of initializations.

\end{enumerate}

The following table lists PDF Library API methods that should be changed to newer methods when working with HFTs.


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{Plugins_Hft:section-3}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Old method
&\sphinxstyletheadfamily 
New method
\\
\hline
ASSecs
&
ASGetDefaultFileSysForPath
\\
\hline
ASPushExceptionFrame
&
ACPushExceptionFrame
\\
\hline
ASPopExceptionFrame
&
ACPopExceptionFrame
\\
\hline
ASGetExceptionErrorCode
&
ACGetExceptionErrorCode
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
Other PDF Library API methods will work as is without any code change.
\end{sphinxadmonition}


\chapter{Working with Cos Objects}
\label{\detokenize{Plugins_Cos:working-with-cos-objects}}\label{\detokenize{Plugins_Cos::doc}}
A PDF file is structured as a tree of low\sphinxhyphen{}level objects, called Cos objects. Cos objects form all PDF document components, such as bookmarks, pages, fonts, images, and annotations. The Acrobat core API contains methods (the Cos layer) that enable you to operate directly on these low\sphinxhyphen{}level objects. You may encounter a situation where you want to perform a task that is not supported by using AV and PD layer methods. In such a situation, it is necessary to use Cos methods.

For example, the \sphinxhref{Plugins\_Annotations.html\#50618420\_98126}{Creating Annotations} chapter explains how to set text annotations properties by using \sphinxcode{\sphinxupquote{PDTextAnnot}} methods. Some newer types of annotations, such as 3D annotations, have properties that cannot be accessed directly by PD layer methods. As a result, you must use Cos layer methods to access the PDF dictionary that represents the annotation. (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_43763}{Creating 3D Annotations}.)

\begin{sphinxadmonition}{caution}{Caution:}
Care is required when working with Cos objects. Unlike using AV and PD objects, Cos objects can produce invalid PDF files. Before working with Cos objects, it is strongly recommended that you be familiar with concepts such as resource dictionaries as discussed in the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}
\end{sphinxadmonition}


\section{About Cos objects}
\label{\detokenize{Plugins_Cos:about-cos-objects}}
PDF files contain various Cos object types. In addition to basic data types such as integer, fixed, and Boolean values, Cos objects also contain the following object types:
\begin{itemize}
\item {} 
Array

\item {} 
Dictionary

\item {} 
Name

\item {} 
String

\item {} 
Stream

\end{itemize}


\subsection{About direct and indirect objects}
\label{\detokenize{Plugins_Cos:about-direct-and-indirect-objects}}
You can create Cos objects as either direct or indirect objects; the choice is specified as a parameter to the method that creates the object. A direct object is placed directly into another object (such as an array or dictionary). Direct objects cannot be shared between two or more dictionaries or arrays. An indirect object is labeled so that it can be referenced by other objects multiple times. The following is the syntax of an indirect object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{object} \PYG{n}{number}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{generation} \PYG{n}{number}\PYG{o}{\PYGZgt{}} \PYG{n}{obj}
    \PYG{o}{\PYGZlt{}}\PYG{n}{direct} \PYG{n+nb}{object}\PYG{o}{\PYGZgt{}}
\PYG{n}{endobj}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{<object number>}} \sphinxcode{\sphinxupquote{<generation number>}} is known as an indirect object identifier. An object referencing another indirect object uses the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{object} \PYG{n}{number}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{generation} \PYG{n}{number}\PYG{o}{\PYGZgt{}}
\PYG{n}{R}
\end{sphinxVerbatim}

This reference is equivalent to the direct object represented by the indirect object.

This example shows indirect object 6, followed by a reference to it in indirect object 7.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{l+m+mi}{6} \PYG{l+m+mi}{0} \PYG{n}{obj}
      \PYG{p}{(}\PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{string}\PYG{p}{)}
  \PYG{n}{endobj}

  \PYG{l+m+mi}{7} \PYG{l+m+mi}{0} \PYG{n}{obj}
    \PYG{p}{[} \PYG{l+m+mi}{6} \PYG{l+m+mi}{0} \PYG{n}{R} \PYG{p}{]} \PYG{o}{\PYGZpc{}}\PYG{n}{An} \PYG{n}{array} \PYG{k}{with} \PYG{n}{one} \PYG{n}{element} \PYG{n}{that} \PYG{o+ow}{is} \PYG{n}{indirect} \PYG{n+nb}{object} \PYG{l+m+mi}{6}
\PYG{n}{endobj}
\end{sphinxVerbatim}

If you were to retrieve the zeroth element in the array represented by object 7, you would get the Cos object that represents this string value:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{string}
\end{sphinxVerbatim}

On the other hand, in the following definition of indirect object 8, the elements of the array are all direct objects (the integer objects, 1, 2, and 3).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8} \PYG{l+m+mi}{0} \PYG{n}{obj}
    \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{endobj}
\end{sphinxVerbatim}


\subsection{About Cos object types}
\label{\detokenize{Plugins_Cos:about-cos-object-types}}
Two API objects exist in the Cos layer:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CosDoc}}, which represents an entire PDF file.

\item {} 
\sphinxcode{\sphinxupquote{CosObj}}, which represents all the individual object types, such as a Cos string, described in this section. There are various methods to create the different types of Cos objects mentioned in this section, as well as getting and setting their values.

\end{itemize}


\subsubsection{Cos strings}
\label{\detokenize{Plugins_Cos:cos-strings}}
A string object consists of a series of bytes—unsigned integer values in the range 0 to 255. The string elements are not integer objects, but are stored in a more compact format. String objects can be written in the following ways:
\begin{itemize}
\item {} 
As a sequence of literal characters enclosed in parentheses

\item {} 
As hexadecimal data enclosed in angle brackets

\end{itemize}


\paragraph{Literal strings}
\label{\detokenize{Plugins_Cos:literal-strings}}
A literal string is written as an arbitrary number of characters enclosed in parentheses. Any characters may appear in a string except unbalanced parentheses and the backslashes, which must be treated specially. Balanced pairs of parentheses within a string require no special treatment.

The following are examples of literal strings:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(This is a string)
(Strings may contain newlines
and such)
(Strings may contain balanced parentheses ( ) and
special characters (*!\PYGZam{}\PYGZcb{}\PYGZca{}\PYGZpc{} and so on).)
(The following is an empty string.)
()
(It has zero (0) length.)
\end{sphinxVerbatim}

Within a literal string, the backslash () is used as an escape character for various purposes, such as including newline characters, nonprinting ASCII characters, unbalanced parentheses, or the backslash character itself in the string. The character immediately following the backslash determines its precise interpretation. If the character following the backslash is not one of those shown in the following table, the backslash is ignored. The following table shows valid literal string escape sequences.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Escape sequence
&\sphinxstyletheadfamily 
Description
\\
\hline
n
&
Line feed (LF)
\\
\hline
r
&
Carriage return (CR)
\\
\hline
t
&
Horizontal tab (HT)
\\
\hline
b
&
Backspace (BS)
\\
\hline
f
&
Form feed (FF)
\\
\hline
(
&
Left parenthesis
\\
\hline
)
&
Right parenthesis
\\
\hline

&
Backslash
\\
\hline
ddd
&
Character code ddd (octal)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

If a string is too long to be conveniently placed on a single line, it may be split across multiple lines by using the backslash character at the end of a line to indicate that the string continues on the following line. The backslash and the end\sphinxhyphen{}of\sphinxhyphen{}line marker following it are not considered part of the string. For example, the following strings examples are equivalent:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{These} \PYG{n}{two} \PYG{n}{strings} \PYG{n}{are} \PYG{n}{the} \PYG{n}{same}\PYG{o}{.}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{These} \PYG{n}{two} \PYG{n}{strings} \PYG{n}{are} \PYG{n}{the} \PYG{n}{same}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Hexadecimal strings}
\label{\detokenize{Plugins_Cos:hexadecimal-strings}}
Strings may also be written in hexadecimal form, which is useful for including arbitrary binary data in a PDF file. A hexadecimal string is written as a sequence of hexadecimal digits (0–9 and either A–F or a–f) enclosed within angle brackets (< and >). Consider the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{4E6}\PYG{n}{F762073686D6F7A206B6120706F702E} \PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Each pair of hexadecimal digits defines one byte of the string. White\sphinxhyphen{}space characters (such as space, tab, carriage return, line feed, and form feed) are ignored. If the final digit of a hexadecimal string is missing, that is, if there is an odd number of digits, the final digit is assumed to be 0. Consider the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{901}\PYG{n}{FA3}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

This is a 3\sphinxhyphen{}byte string consisting of the characters whose hexadecimal codes are 90, 1F, and A3, but \sphinxcode{\sphinxupquote{<901FA>}} is a 3\sphinxhyphen{}byte string containing the characters whose hexadecimal codes are 90, 1F, and A0.


\subsubsection{Cos arrays}
\label{\detokenize{Plugins_Cos:cos-arrays}}
Arrays are one\sphinxhyphen{}dimensional collections of objects accessed by a numeric index. Array indexes are zero\sphinxhyphen{}based and may be any combination of the Cos data types. The following array has seven elements: three integers, a string, a Boolean value, a dictionary (containing one key\sphinxhyphen{}value pair), and an indirect object reference.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{p}{(}\PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{string}\PYG{p}{)} \PYG{n}{true} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{o}{/}\PYG{n}{Key} \PYG{p}{(}\PYG{n}{The} \PYG{n}{value}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{6} \PYG{l+m+mi}{0} \PYG{n}{R} \PYG{p}{]}
\end{sphinxVerbatim}


\subsubsection{Cos names}
\label{\detokenize{Plugins_Cos:cos-names}}
A name object is an atomic symbol uniquely defined by a sequence of characters. Uniquely defined means that any two name objects made up of the same sequence of characters are identically the same object. Atomic means that a name has no internal structure; although it is defined by a sequence of characters, those characters are not considered elements of the name.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{n}{AName}
\end{sphinxVerbatim}

A slash character (/) introduces a name. The slash is not part of the name but is a prefix indicating that the following sequence of characters constitutes a name. There can be no white\sphinxhyphen{}space characters between the slash and the first character in the name. The name may include any regular characters, but not delimiter or white\sphinxhyphen{}space characters. Uppercase and lowercase letters are considered distinct: /A and /a are different names. The following examples are valid literal names:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Name1
  /ASomewhatLongerName
  /A;Name\PYGZus{}With\PYGZhy{}Various***Characters?
  /1.2
  /\PYGZdl{}\PYGZdl{}
  /@pattern
  /.notdef
\end{sphinxVerbatim}

Beginning with PDF 1.2, any character except null (character code 0) may be included in a name by writing its 2\sphinxhyphen{}digit hexadecimal code, preceded by the number sign character (\#). This syntax is required to represent any of the delimiter or white\sphinxhyphen{}space characters or the number sign character itself; it is recommended but not required for characters whose codes are outside the range 33 (!) to 126 (\textasciitilde{}). The examples shown in the following table are valid literal names in PDF 1.2 and later.


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{Plugins_Cos:section-1}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Literal name
&\sphinxstyletheadfamily 
Result
\\
\hline
/Adobe\#20Green
&
Adobe Green
\\
\hline
/PANTONE\#205757\#20CV
&
PANTONE 5757 CV
\\
\hline
/paired\#28\#29parentheses
&
paired()parentheses
\\
\hline
/The\_Key\_of\_F\#23\_Minor
&
The\_Key\_of\_F\#\_Minor
\\
\hline
/A\#42
&
AB
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The length of a name is subject to an implementation limit. The limit applies to the number of characters in the name’s internal representation. For example, the name /A\#20B has four characters (/, A, space, B), not six.

Name objects are treated as atomic symbols within a PDF file. Ordinarily, the bytes making up the name are never treated as text to be presented to a user. However, occasionally the need arises to treat a name object as text, such as one that represents a font name.

In such situations, it is recommended that the sequence of bytes (after expansion of \# sequences, if any) be interpreted according to UTF\sphinxhyphen{}8, a variable\sphinxhyphen{}length byte\sphinxhyphen{}encoded representation of Unicode in which the printable ASCII characters have the same representations as in ASCII. This enables a name object to represent text in any natural language, subject to the implementation limit on the length of a name.


\subsubsection{Cos dictionaries}
\label{\detokenize{Plugins_Cos:cos-dictionaries}}
A dictionary object is an associative table containing pairs of objects, known as the dictionary’s entries. The first element of each entry is the key and the second element is the value. The key must be a name. The value can be any kind of object, including other dictionaries and streams. A dictionary entry whose value is null is equivalent to an absent entry.

A dictionary is a table data structure whose elements are object pairs:
\begin{itemize}
\item {} 
The first element is the key, which is always a name object, a sequence of characters beginning with the forward slash (/) character. No two entries in the same dictionary should have the same key. If a key does appear more than once, its value is undefined.

\item {} 
The second element is the Cos object representing the value. You can add new key\sphinxhyphen{}value pairs, modify existing key\sphinxhyphen{}value pairs, or delete existing key\sphinxhyphen{}value pairs in a dictionary.

\end{itemize}

The following is an example of a dictionary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{o}{/}\PYG{n}{Name} \PYG{n}{John} \PYG{o}{/}\PYG{n}{Age} \PYG{l+m+mi}{27} \PYG{o}{/}\PYG{n}{AnArray} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

The value associated with the \sphinxcode{\sphinxupquote{Name}} key is the value \sphinxcode{\sphinxupquote{John}}. The value for the \sphinxcode{\sphinxupquote{Age}} key is \sphinxcode{\sphinxupquote{27}}. And the value for the \sphinxcode{\sphinxupquote{AnArray}} key is an array with the values \sphinxcode{\sphinxupquote{1}}, \sphinxcode{\sphinxupquote{2}}, and \sphinxcode{\sphinxupquote{3}}. For information about creating a Cos dictionary, see \sphinxhref{Plugins\_Cos.html\#50618418\_10844}{Creating Cos dictionaries}.


\subsubsection{Cos streams}
\label{\detokenize{Plugins_Cos:cos-streams}}
A stream is a sequence of bytes that can be read a portion at a time. For this reason, objects with potentially large amounts of data, such as images and page descriptions, are represented as streams. A stream consists of a dictionary followed by zero or more bytes bracketed between the keywords \sphinxcode{\sphinxupquote{stream}} and \sphinxcode{\sphinxupquote{endstream}}. The following example shows the basic syntax of a stream:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dictionary
stream
    …Zero or more bytes…
endstream
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{stream}} keyword should be followed by an end\sphinxhyphen{}of\sphinxhyphen{}line marker consisting of either a carriage return and a line feed or just a line feed, and not by a carriage return alone. The sequence of bytes that make up a stream is located between the \sphinxcode{\sphinxupquote{stream}} and \sphinxcode{\sphinxupquote{endstream}} keywords. Streams must be indirect objects and the stream dictionary must be a direct object. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86862}{About direct and indirect objects}.)

\begin{sphinxadmonition}{note}{Note:}
For more information about streams, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}.
\end{sphinxadmonition}


\section{Working with Cos strings}
\label{\detokenize{Plugins_Cos:working-with-cos-strings}}
This section discusses ways in which you can work with Cos strings. (See \sphinxhref{Plugins\_Cos.html\#50618418\_36150}{Cos strings}.)


\subsection{Creating Cos strings}
\label{\detokenize{Plugins_Cos:creating-cos-strings}}
You can use the Acrobat core API to create a \sphinxcode{\sphinxupquote{CosObj}} object that is based on a Cos string.

To create a Cos string:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{CosDoc}} object that represents a PDF file by invoking the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method and passing a \sphinxcode{\sphinxupquote{PDDoc}} object.

\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that is based on a Cos string by invoking the \sphinxcode{\sphinxupquote{CosNewString}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the \sphinxcode{\sphinxupquote{CosObj}} object is an indirect or direct object. If \sphinxcode{\sphinxupquote{true}}, the string is an indirect object. If \sphinxcode{\sphinxupquote{false}}, the string is a direct object. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86862}{About direct and indirect objects}.)

\item {} 
A character pointer that specifies the string. Cos strings can contain NULL characters.

\item {} 
The length of the character pointer.

\end{itemize}

\end{enumerate}

The following code example creates a \sphinxcode{\sphinxupquote{CosObj}} that is based on a Cos string. A \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} is passed to the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{Cos} \PYG{n}{string}
\PYG{n}{char}\PYG{o}{*} \PYG{n}{mystr} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New String}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{CosDoc} \PYG{n}{cd} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{CosObj} \PYG{n}{strObj} \PYG{o}{=} \PYG{n}{CosNewString}\PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{mystr}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{mystr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Retrieving the string value}
\label{\detokenize{Plugins_Cos:retrieving-the-string-value}}
You can retrieve the string value from a \sphinxcode{\sphinxupquote{CosObj}} that is based on a Cos string. To retrieve the string value, invoke the \sphinxcode{\sphinxupquote{CosStringValue}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} that is based on a Cos string.

\item {} 
The address of an \sphinxcode{\sphinxupquote{ASTCount}} object that is used to store the string length.

\end{itemize}

An exception is thrown if the \sphinxcode{\sphinxupquote{CosObj}} object that is passed to the \sphinxcode{\sphinxupquote{CosStringValue}} method is not based on a Cos string. The following code example expands the previous code example by retrieving the string value by invoking the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{Cos} \PYG{n}{string}
\PYG{n}{char}\PYG{o}{*} \PYG{n}{mystr} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New String}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{CosDoc} \PYG{n}{cd} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc} \PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{CosObj} \PYG{n}{strObj} \PYG{o}{=} \PYG{n}{CosNewString}\PYG{p}{(}\PYG{n}{cd}\PYG{p}{,}\PYG{n}{false}\PYG{p}{,}\PYG{n}{mystr}\PYG{p}{,}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{mystr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{string} \PYG{n}{value}
\PYG{n}{char}\PYG{o}{*} \PYG{n}{strValue}\PYG{p}{;}
\PYG{n}{ASTCount} \PYG{n}{length}\PYG{p}{;}
\PYG{n}{strValue} \PYG{o}{=} \PYG{n}{CosStringValue}\PYG{p}{(}\PYG{n}{strObj}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{length}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Display} \PYG{n}{the} \PYG{n}{string} \PYG{n}{value}
\PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{n}{strValue}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Working with Cos arrays}
\label{\detokenize{Plugins_Cos:working-with-cos-arrays}}
This section discusses ways in which you can work with \sphinxcode{\sphinxupquote{Cos}} arrays.


\subsection{Creating Cos arrays}
\label{\detokenize{Plugins_Cos:creating-cos-arrays}}
You can use the Acrobat core API to create a \sphinxcode{\sphinxupquote{CosObj}} object that is based on a \sphinxcode{\sphinxupquote{Cos}} array. You specify the number of elements that the \sphinxcode{\sphinxupquote{Cos}} array stores when you create it. However, you can add elements dynamically as needed. For example, assume that you create a \sphinxcode{\sphinxupquote{Cos}} array that stores three elements. If required, you can add a fourth element. An exception is thrown if the \sphinxcode{\sphinxupquote{CosObj}} object that is added to the \sphinxcode{\sphinxupquote{Cos}} array is a direct object that is already located in another \sphinxcode{\sphinxupquote{Cos}} collection object.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
To create a Cos array:

\item {} 
Create a \sphinxcode{\sphinxupquote{CosDoc}} object that represents a PDF file by invoking the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method and passing a \sphinxcode{\sphinxupquote{PDDoc}} object.

\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that is based on a \sphinxcode{\sphinxupquote{Cos}} array by invoking the \sphinxcode{\sphinxupquote{CosNewArray}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the \sphinxcode{\sphinxupquote{CosObj}} object is an indirect or direct object. If \sphinxcode{\sphinxupquote{true}}, the string is an indirect object. If \sphinxcode{\sphinxupquote{false}}, the string is a direct object. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86862}{About direct and indirect objects}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASTArraySize}} object that specifies the number of elements.

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that stores a value to add to the \sphinxcode{\sphinxupquote{Cos}} array. For example, to create a \sphinxcode{\sphinxupquote{CosObj}} object that is based on an integer value, invoke the \sphinxcode{\sphinxupquote{CosNewInteger}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the \sphinxcode{\sphinxupquote{CosObj}} object is an indirect or direct object. If \sphinxcode{\sphinxupquote{true}}, the string is an indirect object. If \sphinxcode{\sphinxupquote{false}}, the string is a direct object. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86862}{About direct and indirect objects}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that specifies the integer value.

\end{itemize}

\item {} 
Add the value to the \sphinxcode{\sphinxupquote{Cos}} array by invoking the \sphinxcode{\sphinxupquote{CosArrayPut}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that represents a \sphinxcode{\sphinxupquote{Cos}} array.

\item {} 
An \sphinxcode{\sphinxupquote{ASTArraySize}} object that specifies a 0\sphinxhyphen{}based index value.

\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that stores the value to add to the array.

\end{itemize}

\end{enumerate}

The following code example creates a \sphinxcode{\sphinxupquote{Cos}} array and adds the values \sphinxcode{\sphinxupquote{1}}, \sphinxcode{\sphinxupquote{2}}, \sphinxcode{\sphinxupquote{3}}, \sphinxcode{\sphinxupquote{4}}, and \sphinxcode{\sphinxupquote{5}} to it. A \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} is passed to the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{Cos} \PYG{n}{array}
\PYG{n}{CosObj} \PYG{n}{ArrayObj}\PYG{p}{,} \PYG{n}{IntObj}\PYG{p}{;}
\PYG{n}{CosDoc} \PYG{n}{cd} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ArrayObj} \PYG{o}{=} \PYG{n}{CosNewArray} \PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{CosObj} \PYG{n}{representing} \PYG{n}{the} \PYG{n}{integer} \PYG{n}{value}
\PYG{n}{IntObj} \PYG{o}{=} \PYG{n}{CosNewInteger} \PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Store} \PYG{n}{the} \PYG{n}{integer} \PYG{n+nb}{object} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{array}
\PYG{n}{CosArrayPut} \PYG{p}{(}\PYG{n}{ArrayObj}\PYG{p}{,} \PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{IntObj}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Retrieving Cos array values}
\label{\detokenize{Plugins_Cos:retrieving-cos-array-values}}
You can use the Acrobat core API to retrieve values from a \sphinxcode{\sphinxupquote{CosObj}} object that is based on a \sphinxcode{\sphinxupquote{Cos}} array.

To retrieve values from a Cos array:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Determine the number of elements by invoking the \sphinxcode{\sphinxupquote{CosArrayLength}} method. Pass the \sphinxcode{\sphinxupquote{CosObj}} object that represents the \sphinxcode{\sphinxupquote{Cos}} array as an argument.

\item {} 
Get the \sphinxcode{\sphinxupquote{CosObj}} object that represents an array element by invoking the \sphinxcode{\sphinxupquote{CosArrayGet}} method and passing the following arguments:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{CosObj}} object that represents the \sphinxcode{\sphinxupquote{Cos}} array

\item {} 
An \sphinxcode{\sphinxupquote{ASTArraySize}} object that represents the index of the array element to retrieve

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{CosArrayGet}} method returns a \sphinxcode{\sphinxupquote{CosObj}} object that represents the element
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Get the element value. However, you must invoke the method that corresponds to the \sphinxcode{\sphinxupquote{CosObj}} object’s data type. If, for example, the \sphinxcode{\sphinxupquote{Cos}} array stores integer values, invoke the \sphinxcode{\sphinxupquote{CosIntegerValue}} method to obtain the element’s integer value. Pass the \sphinxcode{\sphinxupquote{CosObj}} object that represents the element. This method returns the corresponding value. If the \sphinxcode{\sphinxupquote{CosIntegerValue}} method is invoked, then an \sphinxcode{\sphinxupquote{ASInt32}} value is returned.

\end{enumerate}

The following code illustrates a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{GetArrayValues}} that retrieves the value of each element and displays it in an alert box. Notice that a \sphinxcode{\sphinxupquote{CosObj}} that represents a \sphinxcode{\sphinxupquote{Cos}} array is passed to the \sphinxcode{\sphinxupquote{GetArrayValues}} as its only parameter.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{GetArrayValues}\PYG{p}{(}\PYG{n}{CosObj} \PYG{n}{array}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{CosObj} \PYG{n}{IntObj}\PYG{p}{;}
  \PYG{n}{ASInt32} \PYG{n}{value}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{NumElements}\PYG{p}{;}
  \PYG{n}{char} \PYG{n}{buf}\PYG{p}{[}\PYG{l+m+mi}{256}\PYG{p}{]}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Determine} \PYG{n}{the} \PYG{n}{number} \PYG{n}{of} \PYG{n}{elements} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{array}
\PYG{n}{NumElements} \PYG{o}{=} \PYG{n}{CosArrayLength}\PYG{p}{(}\PYG{n}{array}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Iterate} \PYG{n}{through} \PYG{n}{the} \PYG{n}{array}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NumElements}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{a} \PYG{n}{specific} \PYG{n}{element}
\PYG{n}{IntObj} \PYG{o}{=} \PYG{n}{CosArrayGet}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Convert} \PYG{n}{the} \PYG{n}{CosObj} \PYG{n}{to} \PYG{n}{its} \PYG{n}{ASInt32} \PYG{n}{value}
\PYG{n}{value} \PYG{o}{=} \PYG{n}{CosIntegerValue} \PYG{p}{(}\PYG{n}{IntObj}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Display} \PYG{n}{the} \PYG{n}{value}
\PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The element value is }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Working with Cos dictionaries}
\label{\detokenize{Plugins_Cos:working-with-cos-dictionaries}}
This section discusses ways in which you can work with Cos dictionaries. (See \sphinxhref{Plugins\_Cos.html\#50618418\_50984}{Cos dictionaries}.)


\subsection{Creating Cos dictionaries}
\label{\detokenize{Plugins_Cos:creating-cos-dictionaries}}
You can create a \sphinxcode{\sphinxupquote{CosObj}} object that is based on a Cos dictionary. Both the key and its value are \sphinxcode{\sphinxupquote{CosObj}} objects that you create and add to the Cos dictionary, which is also a \sphinxcode{\sphinxupquote{CosObj}} object.

To create a Cos dictionary:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{CosDoc}} object that represents a PDF file by invoking the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method and passing a \sphinxcode{\sphinxupquote{PDDoc}} object.

\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that represents the dictionary by invoking the \sphinxcode{\sphinxupquote{CosNewDict}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the \sphinxcode{\sphinxupquote{CosObj}} object is an indirect or direct object. If \sphinxcode{\sphinxupquote{true}}, the string is an indirect object. If \sphinxcode{\sphinxupquote{false}}, the string is a direct object. (See \sphinxhref{Plugins\_Cos.html\#50618418\_16671}{About Cos objects}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASTArraySize}} object that specifies the number of dictionary entries (the number of key and value pairs).

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{CosNewDict}} method returns a \sphinxcode{\sphinxupquote{CosObj}} object that represents the new Cos dictionary.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that represents a dictionary value. You must invoke a method that corresponds to the value’s data type. For example, to add an integer value, invoke the \sphinxcode{\sphinxupquote{CosNewInteger}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the \sphinxcode{\sphinxupquote{CosObj}} object is an indirect or direct object. If \sphinxcode{\sphinxupquote{true}}, the string is an indirect object. If \sphinxcode{\sphinxupquote{false}}, the string is a direct object. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86862}{About direct and indirect objects}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that specifies the integer value.

\end{itemize}

\item {} 
Place the \sphinxcode{\sphinxupquote{CosObj}} object that represents a dictionary value into the dictionary by invoking the \sphinxcode{\sphinxupquote{CosDictPut}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} that represents the dictionary

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that specifies the key name

\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that specifies the dictionary value

\end{itemize}

\item {} 
Repeat steps 3 and 4 for each dictionary entry that you want to add.

\end{enumerate}

The following code example creates a Cos dictionary with the following entries: \sphinxcode{\sphinxupquote{/Key1 1 /Key2}}. A \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} is passed to the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{Cos} \PYG{n}{dictionary}
\PYG{n}{CosObj} \PYG{n}{Dict}\PYG{p}{,} \PYG{n}{IntObj}\PYG{p}{;}
\PYG{n}{CosDoc} \PYG{n}{cd}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{CosDoc}
\PYG{n}{cd} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Make} \PYG{n}{a} \PYG{n}{new} \PYG{n}{dictionary} \PYG{k}{with} \PYG{n}{two} \PYG{n}{entries}
\PYG{n}{Dict} \PYG{o}{=} \PYG{n}{CosNewDict} \PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IntObj} \PYG{o}{=} \PYG{n}{CosNewInteger} \PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Place} \PYG{n}{the} \PYG{n}{key} \PYG{n}{value} \PYG{n}{pair} \PYG{n}{of} \PYG{o}{/}\PYG{n}{Key1} \PYG{l+m+mi}{1} \PYG{n}{into} \PYG{n}{the} \PYG{n}{dictionary}
\PYG{n}{CosDictPut} \PYG{p}{(}\PYG{n}{Dict}\PYG{p}{,} \PYG{n}{ASAtomFromString} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Key1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{IntObj}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IntObj} \PYG{o}{=} \PYG{n}{CosNewInteger} \PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Place} \PYG{n}{the} \PYG{n}{key} \PYG{n}{value} \PYG{n}{pair} \PYG{n}{of} \PYG{o}{/}\PYG{n}{Key2} \PYG{l+m+mi}{2} \PYG{n}{into} \PYG{n}{the} \PYG{n}{dictionary}
\PYG{n}{CosDictPut} \PYG{p}{(}\PYG{n}{Dict}\PYG{p}{,} \PYG{n}{ASAtomFromString} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Key2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{IntObj}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Retrieving values from a Cos dictionary}
\label{\detokenize{Plugins_Cos:retrieving-values-from-a-cos-dictionary}}
You can retrieve a dictionary element value by performing the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Get a dictionary key value by invoking the \sphinxcode{\sphinxupquote{CosDictGet}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that represents the dictionary.

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that represents the key name.

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{CosDictGet}} method returns a \sphinxcode{\sphinxupquote{CosObj}} object that represents the dictionary value.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Get the element value. However, you must invoke the method that corresponds to the \sphinxcode{\sphinxupquote{CosObj}} object’s data type. If, for example, the \sphinxcode{\sphinxupquote{Cos}} array stores integer values, invoke the \sphinxcode{\sphinxupquote{CosIntegerValue}} method to obtain the dictionary entry value. Pass the \sphinxcode{\sphinxupquote{CosObj}} object that represents the dictionary entry. This method returns the corresponding value. If the \sphinxcode{\sphinxupquote{CosIntegerValue}} method is invoked, then an \sphinxcode{\sphinxupquote{ASInt32}} value is returned.

\end{enumerate}

The following code example retrieves the value of a dictionary element whose key is named Key1. The element value is displayed within an alert box.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Retrieve} \PYG{n}{the} \PYG{n}{value} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{n}{dictionary} \PYG{n}{entry} \PYG{n}{whose} \PYG{n}{key} \PYG{o+ow}{is} \PYG{n}{named} \PYG{n}{Key1}
\PYG{n}{CosObj} \PYG{n}{dictEntry}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{dicValue}\PYG{p}{;}
\PYG{n}{char} \PYG{n}{buf}\PYG{p}{[}\PYG{l+m+mi}{256}\PYG{p}{]} \PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{element} \PYG{n}{whose} \PYG{n}{key} \PYG{o+ow}{is} \PYG{n}{named} \PYG{n}{Key1}
\PYG{n}{dictEntry} \PYG{o}{=} \PYG{n}{CosDictGet}\PYG{p}{(}\PYG{n}{Dict}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Key1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{dicValue} \PYG{o}{=} \PYG{n}{CosIntegerValue}\PYG{p}{(}\PYG{n}{dictEntry}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Display} \PYG{n}{the} \PYG{n}{value} \PYG{n}{of} \PYG{n}{the} \PYG{n}{dictionary} \PYG{n}{element}
\PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The value of the dictionary element is }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{dicValue}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{Dict}} object is a \sphinxcode{\sphinxupquote{CosObj}} that represents the dictionary. (See \sphinxhref{Plugins\_Cos.html\#50618418\_10844}{Creating Cos dictionaries}.)
\end{sphinxadmonition}


\subsection{Querying a Cos dictionary for a key}
\label{\detokenize{Plugins_Cos:querying-a-cos-dictionary-for-a-key}}
You can use the Acrobat core API to determine whether a specific key\sphinxhyphen{}value pair exists. To perform this task, invoke the \sphinxcode{\sphinxupquote{CosDictKnown}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that represents the dictionary.

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that represents the key name.

\end{itemize}

This method returns an \sphinxcode{\sphinxupquote{ASBool}} value that specifies whether the key\sphinxhyphen{}value pair exists. If this method returns \sphinxcode{\sphinxupquote{true}}, then the key\sphinxhyphen{}value pair exists. The following code example queries a dictionary to determine whether a key named \sphinxcode{\sphinxupquote{Key1}} exists.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Determine} \PYG{n}{whether} \PYG{n}{a} \PYG{n}{key} \PYG{n}{named} \PYG{n}{Key1} \PYG{n}{exists}
\PYG{n}{ASBool} \PYG{n}{keyExist} \PYG{o}{=} \PYG{n}{CosDictKnown}\PYG{p}{(}\PYG{n}{Dict}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Key1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{keyExist} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The dictionary contains a key named Key1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The dictionary does not contain a key named Key1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Working with Cos names}
\label{\detokenize{Plugins_Cos:working-with-cos-names}}
This section discusses ways in which you can work with Cos names. (See \sphinxhref{Plugins\_Cos.html\#50618418\_29290}{Cos names}.)


\subsection{Creating Cos names}
\label{\detokenize{Plugins_Cos:creating-cos-names}}
You can use the Acrobat core API to create a \sphinxcode{\sphinxupquote{CosObj}} object that is based on a Cos name.

To create a Cos name:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{CosDoc}} object that represents a PDF file by invoking the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method and passing a \sphinxcode{\sphinxupquote{PDDoc}} object.

\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that represents the name by invoking the \sphinxcode{\sphinxupquote{CosNewName}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the \sphinxcode{\sphinxupquote{CosObj}} object is an indirect or direct object. If \sphinxcode{\sphinxupquote{true}}, the string is an indirect object. If \sphinxcode{\sphinxupquote{false}}, the string is a direct object. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86862}{About direct and indirect objects}.)

\item {} 
An \sphinxcode{\sphinxupquote{ASAtom}} object that represent the name to create.

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{CosNewName}} method returns a \sphinxcode{\sphinxupquote{CosObj}} object that represents the new Cos name.

The following code example creates a Cos name with the value \sphinxcode{\sphinxupquote{Name1}}. A \sphinxcode{\sphinxupquote{PDDoc}} object named \sphinxcode{\sphinxupquote{myPDDoc}} is passed to the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{Cos} \PYG{n}{name}
\PYG{n}{CosObj} \PYG{n}{nameObj}\PYG{p}{;}
\PYG{n}{CosDoc} \PYG{n}{cd} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{nameObj} \PYG{o}{=} \PYG{n}{CosNewName}\PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Retrieving the value of a name object}
\label{\detokenize{Plugins_Cos:retrieving-the-value-of-a-name-object}}
You can retrieve the value of a name object by using the Acrobat core API. For example, assume that you retrieve the value from the Cos name object created in the previous code example. In this situation, the value that is retrieved is \sphinxcode{\sphinxupquote{Name1}}.

To retrieve the value from a Cos name object:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Invoke the \sphinxcode{\sphinxupquote{CosNameValue}} method and pass the \sphinxcode{\sphinxupquote{CosObj}} that represents the Cos name. This method returns an \sphinxcode{\sphinxupquote{ASAtom}} object that represents the name value.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{ASAtomGetString}} method to get a constant character pointer that specifies the Cos name value. Pass the \sphinxcode{\sphinxupquote{ASAtom}} object that is returned from the \sphinxcode{\sphinxupquote{CosNameValue}} method.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{Cos} \PYG{n}{name}
\PYG{n}{CosObj} \PYG{n}{nameObj}\PYG{p}{;}
\PYG{n}{CosDoc} \PYG{n}{cd} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{myPDDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{nameObj} \PYG{o}{=} \PYG{n}{CosNewName} \PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{ASAtomFromString} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{o+ow}{and} \PYG{n}{display} \PYG{n}{the} \PYG{n}{value} \PYG{n}{of} \PYG{n}{a} \PYG{n}{Cos} \PYG{n}{name} \PYG{n+nb}{object}
\PYG{n}{ASAtom} \PYG{n}{nameVal} \PYG{o}{=} \PYG{n}{CosNameValue}\PYG{p}{(}\PYG{n}{nameObj}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{char} \PYG{o}{*} \PYG{n+nb}{str} \PYG{o}{=} \PYG{n}{ASAtomGetString}\PYG{p}{(}\PYG{n}{nameVal}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The return value of the \sphinxcode{\sphinxupquote{ASAtomGetString}} method is a constant character pointer, not a character pointer. You will generate a compile error if you omit the \sphinxcode{\sphinxupquote{const}} keyword.
\end{sphinxadmonition}


\section{Working with Cos streams}
\label{\detokenize{Plugins_Cos:working-with-cos-streams}}
This section discusses ways in which you can work with Cos streams. (See \sphinxhref{Plugins\_Cos.html\#50618418\_63762}{Cos streams}.)

A stream is represented by an \sphinxcode{\sphinxupquote{ASStm}} object definition. A data stream can be a buffer in memory, a file, or an arbitrary user\sphinxhyphen{}written procedure. When writing or extracting data streams, an \sphinxcode{\sphinxupquote{ASStm}} object must be converted to a Cos stream.

\begin{sphinxadmonition}{note}{Note:}
Before reading this section, it is strongly recommended that you are familiar with concepts discussed earlier in this chapter, such as \sphinxcode{\sphinxupquote{Cos}} arrays and Cos dictionaries.
\end{sphinxadmonition}


\subsection{Creating Cos streams}
\label{\detokenize{Plugins_Cos:creating-cos-streams}}
You can create a data stream in memory and then insert the stream into a PDF document page. The following diagram shows the result of a data stream that creates a thin black line segment being inserted into a PDF document.

\noindent\sphinxincludegraphics{{lineStream}.png}

The following example shows the syntax of a stream that creates a thin line segment:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{150} \PYG{l+m+mi}{250} \PYG{n}{m} \PYG{l+m+mi}{150} \PYG{l+m+mi}{350} \PYG{n}{l} \PYG{n}{S}
\end{sphinxVerbatim}

In contrast, the following example shows the syntax of a stream that inserts the text \sphinxcode{\sphinxupquote{Hello}} \sphinxcode{\sphinxupquote{There}} into a PDF document:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BT} \PYG{o}{/}\PYG{n}{F0} \PYG{l+m+mi}{1} \PYG{n}{Tf} \PYG{l+m+mi}{24} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{24} \PYG{l+m+mi}{36} \PYG{l+m+mi}{756} \PYG{n}{Tm} \PYG{l+m+mi}{0} \PYG{n}{Tr} \PYG{l+m+mi}{0} \PYG{n}{g} \PYG{l+m+mi}{0} \PYG{n}{Tc} \PYG{l+m+mi}{0} \PYG{n}{Tw} \PYG{p}{(}\PYG{n}{Hello} \PYG{n}{There}\PYG{p}{)} \PYG{n}{Tj} \PYG{n}{ET}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For information about stream syntax, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}.
\end{sphinxadmonition}


\subsubsection{Creating a stream dictionary}
\label{\detokenize{Plugins_Cos:creating-a-stream-dictionary}}
Each Cos stream has a stream dictionary that contains a \sphinxcode{\sphinxupquote{Length}} entry that indicates how many bytes are used for the stream’s data (if the stream has a filter, the \sphinxcode{\sphinxupquote{Length}} entry is the number of bytes of encoded data). A limit of 4096 bytes exists for the \sphinxcode{\sphinxupquote{Length}} entry. A stream dictionary also has optional entries that are not discussed in this section. For more information about stream dictionaries, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}

In addition, most filters are defined so that the data is self\sphinxhyphen{}limiting; that is, they use an encoding scheme in which an explicit end\sphinxhyphen{}of\sphinxhyphen{}data (EOD) marker delimits the extent of the data. Finally, streams are used to represent many objects from whose length attributes can be inferred. All of these constraints must be consistent.

For example, an image with 10 rows and 20 columns, using a single color component and 8 bits per component, requires exactly 200 bytes of image data. If the stream uses a filter, there must be enough bytes of encoded data in the PDF file to produce those 200 bytes. An error occurs if the \sphinxcode{\sphinxupquote{Length}} entry is too small, if an explicit EOD marker occurs too soon, or if the decoded data does not contain 200 bytes. It is also an error if the stream contains too much data, with the exception that there may be an extra end\sphinxhyphen{}of\sphinxhyphen{}line marker in the PDF file before the \sphinxcode{\sphinxupquote{endstream}} keyword. All streams created in this section have a stream dictionary defined.

For each stream that you want to insert into a PDF document, create a stream dictionary that contains at least the \sphinxcode{\sphinxupquote{Length}} entry, as shown in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{/}\PYG{n}{Length} \PYG{l+m+mi}{100}\PYG{o}{\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

To create a stream dictionary with the Length entry defined:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{CosDoc}} object that represents a PDF file by invoking the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method.

\item {} 
Create an \sphinxcode{\sphinxupquote{ASUns32}} object that represents the stream length.

\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that represents the length of the stream by invoking the \sphinxcode{\sphinxupquote{CosNewInteger}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object that you created in step 1.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the \sphinxcode{\sphinxupquote{CosObj}} object is an indirect or direct object. If \sphinxcode{\sphinxupquote{true}}, the string is an indirect object. If \sphinxcode{\sphinxupquote{false}}, the string is a direct object. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86862}{About direct and indirect objects}.)

\item {} 
The \sphinxcode{\sphinxupquote{ASUns32}} object created in step 2 that represents the stream length.

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{CosNewInteger}} method returns a \sphinxcode{\sphinxupquote{CosObj}} object that represents the stream length.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that represents the Cos dictionary. (See \sphinxhref{Plugins\_Cos.html\#50618418\_10844}{Creating Cos dictionaries}.)

\item {} 
Set the stream dictionary key and value by invoking the \sphinxcode{\sphinxupquote{CosDictPutKeyString}} method and passing the following arguments:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{CosObj}} object that you created in step 4 that represents the dictionary.

\item {} 
A character pointer that specifies the name of the key, which in this situation is \sphinxcode{\sphinxupquote{Length}}.

\item {} 
The \sphinxcode{\sphinxupquote{CosObj}} object created in step 3 that specifies the length of the stream.

\end{itemize}

\end{enumerate}

The following code example creates a stream dictionary. The first part of this code example creates a \sphinxcode{\sphinxupquote{PDPage}} object by using an \sphinxcode{\sphinxupquote{AVDoc}} object. For information about this application logic, see \sphinxhref{Plugins\_Pages.html\#50618407\_91421}{Creating a PDEContent object}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDPage} \PYG{n+nb}{object} \PYG{n}{using} \PYG{n}{the} \PYG{n}{current} \PYG{n}{page}
\PYG{n}{AVDoc} \PYG{n}{avDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVPageView} \PYG{n}{pageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPageNumber} \PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPage} \PYG{n}{pdPage} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{pageNum}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Use} \PYG{n}{the} \PYG{n}{PDPage} \PYG{n+nb}{object} \PYG{n}{to} \PYG{n}{get} \PYG{n}{the} \PYG{n}{CosDoc} \PYG{n+nb}{object}
\PYG{n}{CosDoc} \PYG{n}{cd} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{PDPageGetDoc}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{a} \PYG{n}{stream} \PYG{n}{to} \PYG{n}{draw} \PYG{n}{a} \PYG{n}{line}
\PYG{n}{char} \PYG{n}{buf} \PYG{p}{[}\PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{150 250 m 150 350 l S}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{stream} \PYG{n}{length}
\PYG{n}{ASUns32} \PYG{n}{streamLength} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ASUns32}\PYG{p}{)}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{CosObj} \PYG{n+nb}{object} \PYG{n}{that} \PYG{n}{represents} \PYG{n}{the} \PYG{n}{stream} \PYG{n}{length}
\PYG{n}{CosObj} \PYG{n}{LengthEntry} \PYG{o}{=} \PYG{n}{CosNewInteger}\PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}\PYG{n}{streamLength}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{CosObj} \PYG{n}{that} \PYG{n}{represents} \PYG{n}{a} \PYG{n}{stream} \PYG{n}{dictionary}

\PYG{o}{/}\PYG{o}{/}\PYG{o+ow}{and} \PYG{n}{sets} \PYG{n}{its} \PYG{n}{key}\PYG{o}{\PYGZhy{}}\PYG{n}{value} \PYG{n}{pairs}
\PYG{n}{CosObj} \PYG{n}{AttrDict} \PYG{o}{=} \PYG{n}{CosNewDict}\PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{char} \PYG{o}{*}\PYG{n}{Length\PYGZus{}KStr} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Length}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{AttrDict}\PYG{p}{,} \PYG{n}{Length\PYGZus{}KStr}\PYG{p}{,} \PYG{n}{LengthEntry}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Determine} \PYG{k}{if} \PYG{n}{the} \PYG{n}{stream} \PYG{n}{dictionary} \PYG{o+ow}{is} \PYG{n}{valid}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{CosObjEqual} \PYG{p}{(}\PYG{n}{AttrDict}\PYG{p}{,} \PYG{n}{CosNewNull} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The attributes dictionary could not be created.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
This code example creates a \sphinxcode{\sphinxupquote{CosObj}} object named \sphinxcode{\sphinxupquote{AttrDict}} that represents a stream dictionary.
\end{sphinxadmonition}


\subsubsection{Inserting a Cos stream into a PDF document}
\label{\detokenize{Plugins_Cos:inserting-a-cos-stream-into-a-pdf-document}}
When inserting a stream into a PDF document, ensure that the stream is valid; otherwise, a run\sphinxhyphen{}time error occurs. This section explains how to create a stream that draws a thin black line segment and then inserts the stream into the current PDF page.

To insert a stream into the current PDF document page:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a \sphinxcode{\sphinxupquote{PDPage}} object that represents the current PDF page. (See \sphinxhref{Plugins\_Pages.html\#50618407\_91421}{Creating a PDEContent object}.)

\item {} 
Create a \sphinxcode{\sphinxupquote{CosDoc}} object that represents a PDF file by invoking the \sphinxcode{\sphinxupquote{PDDocGetCosDoc}} method.

\item {} 
Define the stream that draws a thin black line segment. You can populate a character array with a stream by invoking the \sphinxcode{\sphinxupquote{sprintf}} method.

\item {} 
Create an \sphinxcode{\sphinxupquote{ASUns32}} object that represents the stream length.

\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that represents the stream dictionary. (See \sphinxhref{Plugins\_Cos.html\#50618418\_71942}{Creating a stream dictionary}.)

\item {} 
Read the stream into memory by invoking the \sphinxcode{\sphinxupquote{ASMemStmRdOpen}} method and passing the following arguments:
\begin{itemize}
\item {} 
A character pointer that contains the data stream

\item {} 
An \sphinxcode{\sphinxupquote{ASUns32}} object that specifies the stream length

\end{itemize}

\end{enumerate}

This method returns an \sphinxcode{\sphinxupquote{ASStm}} object that represents an in\sphinxhyphen{}memory data stream.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a new Cos stream that is based on data located in the \sphinxcode{\sphinxupquote{ASStm}} object by invoking the \sphinxcode{\sphinxupquote{CosNewStream}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object that specifies the PDF document in which the Cos stream is inserted (pass the \sphinxcode{\sphinxupquote{CosDoc}} object created in step 2).

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the Cos stream is an indirect object. Because all streams are indirect objects, this argument must be set to \sphinxcode{\sphinxupquote{true}}.

\item {} 
An \sphinxcode{\sphinxupquote{ASStm}} object that contains the stream data (pass the \sphinxcode{\sphinxupquote{ASStm}} object created in step 6).

\item {} 
A \sphinxcode{\sphinxupquote{CosStreamStartAndCode}} object that specifies the byte offset from which data reading starts. You can pass \sphinxcode{\sphinxupquote{0}} to ensure that data reading starts at the beginning of the stream.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the data is encoded using filters specified in the stream dictionary before it is written to the Cos stream.

\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that represents the stream dictionary (pass the \sphinxcode{\sphinxupquote{CosObj}} object created in step 5).

\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that represents the parameters that are used by the encoding filter if the source data is encoded before it is written to the file. If encoding parameters are not required, this value is ignored. For information about encoding filters, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}

\item {} 
A \sphinxcode{\sphinxupquote{CosByteMax}} object that specifies the amount of data read from the source. If this value is \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}, data is read from the source until it reaches the end of the stream.

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{CosNewStream}} method returns a \sphinxcode{\sphinxupquote{CosObj}} object that represents the Cos stream.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Replace the contents of the specified page with the Cos stream by invoking the \sphinxcode{\sphinxupquote{PDPageAddCosContents}} method and passing the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDPage}} object that represents the current page of the PDF document (pass the \sphinxcode{\sphinxupquote{PDPage}} object created in step 1).

\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that contains the Cos stream.

\end{itemize}

\end{enumerate}

The following code example creates a Cos stream and inserts it into the current page of a PDF document.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{local} \PYG{n}{variables} \PYG{n}{used} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{code} \PYG{n}{example}
\PYG{n}{CosDoc} \PYG{n}{cd}\PYG{p}{;}
\PYG{n}{CosObj} \PYG{n}{PageStrm}\PYG{p}{,} \PYG{n}{LengthEntry}\PYG{p}{,} \PYG{n}{AttrDict}\PYG{p}{;}
\PYG{n}{CosObj} \PYG{n}{EncodeParms} \PYG{o}{=} \PYG{n}{CosNewNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASStm} \PYG{n}{OpenedStream}\PYG{p}{;}
\PYG{n}{char} \PYG{n}{buf} \PYG{p}{[}\PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{PDPage} \PYG{n+nb}{object} \PYG{n}{using} \PYG{n}{the} \PYG{n}{current} \PYG{n}{page}
\PYG{n}{AVDoc} \PYG{n}{avDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{AVPageView} \PYG{n}{pageView} \PYG{o}{=} \PYG{n}{AVDocGetPageView}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPageNumber} \PYG{n}{pageNum} \PYG{o}{=} \PYG{n}{AVPageViewGetPageNum}\PYG{p}{(}\PYG{n}{pageView}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDDoc} \PYG{n}{pdDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{avDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PDPage} \PYG{n}{pdPage} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{pdDoc}\PYG{p}{,} \PYG{n}{pageNum}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{acquire} \PYG{n}{current} \PYG{n}{page}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Use} \PYG{n}{the} \PYG{n}{PDPage} \PYG{n+nb}{object} \PYG{n}{to} \PYG{n}{create} \PYG{n}{a} \PYG{n}{CosDoc} \PYG{n+nb}{object}
\PYG{n}{cd} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{PDPageGetDoc}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{a} \PYG{n}{stream} \PYG{n}{that} \PYG{n}{creates} \PYG{n}{a} \PYG{n}{thin} \PYG{n}{line} \PYG{n}{segment}
\PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{150 250 m 150 350 l S}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Get} \PYG{n}{the} \PYG{n}{stream} \PYG{n}{length}
\PYG{n}{ASUns32} \PYG{n}{streamLength} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ASUns32}\PYG{p}{)}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{CosObj} \PYG{n+nb}{object} \PYG{n}{that} \PYG{n}{represents} \PYG{n}{the} \PYG{n}{stream} \PYG{n}{length}
\PYG{n}{LengthEntry} \PYG{o}{=} \PYG{n}{CosNewInteger}\PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}\PYG{n}{streamLength}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{CosObj} \PYG{n}{that} \PYG{n}{represents} \PYG{n}{a} \PYG{n}{stream} \PYG{n}{dictionary}

\PYG{o}{/}\PYG{o}{/}\PYG{o+ow}{and} \PYG{n+nb}{set} \PYG{n}{it} \PYG{n}{key}\PYG{o}{\PYGZhy{}}\PYG{n}{value} \PYG{n}{pairs}
\PYG{n}{AttrDict} \PYG{o}{=} \PYG{n}{CosNewDict}\PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{char} \PYG{o}{*}\PYG{n}{Length\PYGZus{}KStr} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Length}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{AttrDict}\PYG{p}{,} \PYG{n}{Length\PYGZus{}KStr}\PYG{p}{,} \PYG{n}{LengthEntry}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Determine} \PYG{k}{if} \PYG{n}{the} \PYG{n}{stream} \PYG{n}{dictionary} \PYG{o+ow}{is} \PYG{n}{valid}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{CosObjEqual} \PYG{p}{(}\PYG{n}{AttrDict}\PYG{p}{,} \PYG{n}{CosNewNull} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The stream dictionary could not be created}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/}\PYG{n}{Read} \PYG{n}{the} \PYG{n}{stream} \PYG{n}{into} \PYG{n}{memory} \PYG{n}{by} \PYG{n}{invoking} \PYG{n}{the} \PYG{n}{ASMemStmRdOpen} \PYG{n}{method}
\PYG{n}{OpenedStream} \PYG{o}{=} \PYG{n}{ASMemStmRdOpen}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{,}\PYG{n}{streamLength}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{DURING}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{Cos} \PYG{n}{stream} \PYG{n}{using} \PYG{n}{data} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{n}{ASStm} \PYG{n+nb}{object}
\PYG{o}{/}\PYG{o}{/}\PYG{n}{PageStrm} \PYG{o}{=} \PYG{n}{CosNewStream}\PYG{p}{(}\PYG{n}{cd}\PYG{p}{,} \PYG{n}{true}\PYG{p}{,} \PYG{n}{OpenedStream}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}
   \PYG{n}{false}\PYG{p}{,} \PYG{o}{/}\PYG{o}{/} \PYG{n}{StmDataIsNotDecoded}
   \PYG{n}{AttrDict}\PYG{p}{,} \PYG{o}{/}\PYG{o}{/}\PYG{n}{The} \PYG{n}{stream} \PYG{n}{dictionary}
   \PYG{n}{EncodeParms}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Close} \PYG{n}{the} \PYG{n}{stream}
\PYG{n}{ASStmClose}\PYG{p}{(}\PYG{n}{OpenedStream}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{HANDLER}
\PYG{n}{AVAlertNote} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Trying to create new CosStream}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{CosObjDestroy} \PYG{p}{(}\PYG{n}{AttrDict}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASStmClose} \PYG{p}{(}\PYG{n}{OpenedStream}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{return}\PYG{p}{;}
\PYG{n}{END\PYGZus{}HANDLER}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Completely} \PYG{n}{replace} \PYG{n}{the} \PYG{n}{contents} \PYG{n}{of} \PYG{n}{the} \PYG{n}{specified} \PYG{n}{page} \PYG{k}{with} \PYG{n}{newContents}
\PYG{n}{PDPageAddCosContents} \PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{n}{PageStrm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{caution}{Caution:}
If you execute this code example without having a PDF document open, you will cause an Adobe Reader or Acrobat run\sphinxhyphen{}time error. The run\sphinxhyphen{}time error occurs because this code example creates a \sphinxcode{\sphinxupquote{PDPage}} object that is based on the current PDF document page.
\end{sphinxadmonition}


\subsection{Populating a PDF with a content stream}
\label{\detokenize{Plugins_Cos:populating-a-pdf-with-a-content-stream}}
This section explains how to use the Acrobat core API to create a new PDF document, insert a page into the document, and populate the page with a Cos content stream that inserts the text \sphinxcode{\sphinxupquote{Hello}} \sphinxcode{\sphinxupquote{There}}. When inserting a content stream into a PDF document, in addition to creating a stream dictionary, you must also create a resource dictionary and a page dictionary. A resource dictionary defines attributes such as the font that a content stream uses and a page dictionary defines attributes such as the page’s height and width. For information about these dictionaries, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}

The following example shows the resource dictionary that is created in this section.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{n}{obj}
\PYG{o}{\PYGZlt{}\PYGZlt{}}
\PYG{o}{/}\PYG{n}{Font} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{o}{/}\PYG{n}{F0} \PYG{l+m+mi}{5} \PYG{l+m+mi}{0} \PYG{n}{R} \PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{o}{/}\PYG{n}{ProcSet} \PYG{l+m+mi}{6} \PYG{l+m+mi}{0} \PYG{n}{R}
\PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{n}{endobj}
\end{sphinxVerbatim}

The following example shows the font descriptor that is created in this section.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5} \PYG{l+m+mi}{0} \PYG{n}{obj}
\PYG{o}{\PYGZlt{}\PYGZlt{}}
\PYG{o}{/}\PYG{n}{Type} \PYG{o}{/}\PYG{n}{Font}
\PYG{o}{/}\PYG{n}{Subtype} \PYG{o}{/}\PYG{n}{Type1}
\PYG{o}{/}\PYG{n}{Name} \PYG{o}{/}\PYG{n}{F0}
\PYG{o}{/}\PYG{n}{BaseFont} \PYG{o}{/}\PYG{n}{Courier}
\PYG{o}{/}\PYG{n}{Encoding} \PYG{o}{/}\PYG{n}{WinAnsiEncoding}
\PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{n}{endobj}
\end{sphinxVerbatim}

The following example shows the Procset resource created in this section.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{procset} \PYG{n}{resource}\PYG{o}{.}
\PYG{l+m+mi}{6} \PYG{l+m+mi}{0} \PYG{n}{obj}
\PYG{p}{[}
\PYG{o}{/}\PYG{n}{PDF} \PYG{o}{/}\PYG{n}{Text}
\PYG{p}{]}
\PYG{n}{endobj}
\end{sphinxVerbatim}

The following example shows the page dictionary that is created in this section.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{page} \PYG{n}{dictionary}\PYG{o}{.}
\PYG{l+m+mi}{7} \PYG{l+m+mi}{0} \PYG{n}{obj}
\PYG{o}{\PYGZlt{}\PYGZlt{}}
\PYG{o}{/}\PYG{n}{Type} \PYG{o}{/}\PYG{n}{Page}
\PYG{o}{/}\PYG{n}{MediaBox} \PYG{p}{[} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{612} \PYG{l+m+mi}{792} \PYG{p}{]}
\PYG{o}{/}\PYG{n}{Parent} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{n}{R}
\PYG{o}{/}\PYG{n}{Resources} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{n}{R}
\PYG{o}{/}\PYG{n}{Contents} \PYG{l+m+mi}{8} \PYG{l+m+mi}{0} \PYG{n}{R}
\PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{n}{endobj}
\end{sphinxVerbatim}

The following diagram shows the PDF document that is created in this section.

\noindent\sphinxincludegraphics{{HelloPDF}.png}

To create a PDF document and populate it with a Cos content stream:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Define the media box rectangle used in the PDF document’s page.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{ASFixedRect} \PYG{n}{MedBox}\PYG{p}{;}
  \PYG{n}{MedBox}\PYG{o}{.}\PYG{n}{left} \PYG{o}{=} \PYG{n}{ASInt32ToFixed} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{MedBox}\PYG{o}{.}\PYG{n}{top} \PYG{o}{=} \PYG{n}{ASInt32ToFixed} \PYG{p}{(}\PYG{l+m+mi}{792}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{MedBox}\PYG{o}{.}\PYG{n}{right} \PYG{o}{=} \PYG{n}{ASInt32ToFixed} \PYG{p}{(}\PYG{l+m+mi}{612}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{MedBox}\PYG{o}{.}\PYG{n}{bottom} \PYG{o}{=} \PYG{n}{ASInt32ToFixed} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Define the stream that is written to the PDF document page, as shown in the following example.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{char}\PYG{o}{*} \PYG{n}{StreamBuf} \PYG{o}{=} \PYG{p}{(}\PYG{n}{char}\PYG{o}{*}\PYG{p}{)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BT /F0 1 Tf 24 0 0 24 36 756 Tm 0 Tr 0 g 0 Tc 0 Tw}
  \PYG{p}{(}\PYG{n}{Hello} \PYG{n}{There}\PYG{p}{)} \PYG{n}{Tj} \PYG{n}{ET}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Create a \sphinxcode{\sphinxupquote{PDDoc}} object that represents the new document by invoking the \sphinxcode{\sphinxupquote{PDDocCreate}} method. After the document is created, at least one page must be added before Acrobat or Adobe Reader can display the document.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDDoc} \PYG{n}{NewDoc} \PYG{o}{=} \PYG{n}{PDDocCreate} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Create a \sphinxcode{\sphinxupquote{PDPage}} object that represents the page by invoking the \sphinxcode{\sphinxupquote{PDDocCreatePage}} method and passing the following arguments:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{PDDoc}} object that you created.

\item {} 
The \sphinxcode{\sphinxupquote{PDBeforeFirstPage}} enum value that specifies where to place the page.

\item {} 
The \sphinxcode{\sphinxupquote{ASFixedRect}} object that defines the media box rectangle.

\end{itemize}

\end{enumerate}

This method returns a \sphinxcode{\sphinxupquote{PDPage}} object that represents the new page.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Create a \sphinxcode{\sphinxupquote{CosObj}} object that represents a resource dictionary. In the following code example, a resource dictionary is created in a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{SetResourceForPage}}.

\item {} 
Set the page’s resource key. In the following code example, the page’s resource’s key is set in a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{CreateResourceDicts}}.

\item {} 
Add a Cos stream to the page. In the following code example, a Cos stream is added to the page in a user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{AddStreamToPage}}.

\item {} 
Open the PDF document in Adobe Reader or Acrobat. In the following code example, this task occurs in the user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{MakeTheFile}}.

\item {} 
Save the PDF document. In the following code example, this task occurs in the user\sphinxhyphen{}defined function named \sphinxcode{\sphinxupquote{MakeTheFile}}.

\end{enumerate}

The following code example represents an entire C source file that creates a PDF document and populates it with a Cos content stream. This source file is made up by various user\sphinxhyphen{}defined functions. To make it easier to view these functions, all function signatures are bolded. The entry point to this source file is the \sphinxcode{\sphinxupquote{MakeTheFile}} function. You can invoke the \sphinxcode{\sphinxupquote{MakeTheFile}} function from a menu item or toolbar button to execute this code example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZdq{}ascalls.h\PYGZdq{}
\PYGZsh{}include \PYGZdq{}avcalls.h\PYGZdq{}
\PYGZsh{}include \PYGZdq{}avcalls.h\PYGZdq{}
\PYGZsh{}include \PYGZdq{}coscalls.h\PYGZdq{}
\PYGZsh{}include \PYGZdq{}pdcalls.h\PYGZdq{}
\PYGZsh{}include \PYGZdq{}ascalls.h\PYGZdq{}
\PYGZsh{}include \PYGZdq{}corcalls.h\PYGZdq{}
\PYGZsh{}include \PYGZdq{}dos.h\PYGZdq{}
\PYGZsh{}include \PYGZlt{}io.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}

//Declare global variables
CosObj PageStrm; /* To hold the newly created Cos stream */
CosObj AttrDict; /* As returned by CreateAttribsDict */
CosObj EncodeDict;

//Used to specify what filters are used to encode the stream if used for output.
CosObj ResDict; /* Resource dictionary for the page */
CosObj FontDictObj;
CosObj FontDict;
CosObj procArray;

//Set the page\PYGZsq{}s resource key. Return true if everything is valid, else false.

ASBool SetResourceForPage (PDPage page)

\PYGZob{}
CosObj PageCosObj;

//Make sure that the page is valid
if (!page)
  return false;

DURING

//Get a CosDoc object by using the PDPage page passed to this object
PageCosObj = PDPageGetCosObj(page);

  if (CosDictKnown (PageCosObj, ASAtomFromString (\PYGZdq{}Resources\PYGZdq{}) == true))
      CosObjDestroy (CosDictGet (PageCosObj, ASAtomFromString (\PYGZdq{}Resources\PYGZdq{})));


//Place the ResDict object into the page\PYGZsq{}s Resource Dictionary
CosDictPut (PageCosObj, ASAtomFromString (\PYGZdq{}Resources\PYGZdq{}), ResDict);
HANDLER
  return false;
END\PYGZus{}HANDLER
return true;
\PYGZcb{} /* end of SetResourceForPage*/

//Create the font\PYGZsq{}s resources. Return true if all is valid, else false.
//Creates the required font and proc set dictionaries; then creates the global resource dictionary for the PDF page
ASBool CreateResourceDicts (CosDoc cd)

\PYGZob{}
DURING
  ResDict = CosNewDict (cd, true, 10);

HANDLER
  AVAlertNote(\PYGZdq{}Trying to create the resource dictionary.\PYGZdq{});
  return false;
  END\PYGZus{}HANDLER

DURING
  FontDictObj = CosNewDict (cd, true, 5);

HANDLER
  AVAlertNote (\PYGZdq{}Trying to create the font\PYGZsq{}s dictionary.\PYGZdq{});
  CosObjDestroy (ResDict);
  return false;
END\PYGZus{}HANDLER


/* Create this font descriptor dictionary.

   \PYGZlt{}\PYGZlt{}
   /Type /Font
   /Subtype /Type1
   /Name /F0
   /BaseFont /Courier
   /Encoding /WinAnsiEncoding
   \PYGZgt{}\PYGZgt{}
*/
DURING
  CosDictPut (FontDictObj, ASAtomFromString (\PYGZdq{}Type\PYGZdq{}),
  CosNewName (cd, false, ASAtomFromString (\PYGZdq{}Font\PYGZdq{})));
  CosDictPut (FontDictObj, ASAtomFromString (\PYGZdq{}Subtype\PYGZdq{}),
  CosNewName (cd, false, ASAtomFromString (\PYGZdq{}Type1\PYGZdq{})));
  CosDictPut (FontDictObj, ASAtomFromString (\PYGZdq{}Name\PYGZdq{}),
  CosNewName (cd, false, ASAtomFromString (\PYGZdq{}F0\PYGZdq{})));
  CosDictPut (FontDictObj, ASAtomFromString (\PYGZdq{}BaseFont\PYGZdq{}),
  CosNewName (cd,false, ASAtomFromString (\PYGZdq{}Courier\PYGZdq{})));
  CosDictPut (FontDictObj, ASAtomFromString (\PYGZdq{}Encoding\PYGZdq{}),
  CosNewName (cd,false, ASAtomFromString (\PYGZdq{}WinAnsiEncoding\PYGZdq{})));
HANDLER
  AVAlertNote(\PYGZdq{}Trying to add key\PYGZhy{}value pairs to the Font descriptor dictionary.\PYGZdq{});
  CosObjDestroy (FontDictObj);
  return false;
END\PYGZus{}HANDLER
DURING
  FontDict = CosNewDict (cd, false, 2);
HANDLER
  AVAlertNote (\PYGZdq{}Trying to create page\PYGZsq{}s resource dictionary.\PYGZdq{});
  CosObjDestroy (FontDictObj);
return false;
END\PYGZus{}HANDLER

   /* Add entries to the page\PYGZsq{}s resource dictionary.
      \PYGZlt{}\PYGZlt{}
      /Font \PYGZlt{}\PYGZlt{} /F0 5 0 R \PYGZgt{}\PYGZgt{}
      /ProcSet 6 0 R
      \PYGZgt{}\PYGZgt{}
   */

DURING

   /* Add /Font key\PYGZhy{}value pair to resource dictionary */
      CosDictPut (FontDict, ASAtomFromString (\PYGZdq{}F0\PYGZdq{}), FontDictObj);
      CosDictPut (ResDict, ASAtomFromString (\PYGZdq{}Font\PYGZdq{}), FontDict);
      HANDLER
      AVAlertNote  (\PYGZdq{}Trying to add key\PYGZhy{}value pairs to the page\PYGZsq{}s resource dict.\PYGZdq{});
      CosObjDestroy (FontDictObj);
      CosObjDestroy (FontDict);
      CosObjDestroy (ResDict);
      return false;
      END\PYGZus{}HANDLER

   /* Create the following proc set resource array.
   ** [
   ** /PDF /Text
   ** ]
   */
DURING
  procArray = CosNewArray (cd, true, 5);
HANDLER
  AVAlertNote  (\PYGZdq{}Trying to create proc set array.\PYGZdq{});
  CosObjDestroy (FontDictObj);
  CosObjDestroy (FontDict);
  CosObjDestroy (ResDict);
  return false;
END\PYGZus{}HANDLER

DURING
CosArrayPut (procArray, 0, CosNewName (cd, false, ASAtomFromString (\PYGZdq{}PDF\PYGZdq{})));
CosArrayPut (procArray, 1, CosNewName (cd, false, ASAtomFromString (\PYGZdq{}Text\PYGZdq{})));

/*Place the proc set key\PYGZhy{}value pair into the page\PYGZsq{}s resource dictionary.*/

CosDictPut (ResDict, ASAtomFromString (\PYGZdq{}ProcSet\PYGZdq{}), procArray);
HANDLER
  CosObjDestroy (FontDictObj);
  CosObjDestroy (FontDict);
  CosObjDestroy (ResDict);
  CosObjDestroy (procArray);
  return false;
END\PYGZus{}HANDLER
return true;
\PYGZcb{}

// Create and return the stream\PYGZsq{}s dictionary that defines the Length attribute
CosObj CreateAttribsDict(CosDoc Doc, ASInt32 Len)

\PYGZob{}
//Declare local variables
CosObj Dict; /* Holds newly created dictionary */
ASAtom Key; /* Key used to retrieve CosObj in dictionary */
CosObj Value; /* Assigned, then added to dictionary */
CosObj DecodeArray;

//Create the stream dictionary
Dict = CosNewDict(Doc, false, 10);
Key = ASAtomFromString(\PYGZdq{}Length\PYGZdq{});
Value = CosNewInteger(Doc, false, Len);
CosDictPut(Dict, Key, Value);
return Dict;
\PYGZcb{}

//Add stream to page. Return false if there are problems
ASBool AddStreamToPage (PDPage page, char* StreamBuf, ASInt32 StreamBufLen)

\PYGZob{}

//Declare local variables
CosDoc cd;
ASStm Stm=NULL;
CosObj PageStrm;
CosObj EncodeParms = CosNewNull();

DURING

//Create the CosDoc object
cd = PDDocGetCosDoc (PDPageGetDoc (page));

HANDLER
  AVAlertNote(\PYGZdq{}Unable to get CosDoc\PYGZdq{});
  return false;
END\PYGZus{}HANDLER


//Retrieve the Attributes dictionary
AttrDict = CreateAttribsDict (cd, StreamBufLen);

if (CosObjEqual (AttrDict, CosNewNull ()) == true)\PYGZob{}
  AVAlertNote(\PYGZdq{}Not making stream. Attribs dict not created.\PYGZdq{});
  return false;
\PYGZcb{}

//Read the stream into memory by invoking the ASMemStmRdOpen method
Stm = ASMemStmRdOpen (StreamBuf, StreamBufLen);
if (!Stm)\PYGZob{}
  AVAlertNote (\PYGZdq{}Unable to open data stream to create content stream.\PYGZdq{});
  return false;
\PYGZcb{}
DURING

//Creates a new Cos stream using data from the ASStm object
PageStrm = CosNewStream(cd, true, Stm, \PYGZhy{}1,
  false,
  AttrDict, /* attributesDict */
  EncodeParms,
  \PYGZhy{}1);

ASStmClose (Stm);

HANDLER
  AVAlertNote (\PYGZdq{}Trying to create new CosStream.\PYGZdq{});
  CosObjDestroy (AttrDict);
  ASStmClose (Stm);
  return false;
END\PYGZus{}HANDLER


//Add the content stream to the page
PDPageAddCosContents (page, PageStrm);
return true;
\PYGZcb{} /* end of AddStreamToPage */


//Create the new PDF document
void MakeTheFile (void)

\PYGZob{}

//Declare local variables
volatile PDDoc NewDoc = NULL;
volatile PDPage NewPage;
ASFixedRect MedBox;
ASInt32 PageCount = 0;
char* StreamBuf = NULL;
int StreamBufLen = 0;
ASBool result ;

//Set up the page\PYGZsq{}s media box.
MedBox.left = ASInt32ToFixed (0);
MedBox.top = ASInt32ToFixed (792);
MedBox.right = ASInt32ToFixed (612);
MedBox.bottom = ASInt32ToFixed (0);

//Define a stream to set the text matrix and write out the text
StreamBuf = (char*)\PYGZdq{}BT /F0 1 Tf 24 0 0 24 36 756 Tm 0 Tr 0 g 0 Tc 0 Tw (Hello There) Tj ET\PYGZdq{};

//Get the length of StreamBufLen \PYGZhy{} this is where is it determined
StreamBufLen = strlen (StreamBuf);

DURING

//Create a PDDoc object
NewDoc = PDDocCreate();
  if (NewDoc) \PYGZob{}

//Invoke the PDDocCreatePage method
//  NewPage = PDDocCreatePage(NewDoc, PDBeforeFirstPage, MedBox);
      if (!NewPage)
          ASRaise (0);

//Invoke CreateResourceDicts
//  if (CreateResourceDicts(PDDocGetCosDoc(NewDoc)) == false)
          ASRaise (0);


//Invoke SetResourceForPage method
result = SetResourceForPage(NewPage);

// Invoke AddStreamToPage
result = AddStreamToPage (NewPage, StreamBuf, StreamBufLen);
  if (result == false)
      ASRaise (0);

  PDPageRelease (NewPage);
\PYGZcb{}
HANDLER
  AVAlertNote (\PYGZdq{}Problem creating document.\PYGZdq{});
  if (NewPage) PDPageRelease (NewPage);
  if (NewDoc) PDDocClose (NewDoc);
  return;
END\PYGZus{}HANDLER
DURING


//Open the new doc
AVDocOpenFromPDDoc(NewDoc, NULL);


//Save the PDF document to the root of C and name it cosPDFDocument.pdf
PDDocSave(NewDoc, PDSaveFull | PDSaveLinearized,ASPathFromPlatformPath

(\PYGZdq{}C:cosPDFDocument.pdf\PYGZdq{}), NULL, NULL, NULL);

HANDLER
  AVAlertNote (\PYGZdq{}Cannot open new document.\PYGZdq{});
END\PYGZus{}HANDLER
\PYGZcb{}
\end{sphinxVerbatim}


\chapter{Working with 3D Annotations}
\label{\detokenize{Plugins_3D_samples:working-with-3d-annotations}}\label{\detokenize{Plugins_3D_samples::doc}}
Three\sphinxhyphen{}dimensional annotations can be viewed in a PDF document by means of \sphinxstyleemphasis{3D annotations}. This chapter explains how to create 3D annotations and modify existing ones by using Cos objects. Before you read this chapter, it is strongly recommended that you become familiar with Cos objects. (See \sphinxhref{Plugins\_Cos.html\#50618418\_86959}{Working with Cos Objects}.)

The underlying 3D object data in a 3D annotation must conform to the Adobe PRC Format Specification the Universal 3D (U3D) format developed by the 3D Industry Forum ( \sphinxurl{http://www.3dif.org} ). Acrobat supports a subset of U3D, as described in the document \sphinxstyleemphasis{U3D Elements}, which can be found at the \sphinxhref{http://www.adobe.com/go/acrobat\_developer}{Acrobat Developer Center}.


\section{Creating 3D annotations}
\label{\detokenize{Plugins_3D_samples:creating-3d-annotations}}
Before you can add three\sphinxhyphen{}dimensional data to an annotation, you must create it. Annotations are represented by an annotation dictionary. A \sphinxstyleemphasis{dictionary} is a data structure with one or more entries, which are \sphinxstyleemphasis{key\sphinxhyphen{}value pairs:}
\begin{itemize}
\item {} 
The key is a \sphinxstyleemphasis{name object}.

\item {} 
The value is some type of PDF object. The \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. describes all the PDF object types. If the value is a dictionary, that dictionary has its own key\sphinxhyphen{}value pairs. Therefore, dictionaries can be nested within other dictionaries (as you will see with the 3D structures). For details, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}.

\end{itemize}

General annotation dictionary entries are described in Table 8.15 in the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. Those specific to 3D annotations are described in Table 9.33.

The following code example creates a 3D annotation with corners (1, 9.5) and (7,4) using the \sphinxcode{\sphinxupquote{PDPageAddNewAnnot}} method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASFixedRect} \PYG{n}{annotRect}\PYG{p}{;}
 \PYG{n}{annotRect}\PYG{o}{.}\PYG{n}{left}   \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{annotRect}\PYG{o}{.}\PYG{n}{top}    \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mf}{9.5}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{annotRect}\PYG{o}{.}\PYG{n}{right}  \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mf}{7.0}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{annotRect}\PYG{o}{.}\PYG{n}{bottom} \PYG{o}{=} \PYG{n}{Int16ToFixed}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{l+m+mi}{72}\PYG{p}{)}\PYG{p}{;}

 \PYG{n}{PDAnnot} \PYG{n}{newAnnot} \PYG{o}{=} \PYG{n}{PDPageAddNewAnnot}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3D}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{o}{\PYGZam{}}\PYG{n}{annotRect}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This method contains the following parameters:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{PDPage}} on which to place the annotation.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} indicating where to add the annotation in the page’s annotation array. The value \sphinxhyphen{}2 is normally used and means the annotation is added to the end of the page’s annotation array. For information about this value, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.

\item {} 
The type of the annotation, which in this case is \sphinxcode{\sphinxupquote{3D}}. This sets the value of the annotation dictionary’s \sphinxcode{\sphinxupquote{Subtype}} entry. It is important to note that in PDF this is a \sphinxstyleemphasis{name object}, not a string. In the API, the \sphinxcode{\sphinxupquote{ASAtom}} type is frequently used to represent names; the \sphinxcode{\sphinxupquote{ASAtomFromString}} method converts a string to a name.

\item {} 
The rectangle in which the annotation appears on the page. This sets the value of the annotation dictionary’s \sphinxcode{\sphinxupquote{Rect}} entry.

\end{itemize}

After the annotation has been created, you must complete the other entries in the annotation dictionary. The \sphinxcode{\sphinxupquote{F}} (flags) entry is set here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDAnnotSetFlags}\PYG{p}{(}\PYG{n}{newAnnot}\PYG{p}{,} \PYG{n}{pdAnnotPrint} \PYG{o}{|} \PYG{n}{pdAnnotReadOnly}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The annotation’s initial appearance (the \sphinxcode{\sphinxupquote{AP}} entry) can be set. (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_59797}{Setting the annotation appearance}.)

Other entries are set using the \sphinxcode{\sphinxupquote{EmbedDataIn3Dannot}} function (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_21047}{Adding 3D data to an annotation}.)

If you add PRC data to a 3D annotation, you must also ensure that the document’s \sphinxcode{\sphinxupquote{Catalog}} dictionary contains an Adobe \sphinxcode{\sphinxupquote{Extension}} dictionary that specifies the PDF base version (\sphinxcode{\sphinxupquote{1.7}} ) and extension level (\sphinxcode{\sphinxupquote{1}} or greater) that added PRC data to 3D annotations. (See \sphinxhref{Plugins\_Documents.html\#50618416\_53916}{PDF version extensions}.)


\section{Adding 3D data to an annotation}
\label{\detokenize{Plugins_3D_samples:adding-3d-data-to-an-annotation}}
The Acrobat and PDF Library API does not contain methods for working specifically with 3D annotations. To add entries to a 3D annotation dictionary, you must use Cos\sphinxhyphen{}level API methods. These methods enable you to create PDF objects of any type (see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. ) and to set their values.

The Cos API uses two primary object types:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CosDoc}} represents an entire PDF document.

\item {} 
\sphinxcode{\sphinxupquote{CosObj}} represents all other PDF objects: simple types like numbers and string values as well as complex types such as dictionaries, arrays, and streams.

\end{itemize}

The API provides methods for creating and working with different object types. The creation methods are of the form \sphinxcode{\sphinxupquote{CosNew}} Object, where Object is the object being created: for example, \sphinxcode{\sphinxupquote{CosNewDict}}, which creates a dictionary object, \sphinxcode{\sphinxupquote{CosNewBoolean}}, and \sphinxcode{\sphinxupquote{CosNewStream}}.

The first two parameters for the \sphinxcode{\sphinxupquote{CosNew}} Object methods (with the exception of \sphinxcode{\sphinxupquote{CosNewNull}}, which takes no parameters) are these:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{CosDoc}} object that represents the current document.

\item {} 
A Boolean parameter that specifies whether the new object should be indirect. Indirect objects (see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. ) are given object numbers and can be referred to from more than one place in a PDF file. Direct objects are specified only where they are used and cannot be referred to from anywhere else.

\end{itemize}

The remaining parameters vary depending on the object type:
\begin{itemize}
\item {} 
For simple types, the third parameter specifies its value. For arrays and dictionaries, the third parameter specifies the number of elements.

\item {} 
For streams, there are several additional parameters. See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference} for details on each method.

\end{itemize}

The return value of these methods is the newly created object. In the API, this object is always a \sphinxcode{\sphinxupquote{CosObj}}. That is, even though you call \sphinxcode{\sphinxupquote{CosNewDict}} to create a dictionary object, and you use methods like \sphinxcode{\sphinxupquote{CosDictPut}} to work with dictionary objects, there is not a formal object type called \sphinxcode{\sphinxupquote{CosDict}}.

If necessary, you can determine the type of a \sphinxcode{\sphinxupquote{CosObj}} by calling the \sphinxcode{\sphinxupquote{CosObjGetType}} method, which returns a constant (\sphinxcode{\sphinxupquote{CosNull}}, \sphinxcode{\sphinxupquote{CosInteger}}, \sphinxcode{\sphinxupquote{CosFixed}}, \sphinxcode{\sphinxupquote{CosReal}}, \sphinxcode{\sphinxupquote{CosBoolean}}, \sphinxcode{\sphinxupquote{CosName}}, \sphinxcode{\sphinxupquote{CosString}}, \sphinxcode{\sphinxupquote{CosDict}}, \sphinxcode{\sphinxupquote{CosArray}}, or \sphinxcode{\sphinxupquote{CosStream}} ).

Most of the code described here involves setting the entries of dictionaries (\sphinxcode{\sphinxupquote{CosObjs}} of type \sphinxcode{\sphinxupquote{CosDict}} ). Dictionaries contain a number of key\sphinxhyphen{}value pairs, where the key is a \sphinxstyleemphasis{name object} and the value is any type of \sphinxcode{\sphinxupquote{CosObj}}.

There are several common methods that can be used, which differ only in how the keys are specified. The \sphinxcode{\sphinxupquote{CosDictPutKeyString}} method (available in Acrobat 7.0 or later) allows the key to be specified as a string and is the recommended method, as in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{theDict}\PYG{p}{,}   \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{dictionary}
     \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TheKey}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}                   \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{key}\PYG{p}{:} \PYG{n}{a} \PYG{n}{string}
     \PYG{n}{theCosValue}\PYG{p}{)}\PYG{p}{;}               \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{value}\PYG{p}{:} \PYG{n}{a} \PYG{n}{CosObj}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{CosDictPut}} requires the key to be specified as an \sphinxcode{\sphinxupquote{ASAtom}}. \sphinxcode{\sphinxupquote{CosDictPutKey}} requires the key to be a name object (a \sphinxcode{\sphinxupquote{CosObj}} of type \sphinxcode{\sphinxupquote{CosName}} ).


\subsection{Creating the 3D annotation dictionary entries}
\label{\detokenize{Plugins_3D_samples:creating-the-3d-annotation-dictionary-entries}}
To work with annotations at the Cos level, you must get the Cos object corresponding to the \sphinxcode{\sphinxupquote{PDAnnot}} object. To perform this task, invoke the \sphinxcode{\sphinxupquote{PDAnnotGetCotObj}} method and pass the \sphinxcode{\sphinxupquote{PDAnnot}} object, as shown in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{cosAnnot} \PYG{o}{=} \PYG{n}{PDAnnotGetCosObj}\PYG{p}{(}\PYG{n}{theAnnot}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, get the \sphinxcode{\sphinxupquote{CosDoc}} object corresponding to the document by invoking the \sphinxcode{\sphinxupquote{CosObjGetDoc}} method and passing the \sphinxcode{\sphinxupquote{CosObj}} object, as shown in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDoc} \PYG{n}{cosDoc} \PYG{o}{=} \PYG{n}{CosObjGetDoc}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Two additional dictionary entries (which are not specific to 3D annotations)—the \sphinxcode{\sphinxupquote{P}} (page) and \sphinxcode{\sphinxupquote{Contents}} entries—can be set as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{P}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{PDPageGetCosObj}\PYG{p}{(}\PYG{n}{pdPage}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Contents}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{n}{CosNewString}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3D Model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3D Model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The following sections show how to set the dictionary entries that are specific to 3D annotations: (See Table 9.33 in the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}.)

\sphinxstyleemphasis{3DD} : A 3D stream specifying the 3D content (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_14693}{Specifying the 3D stream}.)

\sphinxstyleemphasis{3DV} : The initial view of the 3D content (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_69581}{Setting the default view}.)

\sphinxstyleemphasis{3DA} : The activation dictionary (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_16449}{Setting the activation dictionary}.)


\subsection{Specifying the 3D stream}
\label{\detokenize{Plugins_3D_samples:specifying-the-3d-stream}}
The \sphinxcode{\sphinxupquote{3DD}} entry of the annotation dictionary specifies a \sphinxstyleemphasis{stream} containing the PRC or U3D data. Streams are PDF objects that can be thought of as having two parts, the stream data and an associated dictionary:
\begin{itemize}
\item {} 
Stream data is the PRC or U3D data that represents the 3D content.

\item {} 
The associated dictionary (sometimes called the \sphinxstyleemphasis{attributes dictionary} ) contains entries that specify information about the stream. Some entries are common to all stream dictionaries (see Table 3.4 in the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. ). They include:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Length} (required): The length of the stream data

\item {} 
\sphinxstyleemphasis{Filter} (optional): A compression filter that is applied to the data to reduce its size (there are also filters that do not compress data)

\end{itemize}

\end{itemize}

Other entries are unique to 3D streams (see Table 9.35 in the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. ). They include:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Type} (optional): Must be \sphinxcode{\sphinxupquote{3D}} if present.

\item {} 
\sphinxstyleemphasis{Subtype} (required): For PRC data, set this value to \sphinxcode{\sphinxupquote{PRC}} ; for U3D data, set this value to \sphinxcode{\sphinxupquote{U3D}}.

\item {} 
\sphinxstyleemphasis{OnInstantiate} (optional): A JavaScript script to be executed when the 3D stream is read. (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_12859}{Specifying JavaScript code}.)

\end{itemize}


\subsubsection{Creating the stream object}
\label{\detokenize{Plugins_3D_samples:creating-the-stream-object}}
You must create a Cos stream that is based on the file containing the PRC or U3D data (this file was created with 3D authoring software) in order to create a 3D annotation. A data stream can be a buffer in memory, a file, or an arbitrary user\sphinxhyphen{}written procedure. A stream is represented by an \sphinxcode{\sphinxupquote{ASStm}} object, which must be converted into a Cos stream.

To create a Cos stream that is based on the file that contains the PRC or U3D data, perform the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an \sphinxcode{\sphinxupquote{ASPathName}} object that represents the file that contains the PRC or U3D data by invoking the \sphinxcode{\sphinxupquote{ASPathFromPlatformPath}} method and passing a character pointer that specifies the location of the file that contains the PRC or U3D data. If you are working on the Mac OS platform, invoke the \sphinxcode{\sphinxupquote{GetMacPath}} method and pass a character pointer that specifies the file location.

\item {} 
Declare an \sphinxcode{\sphinxupquote{ASFile}} object.

\item {} 
Populate the \sphinxcode{\sphinxupquote{ASFile}} object with the PRC or U3D data by invoking the \sphinxcode{\sphinxupquote{ASFileSysOpenFile}} method and passing the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{ASFileSys}} object that represents the file system in which the PDF file is located. Invoke the \sphinxcode{\sphinxupquote{ASGetDefaultFileSys}} method to get the default file system.

\item {} 
An \sphinxcode{\sphinxupquote{ASPathName}} object that represents the path in which the file that contains the PRC or U3D data is located (pass the \sphinxcode{\sphinxupquote{ASPathName}} object created in step 1).

\item {} 
An \sphinxcode{\sphinxupquote{ASFileMode}} object that represents the mode in which to open the file. For example, specify \sphinxcode{\sphinxupquote{ASFILE\_READ}} to open the file in read mode.

\item {} 
The address of an \sphinxcode{\sphinxupquote{ASFile}} object. The \sphinxcode{\sphinxupquote{ASFileSysOpenFile}} method populates this argument using the file that was opened (file information is obtained from the \sphinxcode{\sphinxupquote{ASPathName}} object).

\end{itemize}

\item {} 
Create an \sphinxcode{\sphinxupquote{ASStm}} object by invoking the \sphinxcode{\sphinxupquote{ASFileStmRdOpen}} method and passing the following arguments:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{ASFile}} object with the file that contains the PRC or U3D data.

\item {} 
Length of data buffer, in bytes. If you specify \sphinxcode{\sphinxupquote{0}}, then the default buffer size (currently 4kB) is used.

\end{itemize}

\item {} 
Invoke the \sphinxcode{\sphinxupquote{CosNewStream}} method to create a Cos stream containing the data that is located within the \sphinxcode{\sphinxupquote{ASStm}} object. This Cos stream will become the value of the 3DD entry of the 3D annotation. Pass the following arguments to this method:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{CosDoc}} object that specifies the PDF document in which the Cos stream is inserted.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the Cos stream is an indirect object. Because all streams are indirect objects, this argument must be set to \sphinxcode{\sphinxupquote{true}}.

\item {} 
An \sphinxcode{\sphinxupquote{ASStm}} object that contains the stream data (pass the \sphinxcode{\sphinxupquote{ASStm}} object created in step 4).

\item {} 
A \sphinxcode{\sphinxupquote{CosStreamStartAndCode}} object that specifies the byte offset from which data reading starts. You can pass \sphinxcode{\sphinxupquote{0}} to ensure that data reading starts at the beginning of the stream.

\item {} 
An \sphinxcode{\sphinxupquote{ASBool}} object that specifies whether the data is encoded using filters specified in the stream dictionary before it is written to the Cos stream.

\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that represents the stream dictionary. You can invoke the \sphinxcode{\sphinxupquote{CosNewNull}} method.

\item {} 
A \sphinxcode{\sphinxupquote{CosObj}} object that represents the parameters that are used by the encoding filter if the source data is encoded before it is written to the file. If encoding parameters are not required, this value is ignored. For information about encoding filters, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}.

\item {} 
A \sphinxcode{\sphinxupquote{CosByteMax}} object that specifies the amount of data read from the source. If this value is \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}, data is read from the source until it reaches the end of the stream.

\end{itemize}

\end{enumerate}

The \sphinxcode{\sphinxupquote{CosNewStream}} method returns a \sphinxcode{\sphinxupquote{CosObj}} object that represents the Cos stream. The following code example creates a Cos stream.
\begin{quote}

//Create an ASPathName that specifies the location of the.U3D file

//u3dFileName is a character pointer that specifies the path to this file
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{ASPathName} \PYG{n}{u3DPathName} \PYG{o}{=}  \PYG{n}{ASPathFromPlatformPath}\PYG{p}{(}\PYG{p}{(}\PYG{n}{void}\PYG{o}{*}\PYG{p}{)} \PYG{n}{u3dFileName}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASFile} \PYG{n+nb}{object} \PYG{o+ow}{and} \PYG{n}{populate} \PYG{n}{it}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{ASFile} \PYG{n}{asFile} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
  \PYG{n}{ASInt32} \PYG{n}{err} \PYG{o}{=} \PYG{n}{ASFileSysOpenFile}\PYG{p}{(}\PYG{n}{ASGetDefaultFileSys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u3DPathName}\PYG{p}{,}     \PYG{n}{ASFILE\PYGZus{}READ}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{asFile}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ASFileSysReleasePath} \PYG{p}{(}\PYG{n}{ASGetDefaultFileSys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u3DPathName}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{if} \PYG{p}{(}\PYG{n}{asFile} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
      \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error opening 3D data file.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Read} \PYG{n}{data} \PYG{n}{stream} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{n}{file}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{ASStm} \PYG{n}{fileStm} \PYG{o}{=} \PYG{n}{ASFileStmRdOpen}\PYG{p}{(}\PYG{n}{asFile}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{fileStm} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
      \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Empty 3D data stream.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{a} \PYG{n}{new} \PYG{n}{Cos} \PYG{n}{stream} \PYG{o+ow}{and} \PYG{n+nb}{set} \PYG{n}{it} \PYG{n}{under} \PYG{l+m+mi}{3}\PYG{n}{DD} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{annot} \PYG{n}{dictionary}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{stm3D} \PYG{o}{=} \PYG{n}{CosNewStream}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{true}\PYG{p}{,} \PYG{n}{fileStm}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{CosNewNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
 \PYG{n}{CosNewNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Adding the Cos stream to the annotation dictionary}
\label{\detokenize{Plugins_3D_samples:adding-the-cos-stream-to-the-annotation-dictionary}}
After you create a a \sphinxcode{\sphinxupquote{CosObj}} object that represents the Cos stream, invoke the \sphinxcode{\sphinxupquote{CosDictPutKeyString}} method to add the Cos stream as the value of the \sphinxcode{\sphinxupquote{3DD}} entry of the annotation dictionary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{,}   \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{annotation} \PYG{n}{dictionary}
      \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3DD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}                       \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{key}
      \PYG{n}{stm3D}\PYG{p}{)}\PYG{p}{;}                      \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{CosObj} \PYG{n+nb}{object} \PYG{n}{used} \PYG{k}{as} \PYG{n}{the}
\PYG{n}{value}
\end{sphinxVerbatim}


\subsubsection{Creating the attributes dictionary}
\label{\detokenize{Plugins_3D_samples:creating-the-attributes-dictionary}}
Complete the entries in the 3D stream dictionary. The \sphinxcode{\sphinxupquote{CosStreamDict}} method obtains the Cos dictionary associated with the stream:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{attrObj} \PYG{o}{=} \PYG{n}{CosStreamDict}\PYG{p}{(}\PYG{n}{stm3D}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, entries can be added to the dictionary. The \sphinxcode{\sphinxupquote{Type}} and \sphinxcode{\sphinxupquote{Subtype}} entries both take name objects as values. Therefore, strings specified in the code must be explicitly converted to names:
\begin{quote}

//Set the stream’s dictionary
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{attrObj}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Subtype}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CosNewName}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}
 \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U3D}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{attrObj}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CosNewNameFromString}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3D}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Specifying JavaScript code}
\label{\detokenize{Plugins_3D_samples:specifying-javascript-code}}
You can create JavaScript that manipulates the 3D annotation. JavaScript is optional and if you do not specify it, then the 3D annotation is still inserted into the PDF document; however, it remains a static graphic. For information about creating JavaScript that manipulates 3D annotations, see the \sphinxstyleemphasis{JavaScript for Acrobat 3D Annotations API Reference}.

The following code example creates an \sphinxcode{\sphinxupquote{ASFile}} object and populates it with the JavaScript file. The \sphinxcode{\sphinxupquote{JsFileName}} variable is a character pointer that specifies the location of the JavaScript file.
\begin{quote}

//Create a char pointer that specifies the location of the JavaScript file
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{char}\PYG{o}{*}\PYG{n}{JsFileName} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:3DJavaScript.js}\PYG{l+s+s2}{\PYGZdq{}}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{an} \PYG{n}{ASFile} \PYG{n+nb}{object} \PYG{n}{that} \PYG{n}{will} \PYG{n}{reference} \PYG{n}{the} \PYG{n}{JavaScript} \PYG{n}{file}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{ASFile} \PYG{n}{jsFile} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Create} \PYG{n}{an} \PYG{n}{ASPathName} \PYG{n+nb}{object} \PYG{n}{based} \PYG{n}{on} \PYG{n}{the} \PYG{n}{JavaScript} \PYG{n}{file}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{ASPathName} \PYG{n}{JsPathName} \PYG{o}{=}  \PYG{n}{ASPathFromPlatformPath}\PYG{p}{(}\PYG{p}{(}\PYG{n}{void}\PYG{o}{*}\PYG{p}{)} \PYG{n}{JsFileName}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/}\PYG{n}{Populate} \PYG{n}{the} \PYG{n}{ASFile} \PYG{n+nb}{object}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{p}{(}\PYG{n}{JsPathName}\PYG{p}{)}
     \PYG{n}{ASInt32} \PYG{n}{err1} \PYG{o}{=} \PYG{n}{ASFileSysOpenFile}\PYG{p}{(}\PYG{n}{ASGetDefaultFileSys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{JsPathName}\PYG{p}{,}
     \PYG{n}{ASFILE\PYGZus{}READ}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{jsFile}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, the data from the file is read into a stream:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASStm} \PYG{n}{JsFileStm} \PYG{o}{=} \PYG{n}{ASFileStmRdOpen}\PYG{p}{(}\PYG{n}{jsFile}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In the following code, an entry is added to the stream dictionary in the process of creating the stream, rather than afterwards as in the previous code. First, the \sphinxcode{\sphinxupquote{CosNewDict}} method is used to create a new dictionary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{dictJsStm} \PYG{o}{=} \PYG{n}{CosNewDict}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This method requires three parameters:
\begin{itemize}
\item {} 
The document in which the dictionary is used.

\item {} 
A Boolean value that specifies whether the dictionary should be an indirect object. All stream dictionaries must be direct; hence the value of this parameter is \sphinxcode{\sphinxupquote{false}}.

\item {} 
A hint for the number of entries in the dictionary (however, dictionaries grow dynamically as needed).

\end{itemize}

Next, the value of the \sphinxcode{\sphinxupquote{Filter}} entry is set to \sphinxcode{\sphinxupquote{FlateDecode}} using the \sphinxcode{\sphinxupquote{CosDictPutKeyString}} method. This means that the stream will be compressed using Flate (ZIP) compression.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{dictJsStm}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Filter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
     \PYG{n}{CosNewNameFromString}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FlateDecode}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, the Cos stream is created, using the stream data and attributes dictionary already created:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{stm3Djscode} \PYG{o}{=} \PYG{n}{CosNewStream}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{true}\PYG{p}{,}
     \PYG{n}{JsFileStm}\PYG{p}{,}    \PYG{o}{/}\PYG{o}{/}\PYG{n}{The} \PYG{n}{stream}
     \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{true}\PYG{p}{,}
     \PYG{n}{dictJsStm}\PYG{p}{,}   \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{stream} \PYG{n}{dictionary}
     \PYG{n}{CosNewNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Set it as the value of the \sphinxcode{\sphinxupquote{OnInstantiate}} entry of the 3D stream dictionary. The following code example specifies a JavaScript script as the value of the \sphinxcode{\sphinxupquote{OnInstantiate}} entry of the 3D stream dictionary.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{attrObj}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{OnInstantiate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stm3Djscode}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Then some cleanup is done:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASFileSysReleasePath} \PYG{p}{(}\PYG{n}{ASGetDefaultFileSys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{JsPathName}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{ASStmClose}\PYG{p}{(}\PYG{n}{JsFileStm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Setting the default view}
\label{\detokenize{Plugins_3D_samples:setting-the-default-view}}
A 3D \sphinxstyleemphasis{view} specifies parameters such as position, orientation, and projection style, which are applied to the \sphinxstyleemphasis{virtual camera} associated with the 3D annotation (see section 9.5.3 in the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. ). The \sphinxstyleemphasis{default view} is the view that is chosen when the annotation is activated.

3D data typically contains a default initial view. This view is used by default if not otherwise specified. In addition, views can be specified by the entries in a view dictionary.

The \sphinxcode{\sphinxupquote{VA}} entry in the 3D stream dictionary is an array of view dictionaries. One of the views can be chosen as the default by means of the \sphinxcode{\sphinxupquote{3DV}} entry in the 3D annotation dictionary or the \sphinxcode{\sphinxupquote{DV}} entry in a 3D stream dictionary.

The following code creates a view dictionary and specifies its entries. The code assumes the Cos objects \sphinxcode{\sphinxupquote{cosAnnot}} for the annotation and \sphinxcode{\sphinxupquote{cosDoc}} for the document have already been obtained. First, a view dictionary is created by invoking the \sphinxcode{\sphinxupquote{CosNewDict}} method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{cosView} \PYG{o}{=} \PYG{n}{CosNewDict} \PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{true}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, the code sets the following entries: (See Table 9.39 in the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. for more detailed information.)

\sphinxstyleemphasis{Type} (optional): If present, must be the name \sphinxcode{\sphinxupquote{3DView}}.

\sphinxstyleemphasis{XN} (required): The name of the view, a string that can be displayed in the user interface.

\sphinxstyleemphasis{IN} (optional): The internal name of the view, a string that can be used to refer to the view from other objects, such as in JavaScript code.

\sphinxstyleemphasis{C2W} (optional): A transformation matrix specifying the camera position. To use this, it is also necessary to set the value of the \sphinxcode{\sphinxupquote{MS}} entry to \sphinxcode{\sphinxupquote{M}}.

\sphinxstyleemphasis{CO} (optional): A number indicating the distance to the center of orbit for this view.

The following code creates an array of type \sphinxcode{\sphinxupquote{double}} and specifies values for views:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{char}\PYG{o}{*} \PYG{n}{externalViewName} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Default View}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
 \PYG{n}{char}\PYG{o}{*} \PYG{n}{internalViewName} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sample3dView}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

 \PYG{n}{double} \PYG{n}{gMatrixVals}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]} \PYG{o}{=}
     \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0000000000000000612303}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{,}
     \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{0.0000000000000000612303}\PYG{p}{,} \PYG{l+m+mf}{82.9517}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{883.324}\PYG{p}{,} \PYG{l+m+mf}{115.166}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
 \PYG{n+nb}{float} \PYG{n}{gCOvalue} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)} \PYG{l+m+mf}{725.305}\PYG{p}{;}
\end{sphinxVerbatim}

Now the values of the dictionary entries are set:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosView}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
     \PYG{n}{CosNewNameFromString}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3DView}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosView}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{XN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CosNewString}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}
     \PYG{n}{externalViewName}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{externalViewName}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosView}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CosNewString}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}
     \PYG{n}{internalViewName}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{internalViewName}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosView}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
     \PYG{n}{CosNewNameFromString}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosView}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CO}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CosNewFixed}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}
     \PYG{n}{FloatToASFixed}\PYG{p}{(}\PYG{n}{gCOvalue}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here the \sphinxcode{\sphinxupquote{C2W}} matrix is populated with the appropriate values:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{matrixArray} \PYG{o}{=} \PYG{n}{CosNewArray}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;}
     \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{12}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
         \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{matrixArray}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,}
             \PYG{n}{CosNewFloat}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)} \PYG{n}{gMatrixVals}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosView}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C2W}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{matrixArray}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Last, the dictionary is set as the value of the \sphinxcode{\sphinxupquote{3DV}} key in the annotation dictionary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3DV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cosView}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Setting the annotation appearance}
\label{\detokenize{Plugins_3D_samples:setting-the-annotation-appearance}}
You may optionally provide a \sphinxstyleemphasis{poster} as the initial appearance of the annotation. The poster may be an image or other graphic content that is in a file or in memory. It must be converted to a PDF \sphinxstyleemphasis{form XObject} to be used as the annotation appearance (see section 4.9 of the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. ).

The \sphinxcode{\sphinxupquote{AP}} entry of the annotation dictionary specifies an \sphinxstyleemphasis{appearance dictionary.} This dictionary contains one or more \sphinxstyleemphasis{appearance streams} (see section 8.4.4 of the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. ) that are PDF content streams (form XObjects) rendered inside the annotation rectangle.

For 3D annotations, the appearance stream is used in the following situations:
\begin{itemize}
\item {} 
To provide an annotation appearance for PDF viewers that do not support 3D.

\item {} 
To provide an initial appearance for the annotation prior to activation. The settings in the activation dictionary determine whether this appearance is ever displayed.

\end{itemize}

There are several ways to get the poster. The function described below, \sphinxcode{\sphinxupquote{GetFormXObjectFromFile}}, illustrates one method. The appearance is generated from a separate PDF file containing an image or other content. You call this function as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{formXObject} \PYG{o}{=} \PYG{n}{GetFormXObjectFromFile}
     \PYG{p}{(}\PYG{n}{gsPosterFilePath}\PYG{p}{,} \PYG{o}{/}\PYG{o}{/}\PYG{n}{The} \PYG{n}{external} \PYG{n}{file}
     \PYG{n}{pdDoc}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The function returns a Cos object, \sphinxcode{\sphinxupquote{formXObject}}, which is the form XObject to be used as the appearance.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{cosAnnot} \PYG{o}{=} \PYG{n}{PDAnnotGetCosObj}\PYG{p}{(}\PYG{n}{newAnnot}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosDoc} \PYG{n}{cosDoc} \PYG{o}{=} \PYG{n}{CosObjGetDoc}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Then you create the appearance dictionary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{apprDict} \PYG{o}{=} \PYG{n}{CosNewDict}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and set its \sphinxcode{\sphinxupquote{N}} (normal) entry to the appearance stream obtained above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{apprDict}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{N}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{formXObject}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AP}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{apprDict}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The following is the \sphinxcode{\sphinxupquote{GetFormXObjectFromFile}} function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{GetFormXObjectFromFile}
     \PYG{p}{(}\PYG{n}{char}\PYG{o}{*} \PYG{n}{pdfImageFilePath}\PYG{p}{,} \PYG{o}{/}\PYG{o}{/}\PYG{n}{Path} \PYG{n}{of} \PYG{n}{image} \PYG{n}{PDF} \PYG{n}{file}
     \PYG{n}{PDDoc} \PYG{n}{TargetPdDoc}\PYG{p}{)}          \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{current} \PYG{n}{document}
 \PYG{p}{\PYGZob{}}
 \PYG{n}{PDDoc} \PYG{n}{posterPDFDoc} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}                  \PYG{o}{/}\PYG{o}{/}\PYG{n}{Initialization} \PYG{n}{code}
 \PYG{n}{PDPage} \PYG{n}{pdPageImage} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{ASPathName} \PYG{n}{asPathName}\PYG{p}{;}
 \PYG{n}{CosObj} \PYG{n}{contentFormXObject} \PYG{o}{=} \PYG{n}{CosNewNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosObj} \PYG{n}{formXObject} \PYG{o}{=} \PYG{n}{CosNewNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

First, the PDF file containing the image is opened:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if(strlen(pdfImageFilePath) \PYGZgt{} 0 ) \PYGZob{}
     char sPathFlag[16] = \PYGZdq{}Cstring\PYGZdq{};
 \PYGZsh{}ifdef MAC\PYGZus{}PLATFORM
 if (!strchr(pdfImageFilePath,(int)\PYGZsq{}:\PYGZsq{}))
     strcpy (sPathFlag, \PYGZdq{}POSIXPath\PYGZdq{});
 \PYGZsh{}endif

 asPathName = ASFileSysCreatePathName (ASGetDefaultFileSys(),
     ASAtomFromString(sPathFlag), pdfImageFilePath, 0);
\end{sphinxVerbatim}

The content to be used is expected to be on the first page of the PDF file. The \sphinxcode{\sphinxupquote{PDDocAcquirePage}} method returns a \sphinxcode{\sphinxupquote{PDPage}} object for the first page.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pdPageImage} \PYG{o}{=} \PYG{n}{PDDocAcquirePage}\PYG{p}{(}\PYG{n}{posterPDFDoc}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The code then uses PDE\sphinxhyphen{}layer (PDFEdit) methods that work with the content streams on the PDF page. (See the \sphinxstyleemphasis{Overview} guide for more information on how these methods work.)

The \sphinxcode{\sphinxupquote{PDPageAcquirePDEContent}} method returns a \sphinxcode{\sphinxupquote{PDEContent}} object representing the page’s contents. The first parameter is the \sphinxcode{\sphinxupquote{PDPage}} and the second identifies the caller: for PDF Library, it is zero; for plugins, it should be the \sphinxcode{\sphinxupquote{gExtensionID}} extension:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDEContent} \PYG{n}{pdeContent} \PYG{o}{=} \PYG{n}{PDPageAcquirePDEContent} \PYG{p}{(}\PYG{n}{pdPageImage}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{PDEContentGetAttrs}} method gets information about the content in a \sphinxcode{\sphinxupquote{PDEContentAttrs}} structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDEContentAttrs} \PYG{n}{pdeContentAttrs}\PYG{p}{;}
 \PYG{n}{PDEContentGetAttrs}
     \PYG{p}{(}\PYG{n}{pdeContent}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pdeContentAttrs}\PYG{p}{,} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{pdeContentAttrs}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

 \PYG{n}{CosObj} \PYG{n}{contentResources} \PYG{o}{=} \PYG{n}{CosNewNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosDoc} \PYG{n}{pdDocCos} \PYG{o}{=} \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{posterPDFDoc}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{PDEContentToCosObj}} method converts the \sphinxcode{\sphinxupquote{PDEContent}} to a form XObject Cos object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PDEContentToCosObj} \PYG{p}{(}\PYG{n}{pdeContent}\PYG{p}{,}
     \PYG{n}{kPDEContentToForm}\PYG{p}{,}             \PYG{o}{/}\PYG{o}{/} \PYG{n}{To} \PYG{n}{Form} \PYG{n}{XObject}
     \PYG{o}{\PYGZam{}}\PYG{n}{pdeContentAttrs}\PYG{p}{,}              \PYG{o}{/}\PYG{o}{/} \PYG{n}{PDEContentAttrsP}
     \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{pdeContentAttrs}\PYG{p}{)}\PYG{p}{,}       \PYG{o}{/}\PYG{o}{/} \PYG{n}{attrsSize}\PYG{p}{,}
     \PYG{n}{pdDocCos}\PYG{p}{,}                      \PYG{o}{/}\PYG{o}{/} \PYG{n}{The} \PYG{n}{CosDoc}
     \PYG{n}{NULL}\PYG{p}{,}                          \PYG{o}{/}\PYG{o}{/} \PYG{n}{PDEFilterArrayP}
     \PYG{o}{\PYGZam{}}\PYG{n}{contentFormXObject}\PYG{p}{,}           \PYG{o}{/}\PYG{o}{/} \PYG{n}{Resulting} \PYG{n}{form} \PYG{n}{Cos} \PYG{n+nb}{object}
     \PYG{o}{\PYGZam{}}\PYG{n}{contentResources}\PYG{p}{)}\PYG{p}{;}            \PYG{o}{/}\PYG{o}{/} \PYG{n}{Resulting} \PYG{n}{resource} \PYG{n}{Cos} \PYG{n+nb}{object}
\end{sphinxVerbatim}

The following are parameters to this method:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{PDEContent}} object.

\item {} 
A flag indicating what type of Cos object should be created; in this case, a form XObject.

\item {} 
The \sphinxcode{\sphinxupquote{PDEContentAttrs}} structure containing information about the \sphinxcode{\sphinxupquote{PDEContent}}.

\item {} 
The size of the \sphinxcode{\sphinxupquote{PDEContentAttrs}} structure.

\item {} 
The Cos document.

\item {} 
A pointer indicating which filters to use to encode the contents (in this case, null).

\item {} 
The resulting Cos object (in this case, the form XObject which is the variable \sphinxcode{\sphinxupquote{contentFormXObject}} ).

\item {} 
The resulting Cos object representing the resources needed by the Cos object. These resources can include fonts and other items (see section 3.7.2 of the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. ).

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if (!CosObjEqual(contentFormXObject, CosNewNull()) \PYGZam{}\PYGZam{}
    !CosObjEqual(contentResources, CosNewNull())) \PYGZob{}
\end{sphinxVerbatim}

The returned resources must be put into the form XObject’s \sphinxcode{\sphinxupquote{Resources}} dictionary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{contentFormXObject}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Resources}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
         \PYG{n}{contentResources}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{BBox}} entry of the form XObject is required and is set to the value of the page’s media box:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{ASFixedRect} \PYG{n}{boundingBox}\PYG{p}{;}
  \PYG{n}{PDPageGetMediaBox}\PYG{p}{(}\PYG{n}{pdPageImage}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{boundingBox}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{CosObj} \PYG{n}{BBoxArray} \PYG{o}{=} \PYG{n}{CosNewArray}\PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{BBoxArray}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{CosNewInteger}\PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}

\PYG{n}{ASFixedRoundToInt16}\PYG{p}{(}\PYG{n}{boundingBox}\PYG{o}{.}\PYG{n}{left}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{BBoxArray}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{CosNewInteger}\PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}

\PYG{n}{ASFixedRoundToInt16}\PYG{p}{(}\PYG{n}{boundingBox}\PYG{o}{.}\PYG{n}{bottom}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{BBoxArray}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{CosNewInteger}\PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}

\PYG{n}{ASFixedRoundToInt16}\PYG{p}{(}\PYG{n}{boundingBox}\PYG{o}{.}\PYG{n}{right}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{BBoxArray}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{CosNewInteger}\PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,}

\PYG{n}{ASFixedRoundToInt16}\PYG{p}{(}\PYG{n}{boundingBox}\PYG{o}{.}\PYG{n}{top}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{contentFormXObject}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BBox}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{BBoxArray}\PYG{p}{)}\PYG{p}{;}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{Set} \PYG{n}{matrix} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{form} \PYG{n+nb}{object}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{Matrix}} entry of the form XObject is set to the values obtained from the page by means of the \sphinxcode{\sphinxupquote{PDPageGetDefaultMatrix}} method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASFixedMatrix} \PYG{n}{defaultMatrix}\PYG{p}{;}
 \PYG{n}{PDPageGetDefaultMatrix}\PYG{p}{(}\PYG{n}{pdPageImage}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{defaultMatrix}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosObj} \PYG{n}{MatrixArray} \PYG{o}{=} \PYG{n}{CosNewArray}\PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{MatrixArray}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{CosNewFixed}\PYG{p}{(}
     \PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{defaultMatrix}\PYG{o}{.}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{MatrixArray}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{CosNewFixed}
     \PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{defaultMatrix}\PYG{o}{.}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{MatrixArray}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{CosNewFixed}
     \PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{defaultMatrix}\PYG{o}{.}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{MatrixArray}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{CosNewFixed}
     \PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{defaultMatrix}\PYG{o}{.}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{MatrixArray}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{CosNewFixed}
     \PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{defaultMatrix}\PYG{o}{.}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosArrayPut}\PYG{p}{(}\PYG{n}{MatrixArray}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{CosNewFixed}
     \PYG{p}{(}\PYG{n}{pdDocCos}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{defaultMatrix}\PYG{o}{.}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{contentFormXObject}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{MatrixArray}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Finally, the \sphinxcode{\sphinxupquote{CosObjCopy}} method is used to copy the Cos object \sphinxcode{\sphinxupquote{contentFormXObject}} into the current PDF document. The following are parameters are available:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{CosObj}} to copy.

\item {} 
The \sphinxcode{\sphinxupquote{CosDoc}} for the document in which to copy it.

\item {} 
A Boolean value: tru \sphinxcode{\sphinxupquote{e}} means that all indirectly referenced objects from the source should be copied to the destination.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{formXObject} \PYG{o}{=} \PYG{n}{CosObjCopy} \PYG{p}{(}\PYG{n}{contentFormXObject}\PYG{p}{,}
     \PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{TargetPdDoc}\PYG{p}{)}\PYG{p}{,} \PYG{n}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

And finally, there is some cleanup code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASFileSysReleasePath} \PYG{p}{(}\PYG{n}{ASGetDefaultFileSys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{asPathName}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{PDPageRelease}\PYG{p}{(}\PYG{n}{pdPageImage}\PYG{p}{)}\PYG{p}{;}
 \PYG{k}{return} \PYG{n}{formXObject}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Setting the activation dictionary}
\label{\detokenize{Plugins_3D_samples:setting-the-activation-dictionary}}
The optional \sphinxcode{\sphinxupquote{3DA}} entry of the 3D annotation specifies an \sphinxstyleemphasis{activation dictionary} whose entries indicate when the annotation should be activated and deactivated and the state of the 3D content at these times.

When an annotation is inactive, it displays its normal appearance. (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_59797}{Setting the annotation appearance}.) When it is activated, one of its views (specified by the \sphinxcode{\sphinxupquote{3DV}} entry) is displayed.

First the dictionary is created and set as the \sphinxcode{\sphinxupquote{3DA}} entry of the 3D annotation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{activationDict} \PYG{o}{=} \PYG{n}{CosNewDict}\PYG{p}{(}\PYG{n}{CosObjGetDoc}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{)}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CosDictPutKeyString} \PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3DA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{activationDict}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It is not necessary to set any entries whose default values are acceptable. Here the non\sphinxhyphen{}default entries are set.

The \sphinxcode{\sphinxupquote{DIS}} entry of the activation dictionary specifies the state of the 3D content when it is deactivated. In this case, it is set to \sphinxcode{\sphinxupquote{I}}, meaning that it should be instantiated. (The default is \sphinxcode{\sphinxupquote{U}} for uninstantiated.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosDictPutKeyString} \PYG{p}{(}\PYG{n}{activationDict}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
     \PYG{n}{CosNewNameFromString} \PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The code provides a variable to determine the value of the \sphinxcode{\sphinxupquote{A}} entry. The default value is \sphinxcode{\sphinxupquote{XA}}, meaning that the annotation needs to be explicitly activated. \sphinxcode{\sphinxupquote{PO}} means that the annotation should be activated as soon as the page containing the annotation is opened:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Optional} \PYG{n}{activation} \PYG{n}{choice}
 \PYG{k}{if}\PYG{p}{(}\PYG{n}{gbShowDefaultViewWhenOpenPage} \PYG{o}{==} \PYG{n}{true}\PYG{p}{)}
     \PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{activationDict}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
         \PYG{n}{CosNewNameFromString} \PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PO}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Parsing and Creating PRC Files}
\label{\detokenize{Plugins_A3D_API:parsing-and-creating-prc-files}}\label{\detokenize{Plugins_A3D_API::doc}}
\begin{sphinxadmonition}{note}{Note:}
Starting Acrobat X, the ability to convert various 3D formats for use with PDF is no longer supported. The associated APIs are, therefore, not available from Acrobat X SDK onwards.
\end{sphinxadmonition}

The Adobe Acrobat 3D API lets you develop Acrobat plugins and PDF Library applications that create and access data in a PRC stream. Such a stream can be embedded within a PDF document as a 3D annotation. This chapter explains how to export the contents of a PRC stream, and how to create a PRC stream.

PRC data can appear in PDF documents as streams referenced by 3D annotations. PRC data is a highly\sphinxhyphen{}compressed 3D representation supported in Acrobat 8.1 and later. It can represent faceted and exact geometry data. The PRC format is specified in the \sphinxhref{./API\_References/PRCReference/PRC\_Format\_Specification/index.html}{PRC Format Specification}.

Before you read this chapter, it is strongly recommended that you become familiar with 3D concepts and OpenGL, and with 3D annotations. (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_43763}{Creating 3D Annotations}.) OpenGL is an open\sphinxhyphen{}source API for setting and accessing 3D data.

For a description of the PRC file format, see the \sphinxhref{./API\_References/PRCReference/PRC\_Format\_Specification/index.html}{PRC Format Specification}.


\section{Working with the Acrobat 3D API}
\label{\detokenize{Plugins_A3D_API:working-with-the-acrobat-3d-api}}
The Acrobat 3D API provides a programmatic interface to the Acrobat 3D Library. It is the only mechanism that lets you create, access, and change PRC data that appears in a PDF document. It does not enable reading or writing PDF documents. (U3D is another 3D format that can be referenced by 3D annotations.)

You can use the Acrobat 3D API to develop the following settings:
\begin{itemize}
\item {} 
Plugins that work with Acrobat Pro Extended

\item {} 
Applications that use the PDF Library. (Acrobat Pro Extended must also be installed.) When the Acrobat 3D Library initializes itself, it verifies the presence of Acrobat Pro Extended on the same computer.

\end{itemize}


\subsection{Versions}
\label{\detokenize{Plugins_A3D_API:versions}}
The following table shows the correlation between the Acrobat 3D Library versions and the Acrobat products that supports them. The table also shows the PRC format supported by the Acrobat 3D Library version.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{3}{\X{1}{3}|}}
\hline
\sphinxstyletheadfamily 
Acrobat 3D Library version
&\sphinxstyletheadfamily 
Product
&\sphinxstyletheadfamily 
Supports PRC format version
\\
\hline
2.0
&
\begin{DUlineblock}{0em}
\item[] Acrobat Pro Extended
\item[] version 9.0
\end{DUlineblock}

PDF Library version 9.0
&
7094 and earlier
\\
\hline
2.1
&
\begin{DUlineblock}{0em}
\item[] Acrobat Pro Extended
\item[] version 9.1
\end{DUlineblock}

PDF Library version 9.1
&
7094 and earlier
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Compatibility with different PRC format versions}
\label{\detokenize{Plugins_A3D_API:compatibility-with-different-prc-format-versions}}
In addition to supporting the PRC format specified in the previous table, Acrobat 3D Library provides forward and backward compatibility with other PRC format versions:

\sphinxstylestrong{Forward compatibility:} The Acrobat 3D Library is designed to avoid failing if it reads PRC documents that conform to future releases of the PRC format. It does so by ignoring any information it does not understand.

\sphinxstylestrong{Backward compatibility:} In a major release, Acrobat 3D Library support for PRC is backward compatible. Each new version of the software can read PRC files that conform to an earlier PRC format version.


\subsection{Compatibility between the Acrobat 3D Library and the Acrobat 3D API}
\label{\detokenize{Plugins_A3D_API:compatibility-between-the-acrobat-3d-library-and-the-acrobat-3d-api}}
The Acrobat 3D API provides the public declarations for a particular version of the Acrobat 3D Library. Plugins developed with one version of the Acrobat 3D API are installed with the same version of Acrobat 3D Library, where that library is contained in Acrobat Pro Extended.

Acrobat 3D Library is designed to support backward compatibility within minor releases of the library.


\subsection{Requirements}
\label{\detokenize{Plugins_A3D_API:requirements}}
To develop an Acrobat 3D Extended plugin that uses the Acrobat 3D Library, you must download the samples, documentation, and header files from the \sphinxhref{http://www.adobe.com/go/acrobat3d\_developer}{Acrobat 3D Developer Center}. You must also download the Acrobat SDK from the \sphinxhref{http://www.adobe.com/go/acrobat\_developer}{Acrobat Developer Center}.

To develop a PDF Library application that uses the Acrobat 3D Library, you must download the samples, documentation, and header files from the \sphinxhref{http://www.adobe.com/go/acrobat3d\_developer}{Acrobat 3D Developer Center}. You must also download the PDF Library, which is available through your Adobe representative.

A licensed copy of Acrobat Pro Extended must be installed on the computer on which the plugin or PDF Library application is running. The Acrobat 3D Library verifies the presence of Acrobat Pro Extended before initializing its relationship with the application or plugin.

The file that contains the Acrobat 3D Library is A3DLIB.dll, which is located in the following directory:

C:Program FilesAdobeAcrobat DCAcrobat


\subsection{Data types, naming conventions, and character encoding}
\label{\detokenize{Plugins_A3D_API:data-types-naming-conventions-and-character-encoding}}
The Acrobat 3D API adopts the Acrobat library definitions for basic types. Here are the basic types from the Acrobat library: ASInt8, ASInt16, ASInt32, ASUns8, ASUns16, ASUns32, and ASBool.

The Acrobat 3D API declares all non\sphinxhyphen{}basic types, which fall into these general categories:

\sphinxstylestrong{PRC entities.} Correspond to the non\sphinxhyphen{}terminal structures in the PRC format, such as product occurrences, tessellation base data, and texture transformations. Your software uses NULL pointers to reference PRC entities.

\sphinxstylestrong{Data structures.} Contain the data used to create a PRC entity. Data structures can also receive the data obtained from parsing a PRC entity. There is one data structure for each type of PRC entity.

Acrobat 3D API uses a naming convention that is self\sphinxhyphen{}documenting. The name for each function, structure, enumeration, and enumerator provides clues as to its type, its relationship to a PRC entity described in the PRC format, and its role relative to that PRC entity.

Character encoding is UTF\sphinxhyphen{}8, which uses the character encoding scheme described by the Internet Engineering Task Force (IETF) document \sphinxstyleemphasis{UTF\sphinxhyphen{}8, a transformation format of ISO 10646}. That document is available at \sphinxurl{http://tools.ietf.org/html/rfc3629}.


\subsection{Structured and recursive nature of PRC parsing}
\label{\detokenize{Plugins_A3D_API:structured-and-recursive-nature-of-prc-parsing}}
Plugins and applications that process PRC data should be structured to reflect the hierarchy of the PRC format. Ideally, they implement one function to process or create each of the PRC entities. Additionally, they implement other functions to perform repeated tasks, such as processing or creating attribute data that can apply to a broad category of PRC entities.

Additionally, plugins and applications that process PRC data should support recursive function calls.

The PRC format is a highly\sphinxhyphen{}compressed hierarchical structure. The structural entities in a PRC document enable the definition of subassemblies that represent some part of the overall image, such as a gear or a nut. Subassemblies are then grouped to create more complex assemblies, or they can be referenced from other subassemblies similar to a macro.

The following diagram illustrates the hierarchical relationships that can exist between the structural elements:
\begin{itemize}
\item {} 
Model files can have multiple child product occurrences.

\item {} 
Product occurrences can have multiple child product occurrences and a part definition. They can also reference product occurrences that act as prototypes or external data.

\item {} 
Part definitions have multiple child representation items.

\end{itemize}

\noindent\sphinxincludegraphics{{partdefinitions}.png}

Because some PRC entities can contain child entities of the same type, plugins that parse or create PRC data use recursion.


\section{Implementing external linking in your plugin}
\label{\detokenize{Plugins_A3D_API:implementing-external-linking-in-your-plugin}}
The Acrobat 3D Library’s import library (the.lib file) is not provided in the Acrobat SDK or through any other means. As a result, you must use explicit linking to resolve the external links in your plugin.

With explicit linking, the executable using the DLL must make function calls to explicitly load and unload the DLL, and to access the DLL’s exported functions. Your plugin must call the exported functions through a function pointer. More specifically, your plugin must perform the following tasks:
\begin{itemize}
\item {} 
Call the \sphinxcode{\sphinxupquote{LoadLibrary}} function (or a similar function) to load the DLL and obtain a module handle.

\item {} 
Call the \sphinxcode{\sphinxupquote{GetProcAddress}} function to obtain a function pointer to each exported function that your plugin calls. Because applications are calling the DLL’s functions through a pointer, the compiler does not generate external references, so there is no need to link with an import library.

\item {} 
Call the \sphinxcode{\sphinxupquote{FreeLibrary}} function when done with the DLL.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
The Acrobat 3D API functions in this chapter are described as though implicit linking were possible. Wherever you see a direct call to one of these functions, you should instead use the pointer to the function. See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_37765}{Implementing external linking}.
\end{sphinxadmonition}


\subsection{Implementing external linking}
\label{\detokenize{Plugins_A3D_API:implementing-external-linking}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Call the \sphinxcode{\sphinxupquote{LoadLibrary}} function (or a similar function) to load the DLL and obtain a module handle.

\item {} 
Call the \sphinxcode{\sphinxupquote{GetProcAddress}} function to obtain a function pointer to each exported function that your plugin calls. Because applications are calling the DLL’s functions through a pointer, the compiler does not generate external references, so there is no need to link with an import library.

\item {} 
Main code segment that loads the Acrobat 3D library and defines function pointers

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
HMODULE hModuleA3DPRCSDK = A3DPRCLoadLibrary();

if (!hModuleA3DPRCSDK) \PYGZob{}
  AVAlertNote(\PYGZdq{}Failed to load A3DLIB.dll!\PYGZdq{});
  \PYGZus{}unlink(prcName);
  \PYGZus{}unlink(jsName);
  return;
\PYGZcb{}

A3DPRCFunctionPointersInitialize(hModuleA3DPRCSDK);

/*\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
/* Your plugin initializes its relationship with the Acrobat 3D Library
/* and then it parses or creates PRC content.
/*\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

A3DPRCUnloadLibrary(hModuleA3DPRCSDK);
\PYGZcb{} else \PYGZob{}
  char strMsg[128];
  sprintf(strMsg, \PYGZdq{}A3DDllInitialize returned \PYGZpc{}dn\PYGZdq{}, iRet);
  AVAlertNote(strMsg);
  \PYGZus{}unlink(prcName);
  \PYGZus{}unlink(jsName);
  A3DPRCUnloadLibrary(hModuleA3DPRCSDK);
\PYGZcb{}
\end{sphinxVerbatim}

Loading the DLL and obtaining a module handle

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HMODULE} \PYG{n}{A3DPRCLoadLibrary}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{HMODULE} \PYG{n}{hModuleA3DPRCSDK}\PYG{p}{;}

  \PYG{n}{wchar\PYGZus{}t} \PYG{n}{acFilePath}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}PATH}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{GetModuleFileNameW}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{n}{acFilePath}\PYG{p}{,} \PYG{n}{MAX\PYGZus{}PATH}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{wchar\PYGZus{}t}\PYG{o}{*} \PYG{n}{backslash} \PYG{o}{=} \PYG{n}{wcsrchr}\PYG{p}{(}\PYG{n}{acFilePath}\PYG{p}{,} \PYG{n}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{if} \PYG{p}{(}\PYG{n}{backslash}\PYG{p}{)}
      \PYG{n}{acFilePath}\PYG{p}{[}\PYG{n}{backslash} \PYG{o}{\PYGZhy{}} \PYG{n}{acFilePath}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

  \PYG{n}{wcscat}\PYG{p}{(}\PYG{n}{acFilePath}\PYG{p}{,} \PYG{n}{L}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A3DLIB.dll}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{}ifdef UNICODE}
  \PYG{n}{hModuleA3DPRCSDK} \PYG{o}{=} \PYG{n}{LoadLibraryExW}\PYG{p}{(}\PYG{n}{acFilePath}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{LOAD\PYGZus{}WITH\PYGZus{}ALTERED\PYGZus{}SEARCH\PYGZus{}PATH}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}else}
  \PYG{n}{hModuleA3DPRCSDK} \PYG{o}{=} \PYG{n}{LoadLibraryExA}\PYG{p}{(}\PYG{n}{acFilePath}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{LOAD\PYGZus{}WITH\PYGZus{}ALTERED\PYGZus{}SEARCH\PYGZus{}PATH}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZsh{}endif}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{hModuleA3DPRCSDK}\PYG{p}{)}
      \PYG{k}{return} \PYG{n}{hModuleA3DPRCSDK}\PYG{p}{;}

  \PYG{k}{return} \PYG{n}{NULL}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Setting up the function pointers

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{A3DPRCFunctionPointersInitialize}\PYG{p}{(}\PYG{n}{HMODULE} \PYG{n}{hModule}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{\PYGZsh{}define A3D\PYGZus{}API(returntype,name,params) st\PYGZus{}PF\PYGZsh{}\PYGZsh{}name = (PF\PYGZsh{}\PYGZsh{}name)GetProcAddress(hModule,\PYGZsh{}name);}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDK.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKTypes.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKBase.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKErrorCodes.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKGeometry.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKTessellation.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKGraphics.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKStructure.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKRootEntities.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKRepItems.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKTessellation.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKMarkup.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKGlobalData.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKTexture.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKMisc.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKGeometryCrv.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKGeometrySrf.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}A3DSDKTopology.h\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}undef A3D\PYGZus{}API}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Declaring the macro that resolves to the function pointer

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}define A3DCALL(name,params) st\PYGZus{}PF\PYGZsh{}\PYGZsh{}name params}
\end{sphinxVerbatim}

Using the macro to invoke an Acrobat 3D API function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if(iErr == A3D\PYGZus{}SUCCESS) \PYGZob{}
      ASInt32 iRet = A3DCALL(A3DDllInitialize,(iMajorVersion, iMinorVersion));
      if(iRet == A3D\PYGZus{}SUCCESS) \PYGZob{}
      …
  \PYGZcb{}
\PYGZcb{}
\end{sphinxVerbatim}


\section{Parsing a PRC file}
\label{\detokenize{Plugins_A3D_API:parsing-a-prc-file}}
This section describes how to parse the data in a PRC file. You can then export the PRC data to an external file that uses a different CAD format, provided you understand the structure of that format and have an API that supports that format. It is beyond the scope of this chapter to explain how to convert PRC data into a specific CAD format. It is also beyond the scope of this chapter to provide an exhaustive explanation of parsing all aspects of a PRC file.

The following diagram shows the structure of a plugin that parses PRC data.

\noindent\sphinxincludegraphics{{parseprc}.png}

The following diagram shows the sequence of tasks required to parse a Brep model entity.

\noindent\sphinxincludegraphics{{parsebrep}.png}


\subsection{Handling errors}
\label{\detokenize{Plugins_A3D_API:handling-errors}}
Most of the Acrobat 3D API functions return an integer that indicates success or failure. A return value of \sphinxcode{\sphinxupquote{A3D\_SUCCESS}} indicates success, and any negative return value indicates failure. The following example shows one approach for evaluating this returned result:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ASInt32 iRet = A3DAsmModelFileLoadFromFile(acFileName, NULL, \PYGZam{}p);
if (iRet == A3D\PYGZus{}SUCCESS) \PYGZob{}
  …
\PYGZcb{} else
  fprintf(\PYGZdq{}Error: \PYGZpc{}1dn\PYGZdq{}, iRet);
\end{sphinxVerbatim}

Although subsequent explanations in this section omit this description, you must still check for errors when an Acrobat 3D API function returns.


\subsection{Copying the embedded PRC file to a separate file}
\label{\detokenize{Plugins_A3D_API:copying-the-embedded-prc-file-to-a-separate-file}}
This section explains how to export a PRC stream represented in a PDF document as a 3D annotation.

Copy the embedded PRC file to a separate file
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Retrieve the 3D annotation from within a PDF document. (See \sphinxhref{Plugins\_Annotations.html\#50618420\_93262}{Retrieving existing annotations}.) Ensure that the annotation dictionary type is \sphinxcode{\sphinxupquote{3DD}} and that the subtype is \sphinxcode{\sphinxupquote{PRC}}.

\item {} 
Write the PRC stream to a separate file. This will simplify accessing the data in the stream.

\end{enumerate}


\subsection{Initializing the Acrobat 3D API}
\label{\detokenize{Plugins_A3D_API:initializing-the-acrobat-3d-api}}
This section explains how to initialize the Acrobat 3D API.

Initialize your interface with the Acrobat 3D API
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Verify that your plugin is compatible with the Acrobat 3D Library by comparing the version of the Acrobat 3D API against which you compiled and the version of the Acrobat 3D Library available to your plugin. Obtain the version identifiers for the currently installed Acrobat 3D Library by invoking the \sphinxcode{\sphinxupquote{A3DDllGetVersion}} function. Evaluate the returned values as follows:
\begin{itemize}
\item {} 
Ensure that the value of the \sphinxcode{\sphinxupquote{piMajorVersion}} argument matches the \sphinxcode{\sphinxupquote{A3D\_DLL\_MAJORVERSION}} enumeration.

\item {} 
Ensure that the value of the \sphinxcode{\sphinxupquote{piMinorVersion}} argument is equal to or greater than the \sphinxcode{\sphinxupquote{A3D\_DLL\_MINORVERSION}} enumeration. The Acrobat 3D Library provides backward compatibility for earlier releases of the API that have the same major version identifier.

\end{itemize}

\item {} 
Initialize the Acrobat 3D API by supplying the version identifiers for the Acrobat 3D API.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if(iErr == A3D\PYGZus{}SUCCESS) \PYGZob{}
      ASInt32 iRet = A3DCALL(
          A3DDllInitialize,(A3D\PYGZus{}DLL\PYGZus{}MAJORVERSION, A3D\PYGZus{}DLL\PYGZus{}MINORVERSION));
      if(iRet == A3D\PYGZus{}SUCCESS) \PYGZob{} … \PYGZcb{}
\PYGZcb{}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
For simplicity, this example uses a syntax that assumes the import library is available. That library is not publicly available, so your code must use a syntax that supports external linking (see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_20817}{Implementing external linking in your plugin}). The following example shows the syntax to use:
\end{sphinxadmonition}


\subsection{Parsing structure PRC entities}
\label{\detokenize{Plugins_A3D_API:parsing-structure-prc-entities}}
The \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference} groups the PRC entities that provide structure to the PRC document into the structure module. The PRC entities in the structure module are described here:

\sphinxstylestrong{Model file:} Is a root PRC entity. There is only one model file in a PRC file.

\sphinxstylestrong{Product occurrence:} Can contain multiple child product occurrences and one part definition. It can also reference other product occurrences used as prototypes or external data.

\sphinxstylestrong{Part definition:} Contains representation items.

\sphinxstylestrong{Filter:} Specifies inclusion or exclusion of topology, geometry, tessellation, or graphic entities, based on the entity’s layer or entity type.


\subsubsection{Parse the model file data}
\label{\detokenize{Plugins_A3D_API:parse-the-model-file-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Load the PRC file into memory by invoking the A3DAsmModelFileLoadFromFile function. In the following example, the \sphinxcode{\sphinxupquote{acFileName}} argument points to an \sphinxcode{\sphinxupquote{A3DUTF8Char}} array that contains the name of the PRC file, the second parameter must be \sphinxcode{\sphinxupquote{NULL}}, and the \sphinxcode{\sphinxupquote{p}} pointer references a null A3DAsmModelFile object in which the Acrobat 3D Library stores the PRC model file.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmModelFile}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DAsmModelFileLoadFromFile}\PYG{p}{(}\PYG{n}{acFileName}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Populate the model file with the model file data by invoking the A3DAsmModelFileGet function to place the data in that structure. The A3D\_INITIALIZE\_DATA macro clears the memory allocated to the structure and checks the size of the structure to avoid alignment problems. The A3DAsmModelFileGet function creates a data structure from the model file pointer created in the previous step.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmModelFileData} \PYG{n}{sData}\PYG{p}{;}

\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DAsmModelFileGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Save the value of the \sphinxcode{\sphinxupquote{m\_dUnit}} member in the structure in which you are saving data obtained from parsing the PRC file (your export structure). This member specifies a multiple of millimeters. The value of this member must be non\sphinxhyphen{}zero. A value of 1 indicates the units are in millimeters; and a value of 10 indicates the units are in centimeters.

\item {} 
If the \sphinxcode{\sphinxupquote{m\_bUnitFromCAD}} is present, save its value in your export structure. If the \sphinxcode{\sphinxupquote{bUnitFromCAD}} member is true, then the \sphinxcode{\sphinxupquote{m\_bUnit}} is from the native CAD file.

\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.)

\item {} 
Declare an A3DMiscCascadedAttributes structure. This will be the root entry in a stack on which you store child product occurrences and other subordinate structures. This stack is used to iterate through the PRC structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DMiscCascadedAttributes}\PYG{o}{*} \PYG{n}{pAttr}\PYG{p}{;}
\PYG{n}{A3DMiscCascadedAttributesCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

As you parse subsequent PRC entities, you push the attributes onto this stack. For more information about using cascaded attribute stacks, see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_16174}{Parsing PRC entities that specify graphics} or click the Related Pages tab on the \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
Parse each product occurrence pointer in the \sphinxcode{\sphinxupquote{sData.m\_ppPOccurrences}} array. The number of pointers is specified in \sphinxcode{\sphinxupquote{sData.m\_uiPOccurrencesSize}}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{ui} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ui} \PYG{o}{\PYGZlt{}} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiPOccurrencesSize}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{n}{parsePOccurrence}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppPOccurrences}\PYG{p}{[}\PYG{n}{ui}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For information about parsing product occurrences, see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_48520}{Parse a product occurrence}.


\subsubsection{Parse a product occurrence}
\label{\detokenize{Plugins_A3D_API:parse-a-product-occurrence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base, saving the entity name and other relevant data to your export structure. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.)

\item {} 
Create and push a cascaded attributes structure for a product occurrence object, and push that structure onto the stack. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_84985}{Parsing graphic attributes using miscellaneous cascaded attributes}.) Save relevant values to your export structure.

\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DAsmProductOccurrenceData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmProductOccurrenceData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Get the product occurrence data by invoking the \sphinxcode{\sphinxupquote{A3DAsmProductOccurrenceGet}} function.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DAsmProductOccurrenceGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Parse the product occurrence data to identify subordinate or imported product occurrences and recursively parse the contents of each, as described in \sphinxhref{Plugins\_A3D\_API.html\#50618396\_48520}{Parse a product occurrence} (this section). The member names and their significance are described below:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{m\_pPrototype}} : Pointer to a product occurrence prototype, which typically represents a subassembly or part

\item {} 
\sphinxcode{\sphinxupquote{m\_pExternalData}} : Pointer to an external product occurrence

\item {} 
\sphinxcode{\sphinxupquote{m\_uiPOccurrencesSize}} : Number of child product occurrences, where the \sphinxcode{\sphinxupquote{m\_ppPOccurrences}} array references those child product occurrences

\end{itemize}

\end{enumerate}

The following example parses prototype or external product occurrences. The \sphinxcode{\sphinxupquote{sData}} variable is a populated \sphinxcode{\sphinxupquote{A3DAsmProductOccurrenceData}} structure.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pPrototype}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{parsePOccurrence}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pPrototype}\PYG{p}{,} \PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pExternalData}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{parsePOccurrence}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pExternalData}\PYG{p}{,} \PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The following example parses child product occurrences (\sphinxcode{\sphinxupquote{sData.ppPOccurrences{[}ui{]}}}. As before, the \sphinxcode{\sphinxupquote{sdata}} variable is a populated \sphinxcode{\sphinxupquote{A3DAsmProductOccurrenceData}} structure.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{ui} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ui} \PYG{o}{\PYGZlt{}} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiPOccurrencesSize}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{n}{parsePOccurrence}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppPOccurrences}\PYG{p}{[}\PYG{n}{ui}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
If the product occurrence data references a part (\sphinxcode{\sphinxupquote{sData.m\_pPart}} ), parse it. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_48520}{Parse a product occurrence}.)

\item {} 
Parse any scene display parameters in the product occurrence.

\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DAsmProductOccurrenceData}} structure created in Step \sphinxtitleref{Declare and initialize an ``A3DAsmProductOccurrenceData`} structure. <Plugins\_A3D\_API.html\#50618396\_31716>`\_\_ by invoking the \sphinxcode{\sphinxupquote{A3DAsmProductOccurrenceGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument pointing to the product occurrence data.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DAsmProductOccurrenceGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse a part definition}
\label{\detokenize{Plugins_A3D_API:parse-a-part-definition}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base, saving the entity name and other relevant data to your export structure. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.)

\item {} 
Create and push a cascaded attributes structure for a product occurrence object, and push that structure onto the stack. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_84985}{Parsing graphic attributes using miscellaneous cascaded attributes}.) Record information from the data structure of the miscellaneous cascaded attributes structure that is meaningful to your representation.

\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DAsmPartDefinitionData}} structure, as shown in the following example:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmPartDefinitionData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DAsmPartDefinitionGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse each representation item referenced by the part definition (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_89551}{Parsing representation items}.) In the following example, \sphinxcode{\sphinxupquote{sData.m\_uiRepItemsSize}} is the number of representation item entities in the part definition, and entry in the \sphinxcode{\sphinxupquote{sData.m\_ppRepItems{[}ui{]}}} array references a separate representation item.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{ui} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ui} \PYG{o}{\PYGZlt{}} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiRepItemsSize}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{n}{parseRI}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppRepItems}\PYG{p}{[}\PYG{n}{ui}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DAsmPartDefinitionData}} structure created in Step \sphinxtitleref{Declare and initialize an ``A3DAsmPartDefinitionData`} structure, as shown in the following example: <Plugins\_A3D\_API.html\#50618396\_28760>`\_\_ by invoking the \sphinxcode{\sphinxupquote{A3DAsmPartDefinitionGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument pointing to the part definition data.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmPartDefinitionGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parsing representation items}
\label{\detokenize{Plugins_A3D_API:parsing-representation-items}}
Representation items describe objects present in the 3D image, such as a wheel or a bolt. The exception is the representation item set (type \sphinxcode{\sphinxupquote{kA3DTypeRiSet}} ), which is a container for other representation items.

Parse a generic representation item
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base, saving the entity name and other relevant data to your export structure. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.)

\item {} 
Create and push a miscellaneous cascaded attributes structure for the representation item, and then get the data for that structure (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_16174}{Parsing PRC entities that specify graphics}.) Record information from the miscellaneous cascaded attributes data structure that is meaningful to your representation.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{A3DEntityGetType}} function to determine the type of representation item, providing the following arguments:
\begin{itemize}
\item {} 
The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the representation item.

\item {} 
The second argument (\sphinxcode{\sphinxupquote{eType}} in the following example) is a pointer to a variable in which the function stores the type enumerator.

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DEEntityType} \PYG{n}{eType}\PYG{p}{;}
 \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DEntityGetType}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{eType}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Parse the representation item depending on the type of representation item, as shown in the following example. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_19073}{Parse a representation item set (PRC entity A3DRiSet)} or \sphinxhref{Plugins\_A3D\_API.html\#50618396\_70316}{Parse a Brep model representation item (PRC entity A3DRiBrepModel)}.)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
switch(eType) \PYGZob{}
case kA3DTypeRiBrepModel:
  parseRiBrepModel(p, father);
  break;
case kA3DTypeRiSet:
  …
  break;
case kA3DTypeRiPointSet:
  …
  break;
…
default:
  …
\PYGZcb{}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Get the representation item attributes by invoking the \sphinxcode{\sphinxupquote{A3DRiRepresentationItemGet}} function.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiRepresentationItemData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DRiRepresentationItemGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Parse the tessellation base data referenced by the \sphinxcode{\sphinxupquote{m\_pTessBase}} member. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_89274}{Parsing tessellation PRC entities}.)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parseTess}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pTessBase}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
Parse the coordinate system referenced by the \sphinxcode{\sphinxupquote{m\_pCoordinateSystem}} member. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_94778}{Parse coordinate system data}.)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parseRiCSys}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pCoordinateSystem}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DRiRepresentationItemData}} created in Step \sphinxtitleref{Get the representation item attributes by invoking the ``A3DRiRepresentationItemGet`} function. <Plugins\_A3D\_API.html\#50618396\_17261>`\_\_ by invoking the \sphinxcode{\sphinxupquote{A3DRiRepresentationItemGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiRepresentationItemGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse a representation item set (PRC entity A3DRiSet)}
\label{\detokenize{Plugins_A3D_API:parse-a-representation-item-set-prc-entity-a3driset}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Create and push a cascaded attributes structure for a product occurrence object, and push that structure onto the stack. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_84985}{Parsing graphic attributes using miscellaneous cascaded attributes}.) Save relevant values to your export structure.

\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DRiSetData}} structure, and then get the data from the representation PRC entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiSetData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DRiSetGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse each representation item in the representation item set. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_16122}{Parse a generic representation item}.) The \sphinxcode{\sphinxupquote{m\_uiRepItemsSize}} field specifies the number of child representation items, and the m\_ppRepItems{[}{]} field is an array of pointers to the child representation items.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{ui} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{\PYGZlt{}}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiRepItemsSize}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{n}{parseRI}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppRepItems}\PYG{p}{[}\PYG{n}{ui}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pAttr}\PYG{p}{,} \PYG{n}{son}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Delete the A3DRiSetGet function created in Step \sphinxtitleref{Declare and initialize an ``A3DAsmPartDefinitionData`} structure, as shown in the following example: <Plugins\_A3D\_API.html\#50618396\_28760>`\_\_ by invoking the \sphinxcode{\sphinxupquote{A3DAsmPartDefinitionGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument pointing to the part definition data.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiSetGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse a Brep model representation item (PRC entity A3DRiBrepModel)}
\label{\detokenize{Plugins_A3D_API:parse-a-brep-model-representation-item-prc-entity-a3dribrepmodel}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Get the Brep model data by invoking the \sphinxcode{\sphinxupquote{A3DRiBrepModelGet}} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the PRC entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DRiBrepModelData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiBrepModelData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DRiBrepModelGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the Brep model’s topology body data, referenced by the \sphinxcode{\sphinxupquote{m\_pBrepData}} member. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_37745}{Parse topology body data}.)

\item {} 
Parse the Brep model’s data, referenced by the \sphinxcode{\sphinxupquote{m\_pBrepData}} member. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_73034}{Parse the Brep model’s data}.)

\end{enumerate}

\begin{sphinxadmonition}{warning}{Warning:}
The same member (\sphinxcode{\sphinxupquote{m\_pBrepData}} ) is used to parse topology body data and topology model data. The Brep model’s topology body data is recast as the \sphinxcode{\sphinxupquote{A3DTopoBody}} type, which is an abstract root type for any topological body. The \sphinxcode{\sphinxupquote{A3DTopoBodyGet}} function takes an argument of type \sphinxcode{\sphinxupquote{A3DTopoBody}}.
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DRiBrepModelData}} created in Step \sphinxtitleref{Get the Brep model data by invoking the ``A3DRiBrepModelGet`} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the PRC entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DRiBrepModelData}} structure. <Plugins\_A3D\_API.html\#50618396\_45175>`\_\_ by invoking the \sphinxcode{\sphinxupquote{A3DRiBrepModelGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiBrepModelGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse coordinate system data}
\label{\detokenize{Plugins_A3D_API:parse-coordinate-system-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DRiCoordinateSystemData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiCoordinateSystemData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Get the coordinate system data by invoking the \sphinxcode{\sphinxupquote{A3DRiCoordinateSystemGet}} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the \sphinxcode{\sphinxupquote{A3DRiCoordinateSystem}} entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DRiCoordinateSystemData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DRiCoordinateSystemGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Parse the coordinate system transformation data referenced by the \sphinxcode{\sphinxupquote{m\_pTransformation}} member of the \sphinxcode{\sphinxupquote{A3DRiCoordinateSystemData}} structure.

\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DRiCoordinateSystemData}} structure created in Step \sphinxtitleref{Declare and initialize an ``A3DRiCoordinateSystemData`} structure. <Plugins\_A3D\_API.html\#50618396\_58902>`\_\_ by invoking the \sphinxcode{\sphinxupquote{A3DRiCoordinateSystemGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiCoordinateSystemGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Parsing tessellation PRC entities}
\label{\detokenize{Plugins_A3D_API:parsing-tessellation-prc-entities}}
Tessellation entities represent polygon facets.


\subsubsection{Parse tessellation base data}
\label{\detokenize{Plugins_A3D_API:parse-tessellation-base-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Populate an \sphinxcode{\sphinxupquote{A3DTessBaseData}} structure with the tessellation base data by invoking the \sphinxcode{\sphinxupquote{A3DTessBaseGet}} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the tessellation base data, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTessBaseData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTessBaseData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTessBaseGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Export the coordinate size (sData.m\_uiCoordSize), the coordinates array (sData.m\_pdCoords), and the calculate attributes (\sphinxcode{\sphinxupquote{sData.m\_bIsCalculated}} ) to your tessellation base data element.

\item {} 
Parse the tessellation data based on its type. The PRC format defines these types for tessellation data:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{kA3DTypeTess3D}}, which is used for solids and surfaces (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_81753}{Parse 3D tessellation data}.)

\item {} 
\sphinxcode{\sphinxupquote{kA3DTypeTess3DWire}}, which is used for 3D wireframes

\item {} 
\sphinxcode{\sphinxupquote{kA3DTypeTessMarkup}}, which is used for markups

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DEEntityType} \PYG{n}{eType}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iErr} \PYG{o}{=} \PYG{n}{A3DEntityGetType}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{eType}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{iErr} \PYG{o}{==} \PYG{n}{A3D\PYGZus{}SUCCESS}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{switch}\PYG{p}{(}\PYG{n}{eType}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\PYG{n}{case} \PYG{n}{kA3DTypeTess3D}\PYG{p}{:}
  \PYG{n}{parse3DTess}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{pRepItem}\PYG{p}{,} \PYG{n}{pFatherAttr}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{break}\PYG{p}{;}
\PYG{n}{case} \PYG{n}{kA3DTypeTess3DWire}\PYG{p}{:}
  \PYG{n}{parse3DWireTess}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{break}\PYG{p}{;}
\PYG{n}{case} \PYG{n}{kA3DTypeTessMarkup}\PYG{p}{:}
  \PYG{n}{parse3DTessMarkup}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{break}\PYG{p}{;}
\PYG{n}{default}\PYG{p}{:}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{error} \PYG{n}{response}\PYG{o}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Delete the A3DTessBaseData created in Step \sphinxtitleref{Populate an ``A3DTessBaseData`} structure with the tessellation base data by invoking the \sphinxcode{\sphinxupquote{A3DTessBaseGet}} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the tessellation base data, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTessBaseData}} structure. <Plugins\_A3D\_API.html\#50618396\_69214>`\_\_ by invoking the \sphinxcode{\sphinxupquote{A3DRiBrepModelGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTessBaseGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse 3D tessellation data}
\label{\detokenize{Plugins_A3D_API:parse-3d-tessellation-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Populate an \sphinxcode{\sphinxupquote{A3DTess3DData}} structure with the tessellation data by invoking the \sphinxcode{\sphinxupquote{A3DTess3DGet}} function.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTess3DData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTess3DGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Represent relevant data from the 3D tessellation data element in your export structure.

\item {} 
For each face in the tessellation data, create and push the cascaded attributes face data and then access its data members. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_84985}{Parsing graphic attributes using miscellaneous cascaded attributes}.) In the following example, the \sphinxcode{\sphinxupquote{CreateAndPushCascadedAttributesFace}} is a private function that pushes the miscellaneous cascaded attributes for a tessellation face onto the stack.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASUns32} \PYG{n}{uiNumberOfFaces} \PYG{o}{=} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiFaceTessSize}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{ui} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ui} \PYG{o}{\PYGZlt{}} \PYG{n}{uiNumberOfFaces}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{A3DTessFaceData}\PYG{o}{\PYGZam{}} \PYG{n}{sTessFaceData} \PYG{o}{=} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}psFaceTessData}\PYG{p}{[}\PYG{n}{ui}\PYG{p}{]}\PYG{p}{;}

  \PYG{n}{A3DMiscCascadedAttributes}\PYG{o}{*} \PYG{n}{pAttr}\PYG{p}{;}
  \PYG{n}{A3DMiscCascadedAttributesData} \PYG{n}{sAttrData}\PYG{p}{;}
  \PYG{o}{/}\PYG{o}{/} \PYG{n}{Read} \PYG{n}{CascadedAttributes} \PYG{k}{for} \PYG{n}{one} \PYG{n}{of} \PYG{n}{the} \PYG{n}{facec}
  \PYG{n}{CreateAndPushCascadedAttributesFace}\PYG{p}{(}\PYG{n}{pRepItem}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sTessFaceData}\PYG{p}{,}
      \PYG{n}{ui}\PYG{p}{,} \PYG{n}{pFatherAttr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pAttr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sAttrData}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{A3DMiscCascadedAttributesDelete}\PYG{p}{(}\PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{A3DMiscCascadedAttributesGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sAttrData}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Delete the cascaded attributes data structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DMiscCascadedAttributesDelete}\PYG{p}{(}\PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Delete the cascaded attributes structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DMiscCascadedAttributesGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sAttrData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DTess3DData}} structure created in Step \sphinxtitleref{Populate an ``A3DTess3DData`} structure with the tessellation data by invoking the \sphinxcode{\sphinxupquote{A3DTess3DGet}} function. <Plugins\_A3D\_API.html\#50618396\_64792>`\_\_.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTess3DGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Parsing topology PRC entities}
\label{\detokenize{Plugins_A3D_API:parsing-topology-prc-entities}}
The \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference} groups the PRC entities that specify topology into the topology module. The PRC entities in this module specify the surfaces of 3D objects. This section describes how to parse the topology data in a Brep model.

Topology data in a Brep model contains data specific to the Brep and data that is generic to topology models.

\sphinxstylestrong{Data specific to Brep topology models}

The following entities contain the geometric data that represents the Brep data:
\begin{itemize}
\item {} 
Topology Brep data: A topological boundary representation comprised of a bounding box and references to multiple Connex entities (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_82589}{Create a topology Brep data entity}.)

\item {} 
Connex: A collection of shell entities, such as a hollow sphere that contains another sphere that is represented by two connexes (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_42463}{Parse Connex data}.)

\item {} 
Shell: A collection of face entities (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_13069}{Parse a shell entity}.)

\item {} 
Face: A surface and a collection of loops (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_89218}{Parse the face’s surface data}.)

\end{itemize}

\sphinxstylestrong{Data general to all topology models}

The following entities contain data that applies to any topology model:

\sphinxstylestrong{Topology body data:} A mask indicating the source of the bounding box (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_37745}{Parse topology body data}.)

\sphinxstylestrong{Topology context:} A mask indicating the behavior of the topology context (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_86159}{Parse topology context data}.)


\subsubsection{Parse topology body data}
\label{\detokenize{Plugins_A3D_API:parse-topology-body-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Get the topology body data by invoking the \sphinxcode{\sphinxupquote{A3DTopoBodyGet}} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the Brep model’s topology body data, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoBodyData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoBodyData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoBodyGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Parse the context of the topology body context data, referenced by the \sphinxcode{\sphinxupquote{m\_pContext}} member. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_86159}{Parse topology context data}.)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parseContext}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pContext}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DTopoBodyData}} structure created in Step \sphinxtitleref{Get the topology body data by invoking the ``A3DTopoBodyGet`} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the Brep model’s topology body data, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoBodyData}} structure. <Plugins\_A3D\_API.html\#50618396\_67857>`\_\_, by invoking the \sphinxcode{\sphinxupquote{A3DTopoBodyGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoBodyGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse topology context data}
\label{\detokenize{Plugins_A3D_API:parse-topology-context-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Get the data in the topology context data by invoking the \sphinxcode{\sphinxupquote{A3DTopoContextGet}} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the topology context data, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoContextData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoContextData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoContextGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
If you plan to evaluate graphic data relative to the current surface, save the Body Scale for use in scaling the face’s surface data to fit the Nurbs surface. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_89218}{Parse the face’s surface data}.) Body scale has no particular meaning for Nurb data conversion and can be called only on specific surface types.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{stdContextScale} \PYG{o}{=} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}dScale}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DTopoContextData}} structure, created in Step \sphinxtitleref{Get the data in the topology context data by invoking the ``A3DTopoContextGet`} function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the topology context data, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoContextData}} structure. <Plugins\_A3D\_API.html\#50618396\_30926>`\_\_, by invoking the \sphinxcode{\sphinxupquote{A3DTopoContextGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoContextGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse the Brep model’s data}
\label{\detokenize{Plugins_A3D_API:parse-the-brep-model-s-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Get the data in the Brep model by invoking the A3DTopoBrepDataGet function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the Brep model’s data, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DBrepDataData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoBrepDataData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoBrepDataGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
The Brep data can reference Connex entities. The \sphinxcode{\sphinxupquote{m\_uiConnexSize}} member indicates the number of such references, and the m\_ppConnexes{[}{]} member provides the references. Parse each Connex entry. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_42463}{Parse Connex data}.)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{ui} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ui} \PYG{o}{\PYGZlt{}} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiConnexSize}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{n}{parseConnex}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppConnexes}\PYG{p}{[}\PYG{n}{ui}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Save the bounding box referenced by \sphinxcode{\sphinxupquote{m\_sBoundingBox}} as an attribute of the Brep data element in your export structure.

\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DTopoBrepDataData}} structure, created in Step \sphinxtitleref{Get the data in the Brep model by invoking the A3DTopoBrepDataGet function. The first argument (``p`} in the following example) is a pointer to the Brep model’s data, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DBrepDataData}} structure. <Plugins\_A3D\_API.html\#50618396\_62843>`\_\_, by invoking the \sphinxcode{\sphinxupquote{A3DTopoBrepDataGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoBrepDataGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse Connex data}
\label{\detokenize{Plugins_A3D_API:parse-connex-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Get the data in the Brep model by invoking the A3DTopoConnexGet function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the Connex entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoConnexData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoConnexData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoConnexGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
The Connex data can reference multiple Shell entities. The \sphinxcode{\sphinxupquote{m\_uiShellSize}} member indicates the number of such references, and the m\_ppShells{[}{]} member provides the references. Parse each Shell entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_13069}{Parse a shell entity}.)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{ui} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ui} \PYG{o}{\PYGZlt{}} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiShellSize}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{n}{parseShell}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppShells}\PYG{p}{[}\PYG{n}{ui}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DTopoConnexData}} structure, created in Step \sphinxtitleref{Get the data in the Brep model by invoking the A3DTopoConnexGet function. The first argument (``p`} in the following example) is a pointer to the Connex entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoConnexData}} structure. <Plugins\_A3D\_API.html\#50618396\_62700>`\_\_, by invoking the \sphinxcode{\sphinxupquote{A3DTopoConnexGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoConnexGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse a shell entity}
\label{\detokenize{Plugins_A3D_API:parse-a-shell-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Get the data in the topology shell entity by invoking the A3DTopoShellGet function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the topology shell entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoShellData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoShellData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoShellGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
The shell data can reference multiple face entities. The \sphinxcode{\sphinxupquote{m\_uiFaceSize}} member indicates the number of such references, and the m\_ppFaces{[}{]} member provides the references. Parse each face entity, as described in \sphinxhref{Plugins\_A3D\_API.html\#50618396\_89218}{Parse the face’s surface data}. {[}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{p}{(}\PYG{n}{ASUns32} \PYG{n}{ui} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ui} \PYG{o}{\PYGZlt{}} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiFaceSize}\PYG{p}{;} \PYG{n}{ui}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
  \PYG{n}{parseFace}\PYG{p}{(}\PYG{n}{ui}\PYG{p}{,} \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppFaces}\PYG{p}{[}\PYG{n}{ui}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Save the closed indicator (the \sphinxcode{\sphinxupquote{m\_bClosed}} member) and the orientation of the surface normal with respect to the shell normal (the \sphinxcode{\sphinxupquote{m\_pucOrientationWithShell}} member) as attributes in the shell element in your export structure.

\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DTopoShellData}} structure, created in Step \sphinxtitleref{Get the data in the topology shell entity by invoking the A3DTopoShellGet function. The first argument (``p`} in the following example) is a pointer to the topology shell entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoShellData}} structure. <Plugins\_A3D\_API.html\#50618396\_30248>`\_\_, by invoking the \sphinxcode{\sphinxupquote{A3DTopoShellGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoShellGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse the face’s surface data}
\label{\detokenize{Plugins_A3D_API:parse-the-face-s-surface-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Parse the entity base. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60919}{Parsing root\sphinxhyphen{}base entity data}.) Save the entity name and other relevant data to your export structure.

\item {} 
Get the data in the topology face entity by invoking the A3DTopoFaceGet function. The first argument (\sphinxcode{\sphinxupquote{p}} in the following example) is a pointer to the topology face entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoFaceData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoFaceData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoFaceGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Parse the surface data referenced by the \sphinxcode{\sphinxupquote{m\_pSurface}} member in the \sphinxcode{\sphinxupquote{A3DTopoFaceData}} structure. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_23874}{Parse generic surface data}.)

\item {} 
If you are converting the PRC data to a 3D model that does not support UV mapping, you must create a curve on surfaceto editors: this is a standard graphic term and convert it to Nurbs data. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_69663}{Convert surface data to Nurbs (for other than UV\sphinxhyphen{}mapped surfaces)}.)

\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DTopoFaceData}} structure created in Step \sphinxtitleref{Get the data in the topology face entity by invoking the A3DTopoFaceGet function. The first argument (``p`} in the following example) is a pointer to the topology face entity, and the second argument (\sphinxcode{\sphinxupquote{\&sData}} in the following example) is the location of the \sphinxcode{\sphinxupquote{A3DTopoFaceData}} structure. <Plugins\_A3D\_API.html\#50618396\_74067>`\_\_ by invoking the \sphinxcode{\sphinxupquote{A3DTopoFaceGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoFaceGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Convert surface data to Nurbs (for other than UV\sphinxhyphen{}mapped surfaces)}
\label{\detokenize{Plugins_A3D_API:convert-surface-data-to-nurbs-for-other-than-uv-mapped-surfaces}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DCrvOnSurfData}} structure.

\item {} 
Populate the \sphinxcode{\sphinxupquote{A3DCrvOnSurfData}} structure with the surface base and surface domain information from the \sphinxcode{\sphinxupquote{A3DTopoFaceData}} structure.

\item {} 
Create an \sphinxcode{\sphinxupquote{A3DCrvOnSurf}} PRC entity by invoking the \sphinxcode{\sphinxupquote{A3DCrvOnSurfCreate}} function. The first argument in this function call is the \sphinxcode{\sphinxupquote{A3DCrvOnSurfData}} structure, and the second is a pointer to the resulting PRC entity.

\item {} 
Convert a curve on the surface in the \sphinxcode{\sphinxupquote{A3DCrvOnSurf}} PRC entity by invoking the \sphinxcode{\sphinxupquote{A3DCrvBaseGetAsNurbs}} function.

\end{enumerate}


\subsubsection{Parse generic surface data}
\label{\detokenize{Plugins_A3D_API:parse-generic-surface-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Determine the type of surface data by invoking the \sphinxcode{\sphinxupquote{A3DEntityGetType}} function. The first argument references the surface, and the second is a pointer to a variable in which the function stores the type enumerator.

\item {} 
Parse the surface data using the Acrobat 3D API functions most appropriate for the surface type. Use the A3DEntityGetType function to determine surface type. If the surface type is of type \sphinxcode{\sphinxupquote{kA3DTypeSurfNurbs}} or if the surface type is unknown, parse the surface data as Nurbs surface data (see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_48547}{Parse Nurbs surface data}).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
A3DEEntityType eType;
iRet = A3DEntityGetType(p, \PYGZam{}eType);
switch (eType) \PYGZob{}
case kA3DTypeSurfNurbs:
  parseSurfaceNurbs(p);
  break;
case kA3DTypeSurfSphere:
  parseSurfSphere(p);
  break;
case kA3DTypeSurfBlend01:
  parseSurfaceBlend01(p);
  break;
…
\PYGZcb{}
\end{sphinxVerbatim}


\subsubsection{Parse Nurbs surface data}
\label{\detokenize{Plugins_A3D_API:parse-nurbs-surface-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare and initialize an A3DSurfNurbsData structure.

\item {} 
Populate the surface Nurbs data structure by invoking the A3DSurfBaseGetAsNurbs function, providing the following arguments:
\begin{itemize}
\item {} 
The first argument (\sphinxcode{\sphinxupquote{sData.m\_pSurface}} in the following example) is a pointer to the surface base entity.

\item {} 
The second argument (\sphinxcode{\sphinxupquote{1e\sphinxhyphen{}3 / stdContextScale}} ) is a ratio that the function uses to scale the Nurbs data. The value \sphinxcode{\sphinxupquote{1e\sphinxhyphen{}3}} specifies the desired tolerance (0.001 mm in the following example). The \sphinxcode{\sphinxupquote{stdContextScale}} global variable is the Body Scale, which was obtained from the \sphinxcode{\sphinxupquote{A3DTopoContextData}} structure. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_37745}{Parse topology body data}.) The adjustment is calculated by dividing the targeted tolerance by the Body Scale.

\item {} 
The third argument (\sphinxcode{\sphinxupquote{bUseSameParameterization}} ) specifies that the conversion from the surface data to Nurbs data should use the parameterization data (if any) that is already specified in the face’s surface definition.

\item {} 
The fourth argument (\sphinxcode{\sphinxupquote{\&sNurbsData}} ) is a pointer to an empty structure in which the function stores the Nurbs data.

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASBool} \PYG{n}{bUseSameParameterization} \PYG{o}{=} \PYG{n}{TRUE}\PYG{p}{;}
\PYG{n}{A3DSurfNurbsData} \PYG{n}{sNurbsData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sNurbsData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DSurfBaseGetAsNurbs}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pSurface}\PYG{p}{,} \PYG{l+m+mf}{1e\PYGZhy{}3} \PYG{o}{/} \PYG{n}{stdContextScale}\PYG{p}{,}
  \PYG{n}{bUseSameParametrization}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sNurbsData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Determine the result of the \sphinxcode{\sphinxupquote{A3DSurfBaseGetAsNurbs}} function. In addition to returning the standard success and failure values, this function can also return the warning \sphinxcode{\sphinxupquote{A3D\_SRF\_NURBS\_CANNOT\_KEEP\_PARAMETERIZATION}}. This warning indicates that the conversion yielded a valid Nurbs surface but that associated space parametric trimming curves may be unreliable.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if (iRet == A3D\PYGZus{}SUCCESS ||
  iRet == A3D\PYGZus{}SRF\PYGZus{}NURBS\PYGZus{}CANNOT\PYGZus{}KEEP\PYGZus{}PARAMETERIZATION) \PYGZob{}
  …
\PYGZcb{}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
If Step \sphinxtitleref{Parse the surface data referenced by the ``m\_pSurface`} member in the \sphinxcode{\sphinxupquote{A3DTopoFaceData}} structure. (See Parse generic surface data.) <Plugins\_A3D\_API.html\#50618396\_80778>`\_\_ did not return with an error, delete the \sphinxcode{\sphinxupquote{A3DSurfNurbsData}} structure by invoking the \sphinxcode{\sphinxupquote{A3DSurfNurbsGet}} function with the first argument set to \sphinxcode{\sphinxupquote{NULL}} and the second argument set to the location of the structure (\sphinxcode{\sphinxupquote{\&sNurbsData}} in the following example).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DSurfNurbsGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sNurbsData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Parsing PRC entities that specify graphics}
\label{\detokenize{Plugins_A3D_API:parsing-prc-entities-that-specify-graphics}}
The \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference} groups the PRC entities that specify graphics into the graphic module. The graphics module includes the following categories of PRC entities:
\begin{itemize}
\item {} 
\sphinxstylestrong{Graphics entities:} Specify attributes that can apply to any graphic entity, such as color, line pattern, and coordinate system transformation.

\item {} 
\sphinxstylestrong{Camera entities:} Specify the position and direction from which a scene is viewed.

\item {} 
\sphinxstylestrong{Light entities:} Specify the quality of light applied to a 3D scene.

\item {} 
\sphinxstylestrong{SceneDisplay:} Specify viewing characteristics for a 3D representation, such as camera, lights, plane clipping, and background style.

\end{itemize}

{[}DG says: “parsing graphic PRC entities”. Explanation of Graphic Entities is very strange, and I cannot understand its meaning. These entities are very precise, and define precise things!!!!{]}

Some characteristics of PRC entities that specify graphics can be accessed only through the Acrobat 3D API \sphinxstyleemphasis{miscellaneous cascaded attributes}. These characteristics include the entity’s layer, coordinate system, and style attributes. Style attributes include line pattern index, RGB color index, and transparency setting. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_78726}{Parsing attributes that appear in an entity base}.)


\subsection{Parsing attributes that appear in an entity base}
\label{\detokenize{Plugins_A3D_API:parsing-attributes-that-appear-in-an-entity-base}}
This section explains how to obtain data from the root\sphinxhyphen{}base entity or from the miscellaneous cascaded attributes.

The Acrobat 3D Library uses a parallel structure for representing attributes that apply to PRC entities that have a particular PRC entity base. Data that is specific to the entity is defined in \sphinxcode{\sphinxupquote{A3D}} EntityName \sphinxcode{\sphinxupquote{Data}} structures (for example the \sphinxcode{\sphinxupquote{A3DAsmPartDefinitionData}} structure). These structures are used to create or parse the entity. Other data is defined in entities specific to the global or base types. (See the Related Pages on the \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference}.)


\subsubsection{Parsing root\sphinxhyphen{}base entity data}
\label{\detokenize{Plugins_A3D_API:parsing-root-base-entity-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare and initialize a \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRootBaseData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Populate the \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure by invoking the \sphinxcode{\sphinxupquote{A3DRootBaseGet}} function.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DRootBaseGet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Save the value of the \sphinxcode{\sphinxupquote{m\_pcName}} to your export structure.

\item {} 
For each \sphinxcode{\sphinxupquote{A3DMiscAttribute}} entity referenced by the array that is referenced by \sphinxcode{\sphinxupquote{m\_ppAttributes}}, process the contents. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_29718}{Parse the miscellaneous attribute entity}.)

\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRootBaseGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Parse the miscellaneous attribute entity}
\label{\detokenize{Plugins_A3D_API:parse-the-miscellaneous-attribute-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} structure.

\item {} 
Populate the \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} structure by invoking the \sphinxcode{\sphinxupquote{A3DMiscAttributeGet}} function. The first argument references the \sphinxcode{\sphinxupquote{A3DMiscAttribute}} entity (from root base data \sphinxcode{\sphinxupquote{m\_ppAttributes}} member), and the second argument references the \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} being populated.

\item {} 
Determine whether the root data contains modeler data by checking the \sphinxcode{\sphinxupquote{m\_pSingleAttributesData}} member. If its value is non\sphinxhyphen{}null, save the modeler data to your export structure.

\item {} 
Save the value of the \sphinxcode{\sphinxupquote{m\_pcName}} attribute to your export structure.

\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} structure created in Step \sphinxtitleref{Declare and initialize an ``A3DMiscAttributeData`} structure. <Plugins\_A3D\_API.html\#50618396\_78650>`\_\_.

\end{enumerate}


\subsubsection{Parsing graphic attributes using miscellaneous cascaded attributes}
\label{\detokenize{Plugins_A3D_API:parsing-graphic-attributes-using-miscellaneous-cascaded-attributes}}
Miscellaneous cascaded attributes manage the inheritable graphics data that can be applied to a PRC entity. Such inheritable data includes the show and remove settings, style attributes such as color and pattern, layer attributes, and coordinate system transformations.

The \sphinxcode{\sphinxupquote{A3DGraphicsCreate}} function lets you set the graphics data for an entity. It also lets you set inheritance behavior for the attributes. These bits can specify that an attribute be inherited from a child entity or from a parent entity.

The \sphinxcode{\sphinxupquote{A3DGraphicsGet}} function gets the graphics data for an entity, but it does not take into account inherited settings.

The following diagram illustrates the steps required to create and push miscellaneous cascaded attributes, depending on whether the entity represents a tessellation face.


\subsubsection{To create and push a miscellaneous cascaded attributes structure}
\label{\detokenize{Plugins_A3D_API:to-create-and-push-a-miscellaneous-cascaded-attributes-structure}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxhref{Plugins\_A3D\_API.html\#50618396\_26284}{Declare the structure for creating and pushing a cascaded attributes structure}.

\item {} 
Create and push a cascaded attributes structure. For entities in the tessellation module, include a pointer to the tessellation base entity (see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_14663}{Create and push a cascaded attributes structure for entities in the tessellated module}. For all other entities in the graphics module, see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_21570}{Create and push a cascaded attributes structure for graphic entities}.

\item {} 
\sphinxhref{Plugins\_A3D\_API.html\#50618396\_55967}{Delete the structure created for the miscellaneous cascaded attributes}.

\end{enumerate}


\paragraph{Declare the structure for creating and pushing a cascaded attributes structure}
\label{\detokenize{Plugins_A3D_API:declare-the-structure-for-creating-and-pushing-a-cascaded-attributes-structure}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare an empty cascaded data structure in which the cascaded attributes are to be stored. The macro \sphinxcode{\sphinxupquote{A3D\_INITIALIZE\_DATA}} clears the memory allocated to the structure and checks the size of the structure to avoid alignment problems.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DMiscCascadedAttributesData} \PYG{n}{sAttrData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sAttrData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Declare a null pointer to a miscellaneous cascaded attributes object.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DMiscCascadedAttributes}\PYG{o}{*} \PYG{n}{pAttr}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Create and push a cascaded attributes structure for graphic entities}
\label{\detokenize{Plugins_A3D_API:create-and-push-a-cascaded-attributes-structure-for-graphic-entities}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an empty miscellaneous cascaded attributes object by invoking the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesCreate}} function, providing as an argument the address of the previously created null pointer.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscCascadedAttributesCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Invoke the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesPush}} function, which creates the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributes}} object for the current PRC entity and pushes the parent \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributes}} object onto the stack. Provide the following arguments to \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesPush}}.
\begin{itemize}
\item {} 
The first argument (\sphinxcode{\sphinxupquote{pAttr}} in the following example) is a pointer to an empty miscellaneous cascaded attribute object. The \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesPush}} function populates this object.

\item {} 
The second argument (\sphinxcode{\sphinxupquote{pBase}} in the following example) is a pointer to the PRC entity of interest, recast as a \sphinxcode{\sphinxupquote{const A3DRootBaseWithGraphics*}}.

\item {} 
The third argument (\sphinxcode{\sphinxupquote{pFatherAttr}} in the following example) is a pointer to the parent entity’s \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributes}} object. Do not confuse this structure with the parent entity’s \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesData}} structure.

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscCascadedAttributesPush} \PYG{p}{(}\PYG{n}{pAttr}\PYG{p}{,} \PYG{n}{pBase}\PYG{p}{,} \PYG{n}{pFatherAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Get the data from the newly created cascaded attributes structure by invoking the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesGet}} function. Provide the following arguments:
\begin{itemize}
\item {} 
The first argument (\sphinxcode{\sphinxupquote{pAttr}} in the following example) references the cascaded attribute structure populated in Step \sphinxtitleref{Invoke the ``A3DMiscCascadedAttributesPush`} function, which creates the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributes}} object for the current PRC entity and pushes the parent \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributes}} object onto the stack. Provide the following arguments to \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesPush}}. <Plugins\_A3D\_API.html\#50618396\_62288>`\_\_.

\item {} 
The second argument (sAttrData in the following example) references the empty \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesData}} structure created previously. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_26284}{Declare the structure for creating and pushing a cascaded attributes structure}.) The \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesGet}} function stores the entity’s attributes in this structure.

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscCascadedAttributesGet}\PYG{p}{(}\PYG{n}{pAttr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sAttrData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Create and push a cascaded attributes structure for entities in the tessellated module}
\label{\detokenize{Plugins_A3D_API:create-and-push-a-cascaded-attributes-structure-for-entities-in-the-tessellated-module}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Invoke the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesPushTessFace}} function, providing the following arguments:
\begin{itemize}
\item {} 
The first argument (\sphinxcode{\sphinxupquote{pAttr}} in the following example) is a pointer to an empty miscellaneous cascaded attribute object. The \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesPushTessFace}} function populates this object.

\item {} 
The second argument (pRepItem in the following example) is a pointer to the representation item that contains the tessellation face.

\item {} 
The third argument (\sphinxcode{\sphinxupquote{pTessBase}} in the following example) is a pointer to the tessellation entity that contains the face, recast as a \sphinxcode{\sphinxupquote{const A3DTessBase*}} pointer. This argument can be cast from the \sphinxcode{\sphinxupquote{A3DTess3D}} entity.

\item {} 
The fourth argument (psTessFaceData in the following example) references an array of pointers to the \sphinxcode{\sphinxupquote{A3DTessFaceData}} structures that contain the face data. Use the \sphinxcode{\sphinxupquote{A3DTess3DGet}} function to obtain that structure.

\item {} 
The fifth argument (uiFaceIndex in the following example) is the face index used with the fourth argument to access the face data from the \sphinxcode{\sphinxupquote{m\_psFaceTessData}} member of the psTess3DData structure.

\item {} 
The sixth argument (\sphinxcode{\sphinxupquote{pFatherAttr}} in the following example) is a pointer to the parent entity’s \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributes}} object. Do not confuse this structure with the parent entity’s \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesData}} structure.

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscCascadedAttributesCreate}\PYG{p}{(}\PYG{n}{ppAttr}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{This} \PYG{n}{API} \PYG{o+ow}{is} \PYG{n}{dedicated} \PYG{n}{to} \PYG{n}{tessellation}
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscCascadedAttributesPushTessFace}\PYG{p}{(}\PYG{n}{pAttr}\PYG{p}{,} \PYG{n}{pRepItem}\PYG{p}{,} \PYG{n}{pTessBase}\PYG{p}{,}
  \PYG{n}{psTessFaceData}\PYG{p}{,} \PYG{n}{uiFaceIndex}\PYG{p}{,} \PYG{n}{pFatherAttr}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{p}{(}\PYG{o}{*}\PYG{n}{psAttrData}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscCascadedAttributesGet}\PYG{p}{(}\PYG{o}{*}\PYG{n}{ppAttr}\PYG{p}{,} \PYG{n}{psAttrData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Save relevant data to your export structure.

\item {} 
Delete the structure created for the miscellaneous cascaded attributes

\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributes}} structure by invoking the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesDelete}} function.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DMiscCascadedAttributesDelete}\PYG{p}{(}\PYG{n}{pAttr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Delete the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesData}} structure by invoking the \sphinxcode{\sphinxupquote{A3DMiscCascadedAttributesGet}} function, setting the first argument to \sphinxcode{\sphinxupquote{NULL}} and the second to the address of the structure. Here is an example:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DMiscCascadedAttributesGet}\PYG{p}{(}\PYG{n}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sAttrData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{A3DMiscCascadedAttributes}\PYG{o}{*} \PYG{n}{pAttr}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Terminating the interface with the Acrobat 3D API}
\label{\detokenize{Plugins_A3D_API:terminating-the-interface-with-the-acrobat-3d-api}}
When all parsing is complete, you must delete the in\sphinxhyphen{}memory model of the PRC, de\sphinxhyphen{}allocate any other memory allocations, and terminate the Acrobat 3D API.


\subsubsection{Terminate your interface with the Acrobat 3D API}
\label{\detokenize{Plugins_A3D_API:terminate-your-interface-with-the-acrobat-3d-api}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Delete the model file in memory. This model was created when the \sphinxcode{\sphinxupquote{A3DAsmModelFileLoadFromFile}} function was called.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmModelFileDelete}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ensure that all memory is de\sphinxhyphen{}allocated.

\item {} 
Terminate the Acrobat 3D API by invoking the \sphinxcode{\sphinxupquote{A3DDllTerminate}} function, as follows:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DDllTerminate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Creating a PRC file that uses boundary representation}
\label{\detokenize{Plugins_A3D_API:creating-a-prc-file-that-uses-boundary-representation}}
The Acrobat 3D SDK lets you create a representation item for a boundary representation that is optionally accompanied by tessellation data. Boundary representations with or without tessellation data can represent curves, or open or closed solids. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_79448}{Creating a tessellation entity for representing faceted objects}.)

This section explains how to create a PRC file that represents a circular band (a co\sphinxhyphen{}edge) that is UV\sphinxhyphen{}mapped to a clear cylinder surface (pictured below). More specifically, the solid in this 3D image contains a single face, which in turn contains a cylinder and a loop. The loop contains a single co\sphinxhyphen{}edge that contains two circular curves. The co\sphinxhyphen{}edge is UV\sphinxhyphen{}mapped to the cylinder. The following images show the resulting image from different perspectives. To open a PDF document that contains the PRC content pictured below, click \sphinxhref{./CreatedPRC.pdf}{here}.

\noindent\sphinxincludegraphics{{prccontent}.png}
\phantomsection\label{\detokenize{Plugins_A3D_API:section-1}}
The following diagram shows the tasks required to create each PRC entity to represent the image pictured above. This diagram is intended to portray a bottom\sphinxhyphen{}up process, where upper\sphinxhyphen{}level functions are not complete until their lower\sphinxhyphen{}level functions are completed. That is, the most basic PRC entities (such as vertices, edges and coedges) are created first, followed by the more complex PRC entities that consist of those basic PRC entities and other data. The last PRC entity to be created is the model file.

\noindent\sphinxincludegraphics{{prcstructural}.png}

\noindent\sphinxincludegraphics{{structuralbrep}.png}


\subsection{Error handling}
\label{\detokenize{Plugins_A3D_API:error-handling}}\label{\detokenize{Plugins_A3D_API:handling-errors-1}}
For information about handling errors, see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_19574}{Handling errors}.


\subsection{Creating a model file entity and exporting it to a physical file}
\label{\detokenize{Plugins_A3D_API:creating-a-model-file-entity-and-exporting-it-to-a-physical-file}}
This section describes how to initiate the process of creating a model file and how to export that data to a physical file.


\subsubsection{Create a file that contains the PRC data}
\label{\detokenize{Plugins_A3D_API:create-a-file-that-contains-the-prc-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a pointer that references a populated model file entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_77401}{Create a model file entity}.) In the following example, \sphinxcode{\sphinxupquote{createModelFile}} is a private function that returns a pointer to a populated model file.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmModelFile}\PYG{o}{*} \PYG{n}{pModelFile} \PYG{o}{=} \PYG{n}{createModelFile}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Create the model file entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_77401}{Create a model file entity}.)

\item {} 
Save the contents of the model file to a physical file by invoking the \sphinxcode{\sphinxupquote{A3DAsmModelFileWriteToFile}} function.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{p} \PYG{o}{!=} \PYG{n}{NULL}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{\PYGZus{}access}\PYG{p}{(}\PYG{n}{pcPRCName}\PYG{p}{,} \PYG{l+m+mi}{00}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{\PYGZus{}unlink}\PYG{p}{(}\PYG{n}{pcPRCName}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DAsmModelFileWriteToFile}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{pcPRCName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Delete the model file populated in Step \sphinxtitleref{Create a pointer that references a populated model file entity. (See Create a model file entity.) In the following example, ``createModelFile`} is a private function that returns a pointer to a populated model file. <Plugins\_A3D\_API.html\#50618396\_97368>`\_\_.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmModelFileDelete}\PYG{p}{(}\PYG{n}{pModelFile}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The Acrobat 3D API functions in this chapter are described as though implicit linking were possible. Wherever you see a direct call to one of these functions, you should instead use the pointer to the function. See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_37765}{Implementing external linking}.
\end{sphinxadmonition}


\subsection{Creating structure PRC entities}
\label{\detokenize{Plugins_A3D_API:creating-structure-prc-entities}}
This section explains how to create the PRC entities that represent the structure of the PRC file, such as the model file, product occurrences, and part definitions. The names of structure module entities have the form \sphinxcode{\sphinxupquote{A3DAsm}} \sphinxstyleemphasis{Entity\_name}.


\subsubsection{Create a model file entity}
\label{\detokenize{Plugins_A3D_API:create-a-model-file-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
If the model file references multiple product occurrences, create an array to accommodate a pointer that references each product occurrence.

\item {} 
For each product occurrence in the model file, create a pointer that references a populated product occurrence entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_92923}{Create a product occurrence}.) In the following example, \sphinxcode{\sphinxupquote{createOccurrence}} is a private function that returns a pointer to a populated product occurrence.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmProductOccurrence}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createOccurrence}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Declare and initialize a model file data structure and set the values of its members, as follows:
\begin{itemize}
\item {} 
m\_uiPOccurrencesSize represents the number of child product occurrences.

\item {} 
m\_dUnit is a multiple of millimeters that specifies the units used by the 3D data in the structure element.

\item {} 
m\_ppPOccurrences references the array of product occurrence pointers.

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmModelFileData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiPOccurrencesSize} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}dUnit} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppPOccurrences} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Encapsulate the model file data by invoking the \sphinxcode{\sphinxupquote{A3DAsmModelFileCreate}} function. The first argument is a pointer to the model file data, and the second argument is a pointer to the model file entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DAsmModelFileCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pModelFile}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Optionally, associate the model file entity with root\sphinxhyphen{}level attributes (see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_49152}{Defining root\sphinxhyphen{}level attributes for a PRC entity}).

\end{enumerate}


\subsubsection{Create a product occurrence}
\label{\detokenize{Plugins_A3D_API:create-a-product-occurrence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a null pointer to a product occurrence.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmProductOccurrence}\PYG{o}{*} \PYG{n}{pProductOccurrrence} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Create a pointer to a populated part definition. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60514}{Create a part definition}.) In the following example, \sphinxcode{\sphinxupquote{createPart}} is a private function that returns a pointer to a populated part definition entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmPartDefinition}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createPart}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Set the \sphinxcode{\sphinxupquote{m\_pPart}} member to reference the part created in Step \sphinxtitleref{Create a pointer to a populated part definition. (See Create a part definition.) In the following example, ``createPart`} is a private function that returns a pointer to a populated part definition entity. <Plugins\_A3D\_API.html\#50618396\_82443>`\_\_.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmProductOccurrenceData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pPart} \PYG{o}{=} \PYG{n}{p}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Package the product occurrence data as a PRC entity by invoking the \sphinxcode{\sphinxupquote{A3DAsmProductOccurrenceCreate}} function. The first argument is a pointer to the product occurrence data, and the second argument is an indirect pointer to the product occurrence.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=}
  \PYG{n}{A3DAsmProductOccurrenceCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pProductOccurrence}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Define the cascaded attributes for the product occurrence. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_49152}{Defining root\sphinxhyphen{}level attributes for a PRC entity}.)

\end{enumerate}


\subsubsection{Create a part definition}
\label{\detokenize{Plugins_A3D_API:create-a-part-definition}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a null pointer to a part definition.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmPartDefinition}\PYG{o}{*} \PYG{n}{pPartDefinition} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Declare and initialize a part definition data structure, as shown in the following example.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DAsmPartDefinitionData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
For each representation item referenced by this part definition, create a pointer to that representation item and populate it. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_96018}{Create a Brep model representation item}.) In the following example, \sphinxcode{\sphinxupquote{createRIBrep}} is a private function that returns a pointer to a populated Brep representation item.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiRepresentationItem}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createRIBrep}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Set the \sphinxcode{\sphinxupquote{m\_uiRepItemsSize}} member of the part definition to the number of representation items.

\item {} 
Set the \sphinxcode{\sphinxupquote{m\_ppRepItems}} member of the part definition to the array of pointers for the representation items. The following example describes a part definition that references a single representation item:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiRepItemsSize} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppRepItems} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Package the part definition data as a PRC entity by invoking the \sphinxcode{\sphinxupquote{A3DAsmPartDefinitionCreate}} function. The first argument is a pointer to the product occurrence data, and the second is the pointer to the part definition created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_95370}{Declare a null pointer to a part definition.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DAsmPartDefinitionCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pPartDefinition}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Creating representation item PRC entities}
\label{\detokenize{Plugins_A3D_API:creating-representation-item-prc-entities}}
The \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference} groups the PRC entities that specify individual objects present in the CAD file into the representation item module. Representation items define a particular aspect of the geometric data. The Brep model representation item is one of the PRC entities available for packaging distinct 3D objects. Some of the other representation items include set, point set, poly Brep model, and polywire.


\subsubsection{Create a Brep model representation item}
\label{\detokenize{Plugins_A3D_API:create-a-brep-model-representation-item}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a pointer to a Brep model entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiBrepModel}\PYG{o}{*} \PYG{n}{pBrepModel} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Create a pointer to a populated topology Brep data entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_82589}{Create a topology Brep data entity}.) The \sphinxcode{\sphinxupquote{createTopoBrep}} function in the following example is a private function that returns a reference to a populated topology Brep data entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoBrep}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createTopoBrep}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Declare and initialize a Brep model data structure, and set its member values. In the following example, the \sphinxcode{\sphinxupquote{m\_pBrepData}} member references the Brep data entity created in the previous step, and the \sphinxcode{\sphinxupquote{m\_bSolid}} member is set to \sphinxcode{\sphinxupquote{FALSE}}, indicating that the Brep model is a shell.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DRiBrepModelData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pBrepData} \PYG{o}{=} \PYG{n}{p}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}bSolid} \PYG{o}{=} \PYG{n}{FALSE}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Package the Brep model data as a PRC entity by invoking the \sphinxcode{\sphinxupquote{A3DRiBrepModelCreate}} function. The first argument is a pointer to the Brep data structure, and the second is a pointer to the Brep model created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_71454}{Declare a pointer to a Brep model entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet}\PYG{o}{=}\PYG{n}{A3DRiBrepModelCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pBrepModel}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Creating topology PRC entities}
\label{\detokenize{Plugins_A3D_API:creating-topology-prc-entities}}
The \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference} groups the PRC entities that specify topology into the topology module. The topology module uses a hierarchy of faces to define the shapes of 3D objects.


\subsubsection{Create a topology Brep data entity}
\label{\detokenize{Plugins_A3D_API:create-a-topology-brep-data-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a null pointer to a topology Brep data entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoBrepData}\PYG{o}{*} \PYG{n}{pTopoBrepData} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Tip} : Do not confuse the A3DTopoBrepData entity with the \sphinxcode{\sphinxupquote{A3DTopoBrepDataData}} structure. The former references a PRC entity (an opaque type), while the latter reveals the data in that entity.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
For each topology connex data in the Brep data entity, create a pointer that references a populated topology connex entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_28148}{Create a topology connex entity}.) In the following example, \sphinxcode{\sphinxupquote{createTopoConnex}} is a private function that returns a reference to a populated topology connex entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoConnex}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createTopoConnex}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
If the Brep representation item references multiple topology connex entities, allocate memory for an array of references to the topology connexes in the Brep data entity.

\item {} 
Declare and initialize a \sphinxcode{\sphinxupquote{A3DTopoBrepDataData}} structure. Set the \sphinxcode{\sphinxupquote{m\_ppConnexes}} member to reference the array of topology connex entities, and set the \sphinxcode{\sphinxupquote{m\_uiConnexSize}} member to the number of entries in the array.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoBrepDataData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppConnexes} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiConnexSize} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Package the A3DTopoBrepDataData structure as a PRC entity by invoking the \sphinxcode{\sphinxupquote{A3DAsmPartDefinitionCreate}} function. The first argument is a pointer to the Brep\sphinxhyphen{}data data structure (\sphinxcode{\sphinxupquote{A3DTopoBrepDataData}} ), and the second is the pointer to the Brep data entity created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_66118}{Create a null pointer to a topology Brep data entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoBrepDataCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pTopoBrepData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Create a topology connex entity}
\label{\detokenize{Plugins_A3D_API:create-a-topology-connex-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a pointer to a topology connex entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoConnex}\PYG{o}{*} \PYG{n}{pTopoConnex} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
For each topology shell in the topology connex entity, create a pointer that references a populated topology shell entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_38928}{Create a topology shell entity}.) In the following example, \sphinxcode{\sphinxupquote{createTopoShell}} is a private function that returns a reference to a populated topology shell entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoShell}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createTopoShell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
If the topology connex entity references multiple topology shell entities, allocate memory for an array to accommodate each topology shell entity pointer.

\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DTopoConnexData}} structure. Set the m\_ppShells member to reference the array that contains the pointers, and set the m\_uiShellSize member to the number of pointers.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoConnexData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppShells} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiShellSize} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Package the topology connex data as a PRC entity by invoking the \sphinxcode{\sphinxupquote{A3DTopoConnexCreate}} function. The first argument is a pointer to the Brep\sphinxhyphen{}data data structure (\sphinxcode{\sphinxupquote{A3DTopoBrepDataData}} ), and the second is the pointer to the topology connex entity created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_81092}{Declare a pointer to a topology connex entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoConnexCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pTopoConnex}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Create a topology shell entity}
\label{\detokenize{Plugins_A3D_API:create-a-topology-shell-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a null pointer to a topology shell entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoShell}\PYG{o}{*} \PYG{n}{pTopoShell} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
If the topology shell references multiple topology face entities, create an array to accommodate each pointer.

\item {} 
For each topology face in the topology shell, create a pointer that references a populated topology face entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_58671}{Create a topology face entity}.) In the following example, \sphinxcode{\sphinxupquote{createTopoFace}} is a private function that returns a reference to a populated topology shell entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoFace}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createTopoFace}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DTopoShellData}} structure. Set the \sphinxcode{\sphinxupquote{m\_ppFaces}} member to reference the array of topology face entities, and set the \sphinxcode{\sphinxupquote{m\_uiFaceSize}} member to the number of topology shell face entities.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoShellData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppFaces} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiFaceSize} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Set the \sphinxcode{\sphinxupquote{A3DTopoShellData}} structure’s \sphinxcode{\sphinxupquote{m\_pucOrientationWithShell}} member to reference an ASUns8 integer that specifies the orientation of the surface normal with respect to the shell normal. If the shell is closed and otherwise arbitrary, the shell normal points outside the material. The following example specifies that the surface normal has the same orientation as the face and shell.

\end{enumerate}

\begin{sphinxadmonition}{warning}{Warning:}
Despite the simplicity of the values it expresses, the \sphinxcode{\sphinxupquote{m\_pucOrientationWithShell}} is a pointer to an ASUns8 integer; it is not itself an ASUns8 integer.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASUns8} \PYG{n}{orient} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pucOrientationWithShell} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{orient}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Package the topology shell data as a PRC entity by invoking the \sphinxcode{\sphinxupquote{A3DTopoShellCreate}} function. The first argument is a pointer to the topology shell data, and the second is the pointer to the topology shell entity created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_18056}{Declare a null pointer to a topology shell entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoShellCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pTopoShell}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Create a topology face entity}
\label{\detokenize{Plugins_A3D_API:create-a-topology-face-entity}}
The example described here UV\sphinxhyphen{}maps onto a cylinder surface a topology loop representing a circular band.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a null pointer to a topology face entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoFace}\PYG{o}{*} \PYG{n}{pTopoFace} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
If the topology face references multiple loop entities, declare an array to accommodate each pointer.

\item {} 
For each loop in the topology face, create a pointer that references a populated loop entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_79807}{Create a topology loop entity}.) In the following example, \sphinxcode{\sphinxupquote{createTopoLoop}} is a private function that returns a reference to a populated loop entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DDouble} \PYG{n}{outerradius} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{n}{A3DDouble} \PYG{n}{innerradius} \PYG{o}{=} \PYG{l+m+mf}{0.4}\PYG{p}{;}
\PYG{n}{A3DTopoLoop}\PYG{o}{*} \PYG{n}{loops}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{loops}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{createTopoLoop}\PYG{p}{(}\PYG{n}{outerradius}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{loops}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{createTopoLoop}\PYG{p}{(}\PYG{n}{innerradius}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DTopoFaceData}} structure. Set the m\_ppLoops member to reference the array of loop entity pointers, and set the m\_uiLoopSize member to the number of loop entities in the array. Set the m\_uiOuterLoopIndex member to the array index of the topology loop that describes the outer loop. If unknown, set that member to \sphinxcode{\sphinxupquote{A3D\_LOOP\_UNKNOW\_OUTER\_INDEX}}.

\end{enumerate}

In the following example, \sphinxcode{\sphinxupquote{m\_uiOuterLoopIndex}} indicates that the outer loop is the first entry in the \sphinxcode{\sphinxupquote{loops}} array.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoFaceData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppLoops} \PYG{o}{=} \PYG{n}{loops}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiLoopSize} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiOuterLoopIndex} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Declare a pointer that references a populated surface base entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_54641}{Create a surface cylinder entity}.) Set the m\_pSurface member of the \sphinxcode{\sphinxupquote{A3DTopoFaceData}} structure to reference the populated surface. In the following example, \sphinxcode{\sphinxupquote{createSurface}} is a private function that returns a reference to a populated cylinder surface entity. The returned value is cast as a pointer to a surface base.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DSurfBase} \PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createSurface}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pSurface} \PYG{o}{=} \PYG{n}{p}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Package the topology face data as a PRC entity by invoking the A3DTopoFaceCreate function. The first argument is a pointer to the topology face data, and the second is the pointer to the topology face entity created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_14957}{Declare a null pointer to a topology face entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoFaceCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pTopoFace}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Create a topology loop entity}
\label{\detokenize{Plugins_A3D_API:create-a-topology-loop-entity}}
A loop is a connected series of co\sphinxhyphen{}edges and describes the boundary of a face. Generally, loops are closed, having no start or end point.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a null pointer to a topology loop entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoLoop}\PYG{o}{*} \PYG{n}{pTopoLoop} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
If the topology loop references multiple co\sphinxhyphen{}edge entities, declare an array to accommodate each pointer.

\item {} 
For each co\sphinxhyphen{}edge in the loop, do the following:
\begin{itemize}
\item {} 
Create a pointer that references a populated circle entity with a given radius. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_81895}{Create a circular curve entity}.)

\item {} 
Create a pointer that references a populated co\sphinxhyphen{}edge entity with a given curve. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_67390}{Create a topology co\sphinxhyphen{}edge entity}.)

\end{itemize}

\end{enumerate}

In the following example, \sphinxcode{\sphinxupquote{createCircle}} is a private function that takes a radius and returns a reference to a populated circular curve entity, and \sphinxcode{\sphinxupquote{createTopoCoEdge}} is a private function that takes a pointer to a circle entity and returns a reference to a populated co\sphinxhyphen{}edge entity. The circle\sphinxhyphen{}entity describes a curve.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DCrvBase}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{createCircle}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{A3DTopoCoEdge}\PYG{o}{*} \PYG{n}{q} \PYG{o}{=} \PYG{n}{createTopoCoEdge}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Declare and initialize an A3DTopoLoopData structure. Set the m\_ppCoEdges member to reference the array of co\sphinxhyphen{}edge entity pointers, and set the m\_uiCoEdgeSize member to the number of entities in the array.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoLoopData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppCoEdges} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{q}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiCoEdgeSize} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Set the A3DTopoLoopData structure’s m\_ucOrientationWithSurface member to specify the orientation of the loop relative to the surface normal vector. The following example specifies that the orientation is perpendicular to the surface normal vector (or parallel with the surface).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ucOrientationWithSurface} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Package the topology face data as a PRC entity by invoking the A3DTopoLoopCreate function. The first argument is a pointer to the topology loop data, and the second is the pointer to the topology loop entity created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_78554}{Declare a null pointer to a topology loop entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet}\PYG{o}{=}\PYG{n}{A3DTopoLoopCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pTopoLoop}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Create a topology co\sphinxhyphen{}edge entity}
\label{\detokenize{Plugins_A3D_API:create-a-topology-co-edge-entity}}
A coedge is a directed edge. The two co\sphinxhyphen{}edges related to an edge point in the same or opposite directions along the edge. Each co\sphinxhyphen{}edge is associated with a loop of one of the two neighboring/adjacent faces.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a pointer to a populated \sphinxcode{\sphinxupquote{A3DTopoEdge}} entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_10967}{Create a topology edge entity}.)

\item {} 
Declare and initialize a topology co\sphinxhyphen{}edge data entity.

\item {} 
Set the m\_pUVCurve member of the data entity to reference the circle entity created earlier (see \sphinxhref{Plugins\_A3D\_API.html\#50618396\_79807}{Create a topology loop entity}).

\end{enumerate}

Set the \sphinxcode{\sphinxupquote{m\_pEdge}} member to the edge entity created in Step \sphinxtitleref{Create a pointer to a populated ``A3DTopoEdge`} entity. (See Create a topology edge entity.) <Plugins\_A3D\_API.html\#50618396\_38878>`\_\_.

\begin{sphinxadmonition}{warning}{Warning:}
To set the value of the \sphinxcode{\sphinxupquote{m\_pUVCurve}} member using meaningful data, you need your own modeler.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoCoEdgeData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pUVCurve} \PYG{o}{=} \PYG{n}{p}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pEdge} \PYG{o}{=} \PYG{n}{q}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Set the m\_ucOrientationWithLoop member to indicate the relative orientation of the loop.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ucOrientationWithLoop} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{*} \PYG{n}{Same} \PYG{n}{orientation} \PYG{k}{as} \PYG{n}{the} \PYG{n}{adjacent} \PYG{n}{co}\PYG{o}{\PYGZhy{}}\PYG{n}{edge}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ucOrientationUVWithLoop} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Package the co\sphinxhyphen{}edge data as a PRC entity by invoking the A3DTopoEdgeCreate function. The first argument is a pointer to the topology loop data, and the second is the pointer to the topology edge entity created in Step \sphinxtitleref{Create a pointer to a populated ``A3DTopoEdge`} entity. (See Create a topology edge entity.) <Plugins\_A3D\_API.html\#50618396\_38878>`\_\_.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoCoEdgeCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Create a topology edge entity}
\label{\detokenize{Plugins_A3D_API:create-a-topology-edge-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a null pointer to a topology edge entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoEdge}\PYG{o}{*} \PYG{n}{pTopoEdge} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Declare and initialize a topology edge data structure.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTopoEdgeData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Populate the members with data.

\item {} 
Package the topology face data as a PRC entity by invoking the A3DTopoEdgeCreate function. The first argument is a pointer to the topology loop data, and the second is the pointer to the topology edge entity created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_40375}{Declare a null pointer to a topology edge entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DTopoEdgeCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pTopoEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Creating geometry PRC entities}
\label{\detokenize{Plugins_A3D_API:creating-geometry-prc-entities}}
The \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference} describes the PRC entities that specify geometry in the Geometry module. This module contains these submodules:

\sphinxstylestrong{Curves:} Entities that represent different kinds of curves, such as NURBS, elliptic, and helical.

\sphinxstylestrong{Surfaces:} Entities that represent different kinds of surfaces, such as NURBS, spheric, and toric.

\sphinxstylestrong{Common Structures for Geometric Entities:} Entities that supplement data in the Curves and Surfaces modules.

This section describes the creation of a cylinder surface on which a circular co\sphinxhyphen{}edge is UV\sphinxhyphen{}mapped.

A circular curve includes a coordinate system and parameterization settings. By default, the reference domain is {[}0, 2PI{]}. A circular curve uses an \sphinxcode{\sphinxupquote{A3IntervalData}} entity as the linear domain and an \sphinxcode{\sphinxupquote{A3DMiscCartesianTransformationData}} structure as the coordinate system. New parameterization is computed from two coefficients applied to the reference parameterization {[}0, 2PI{]}.


\subsubsection{Create a surface cylinder entity}
\label{\detokenize{Plugins_A3D_API:create-a-surface-cylinder-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a null pointer to an A3DSurfCylinder entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DSurfCylinder}\PYG{o}{*} \PYG{n}{pSurfCylinder} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Declare and initialize a surface cylinder data structure, and initialize the structures it contains.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DSurfCylinderData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sTrsf}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Set the UV\sphinxhyphen{}parameterization data of the surface cylinder data structure, which specifies how the circular curve is mapped to the cylinder. The following example specifies the trimming and orientation of the mapping:
\begin{itemize}
\item {} 
Minimum and maximum extents in the UV domain (\sphinxcode{\sphinxupquote{sData.m\_sParam.m\_sUVDomain}} ) establish the trimming contour in the final parameterization space. Each extent is a 2D vector. The following example clips the texture represented by the co\sphinxhyphen{}edge to the area described by {[}0.0, 0.0{]} and {[}360.0 40.0{]}.

\item {} 
Coefficients establish parameterization along the U and V axes. In this example, U values are expressed as inverted degrees (1.0/degrees). V values are expressed as inverted lengths (1.0/length).

\end{itemize}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}sUVDomain}\PYG{o}{.}\PYG{n}{m\PYGZus{}sMin}\PYG{o}{.}\PYG{n}{m\PYGZus{}dX} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}sUVDomain}\PYG{o}{.}\PYG{n}{m\PYGZus{}sMin}\PYG{o}{.}\PYG{n}{m\PYGZus{}dY} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}sUVDomain}\PYG{o}{.}\PYG{n}{m\PYGZus{}sMax}\PYG{o}{.}\PYG{n}{m\PYGZus{}dX} \PYG{o}{=} \PYG{l+m+mf}{360.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}sUVDomain}\PYG{o}{.}\PYG{n}{m\PYGZus{}sMax}\PYG{o}{.}\PYG{n}{m\PYGZus{}dY} \PYG{o}{=} \PYG{l+m+mf}{40.0}\PYG{p}{;}
\PYG{o}{/}\PYG{o}{/}    \PYG{n}{Parameters} \PYG{n}{go} \PYG{k+kn}{from} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{to} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{both} \PYG{n}{directions}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}dUCoeffA} \PYG{o}{=}
  \PYG{l+m+mf}{1.0} \PYG{o}{/} \PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}sUVDomain}\PYG{o}{.}\PYG{n}{m\PYGZus{}sMax}\PYG{o}{.}\PYG{n}{m\PYGZus{}dX} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}dUCoeffB} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}dVCoeffA} \PYG{o}{=}
  \PYG{l+m+mf}{1.0} \PYG{o}{/} \PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}sUVDomain}\PYG{o}{.}\PYG{n}{m\PYGZus{}sMax}\PYG{o}{.}\PYG{n}{m\PYGZus{}dY} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}dVCoeffB} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}bSwapUV} \PYG{o}{=} \PYG{n}{FALSE}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sTrsf}\PYG{o}{.}\PYG{n}{m\PYGZus{}ucBehaviour} \PYG{o}{=} \PYG{n}{kA3DTransformationIdentity}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Set other member values of the surface cylinder data structure. In the following example, the radius of the cylinder is set to 10.0. The unit of measure (as multiples of millimeters) was previously set for the model file entity. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_77401}{Create a model file entity}.)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}dRadius} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Package the cylinder data as a PRC entity by invoking the A3DSurfCylinderCreate function. The first argument is a pointer to the surface cylinder data, and the second is the pointer to the surface cylinder entity created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_52301}{Declare a null pointer to an A3DSurfCylinder entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DSurfCylinderCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pSurfCylinder}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Create a circular curve entity}
\label{\detokenize{Plugins_A3D_API:create-a-circular-curve-entity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Declare a null pointer to a circular curve entity.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DCrvCircle}\PYG{o}{*} \PYG{n}{pCrvCircle} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Declare and initialize a circular curve data structure, and initialize the structures it contains.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DCrvCircleData} \PYG{n}{sData}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sTrsf}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Set the values of the circular curve data structure. The following example sets the radius of the circle to a value originally specified during loop creation. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_58671}{Create a topology face entity}.)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}dRadius} \PYG{o}{=} \PYG{n}{radius}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Set the values of the parameterization structure within the circular curve data structure. In this example, the interval defines the circular arc as the entire circle and the co\sphinxhyphen{}efficients set the parameterization across the entire length of the circular arc.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}dCoeffA} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}dCoeffB} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}sInterval}\PYG{o}{.}\PYG{n}{m\PYGZus{}dMin} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sParam}\PYG{o}{.}\PYG{n}{m\PYGZus{}sInterval}\PYG{o}{.}\PYG{n}{m\PYGZus{}dMax} \PYG{o}{=} \PYG{l+m+mi}{360}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Set the values of the Cartesian transformation structure within the circular curve data structure. The following example sets the behavior of the Cartesian transformation data to the identity transformation.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sData}\PYG{o}{.}\PYG{n}{m\PYGZus{}sTrsf}\PYG{o}{.}\PYG{n}{m\PYGZus{}ucBehaviour} \PYG{o}{=} \PYG{n}{kA3DTransformationIdentity}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Package the curve data as a PRC entity by invoking the A3DCrvCircleCreate function. The first argument is a pointer to the curve circle data, and the second is the pointer to the circular curve entity created in Step \sphinxhref{Plugins\_A3D\_API.html\#50618396\_46262}{Declare a null pointer to a circular curve entity.}.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DCrvCircleCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pCrvCircle}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Defining root\sphinxhyphen{}level attributes for a PRC entity}
\label{\detokenize{Plugins_A3D_API:defining-root-level-attributes-for-a-prc-entity}}
The Acrobat 3D API lets you create a set of attributes named \sphinxstyleemphasis{root\sphinxhyphen{}level attributes} that can be applied to any PRC entity. These attributes are packaged as an \sphinxcode{\sphinxupquote{A3DRootBase}} entity that is referenced from the PRC entity they describe.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{A3DRootBaseData}}. This structure has a name and can have pointers to multiple \sphinxcode{\sphinxupquote{A3DMiscAttribute}} entities.

\item {} 
\sphinxcode{\sphinxupquote{A3DMiscAttributeData}}. This structure has a name and can reference a single \sphinxcode{\sphinxupquote{A3DMiscSingle}} structure.

\item {} 
\sphinxcode{\sphinxupquote{A3DMiscSingleAttributeData}}. This structure is used for modeler data, such as string or time. It has a title, a type designation, and data. The name in the parent \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} must match the title in the \sphinxcode{\sphinxupquote{A3DMiscSingleAttributeData}}. This structure is terminal.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
See the \sphinxhref{./API\_References/PRCReference/3D\_API\_Reference/index.html}{Acrobat 3D API Reference} for limitations on including modeler data in the root\sphinxhyphen{}level attributes for a PRC entity.
\end{sphinxadmonition}

Here is a diagram that shows the structure of the \sphinxcode{\sphinxupquote{A3DRootBase}} entity that can be associated with any PRC entity. The \sphinxcode{\sphinxupquote{A3DMiscSingleAttributeData}} structures are used only for modeler attributes. The sample code that comes after the following task descriptions exemplifies this structure.

\noindent\sphinxincludegraphics{{rootbase}.png}


\subsubsection{Define miscellaneous attributes that omit modeler data}
\label{\detokenize{Plugins_A3D_API:define-miscellaneous-attributes-that-omit-modeler-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Determine the string to use at the top level of the attributes and (optionally) the strings to use at subordinate levels.

\item {} 
Declare an array to accommodate pointers to the \sphinxcode{\sphinxupquote{A3DMiscAttribute}} entities that you will create in a subsequent step.

\item {} 
For each subordinate\sphinxhyphen{}level string, declare and initialize an \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} structure. Set the \sphinxcode{\sphinxupquote{m\_pcTitle}} member to the subordinate\sphinxhyphen{}level string. Leave the \sphinxcode{\sphinxupquote{m\_uiSize}} and \sphinxcode{\sphinxupquote{m\_pSingleAttributesData}} members set to 0 because this structure omits modeler data.

\item {} 
Package each \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} structure as an \sphinxcode{\sphinxupquote{A3DMiscAttribute}} entity by invoking the \sphinxcode{\sphinxupquote{A3DMiscAttributeCreate}} function. Save the entity pointer in the array created in Step \sphinxtitleref{Declare an array to accommodate pointers to the ``A3DMiscAttribute`} entities that you will create in a subsequent step. <Plugins\_A3D\_API.html\#50618396\_49803>`\_\_.

\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure. Set its \sphinxcode{\sphinxupquote{m\_pcName}} member to the top\sphinxhyphen{}level string. Set the \sphinxcode{\sphinxupquote{m\_ppAttributes}} member to reference the array that contains pointers to the \sphinxcode{\sphinxupquote{A3DMiscAttribute}} entities.

\item {} 
Invoke the A3DRootBaseSet function to package the \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure as an \sphinxcode{\sphinxupquote{A3DRootBase}} entity associated with a PRC entity. The first argument in this call is a pointer to the entity, and the second is a pointer to the \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure.

\end{enumerate}


\subsubsection{Define miscellaneous attributes that include modeler data}
\label{\detokenize{Plugins_A3D_API:define-miscellaneous-attributes-that-include-modeler-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Determine the strings to use for modeler data and the type represented by each string. Here are the possible types and the enumerations that identify them:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{kA3DModellerAttributeTypeInt}} integer (32 bits)

\item {} 
\sphinxcode{\sphinxupquote{kA3DModellerAttributeTypeReal}} floating point

\item {} 
\sphinxcode{\sphinxupquote{kA3DModellerAttributeTypeTime}} integer (32 bits), which uses the same conventions as the \sphinxcode{\sphinxupquote{time\_t}} C datatype.

\item {} 
\sphinxcode{\sphinxupquote{kA3DModellerAttributeTypeString}} UTF\sphinxhyphen{}8 character string

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Determine the titles to use for each piece of modeler data.

\item {} 
Declare an array to accommodate pointers to the \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} entities that you will create in a subsequent step.

\item {} 
For each modeler attribute associated with the root base entity, do the following:
\begin{itemize}
\item {} 
Declare and initialize an A3DMiscSingleAttributeData structure. Set the \sphinxcode{\sphinxupquote{m\_eType}} member to the type of the data, set the \sphinxcode{\sphinxupquote{m\_pcData}} member to a string that represents the data, and set the \sphinxcode{\sphinxupquote{m\_pcTitle}} member to a title that identifies the data.

\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} structure. Set the \sphinxcode{\sphinxupquote{m\_pcTitle}} member to the same title used in the A3DMiscSingleAttributeData structure. Set the \sphinxcode{\sphinxupquote{m\_uiSize}} member to 1, and the \sphinxcode{\sphinxupquote{m\_pSingleAtttributesData}} member to reference the A3DMiscSingleAttributeData structure.

\end{itemize}

\end{enumerate}

\begin{sphinxadmonition}{warning}{Warning:}
Each A3DMiscSingleAttributeData structure that references another A3DMiscSingleAttributeData structure must reference only one such structure and must have the same title as that structure.
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Package each \sphinxcode{\sphinxupquote{A3DMiscAttributeData}} structure as an \sphinxcode{\sphinxupquote{A3DMiscAttribute}} entity by invoking the \sphinxcode{\sphinxupquote{A3DMiscAttributeCreate}} function. Save the entity pointer in the array created in Step \sphinxtitleref{Declare an array to accommodate pointers to the ``A3DMiscAttributeData`} entities that you will create in a subsequent step. <Plugins\_A3D\_API.html\#50618396\_41483>`\_\_.

\item {} 
Declare and initialize an \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure. (See Step \sphinxtitleref{Declare and initialize an ``A3DRootBaseData`} structure. Set its \sphinxcode{\sphinxupquote{m\_pcName}} member to the top\sphinxhyphen{}level string. Set the \sphinxcode{\sphinxupquote{m\_ppAttributes}} member to reference the array that contains pointers to the \sphinxcode{\sphinxupquote{A3DMiscAttribute}} entities. <Plugins\_A3D\_API.html\#50618396\_71665>`\_\_ in \sphinxhref{Plugins\_A3D\_API.html\#50618396\_41376}{Define miscellaneous attributes that omit modeler data}.)

\item {} 
Package the \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure as an \sphinxcode{\sphinxupquote{A3DRootBase}} entity. (See Step \sphinxtitleref{Invoke the A3DRootBaseSet function to package the ``A3DRootBaseData`} structure as an \sphinxcode{\sphinxupquote{A3DRootBase}} entity associated with a PRC entity. The first argument in this call is a pointer to the entity, and the second is a pointer to the \sphinxcode{\sphinxupquote{A3DRootBaseData}} structure. <Plugins\_A3D\_API.html\#50618396\_44847>`\_\_ in \sphinxhref{Plugins\_A3D\_API.html\#50618396\_41376}{Define miscellaneous attributes that omit modeler data}.)

\end{enumerate}

The following sample code creates base root attributes that describe three sets of modeler data. For information about the relationships between the structures and entities that represent this data, see the diagram provided in \sphinxhref{Plugins\_A3D\_API.html\#50618396\_49152}{Defining root\sphinxhyphen{}level attributes for a PRC entity}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DVoid} \PYG{n}{setAttributes}\PYG{p}{(}\PYG{n}{A3DEntity}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{A3DMiscSingleAttributeData} \PYG{n}{Single}\PYG{p}{;}
  \PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{Single}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}eType} \PYG{o}{=} \PYG{n}{kA3DModellerAttributeTypeString}\PYG{p}{;}
  \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Title}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcData} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Simple Brep building demonstration}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

  \PYG{n}{A3DMiscAttributeData} \PYG{n}{sAttribs}\PYG{p}{;}
  \PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sAttribs}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{sAttribs}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle} \PYG{o}{=} \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle}\PYG{p}{;}
  \PYG{n}{sAttribs}\PYG{o}{.}\PYG{n}{m\PYGZus{}pSingleAttributesData} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{Single}\PYG{p}{;}
  \PYG{n}{sAttribs}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiSize} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
  \PYG{n}{ASInt32} \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscAttributeCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sAttribs}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pAttr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Author}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcData} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Adobe Lyon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{sAttribs}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle} \PYG{o}{=} \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle}\PYG{p}{;}
  \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscAttributeCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sAttribs}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pAttr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Company}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcData} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Adobe Systems Incorporated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{sAttribs}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle} \PYG{o}{=} \PYG{n}{Single}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcTitle}\PYG{p}{;}
  \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DMiscAttributeCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sAttribs}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pAttr}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{A3DRootBaseData} \PYG{n}{sRootData}\PYG{p}{;}
  \PYG{n}{A3D\PYGZus{}INITIALIZE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{sRootData}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{sRootData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pcName} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Trimmed surface}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{sRootData}\PYG{o}{.}\PYG{n}{m\PYGZus{}ppAttributes} \PYG{o}{=} \PYG{n}{pAttr}\PYG{p}{;}
  \PYG{n}{sRootData}\PYG{o}{.}\PYG{n}{m\PYGZus{}uiSize} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
  \PYG{n}{iRet} \PYG{o}{=} \PYG{n}{A3DRootBaseSet}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sRootData}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Creating a 3D annotation that references the PRC file}
\label{\detokenize{Plugins_A3D_API:creating-a-3d-annotation-that-references-the-prc-file}}
Within an existing PDF document, create a 3D annotation. (See \sphinxhref{Plugins\_3D\_samples.html\#50618421\_82159}{Creating annotations}.) Use the file created in \sphinxhref{Plugins\_A3D\_API.html\#50618396\_74492}{Creating a model file entity and exporting it to a physical file} to create the 3D stream dictionary. Set the 3D stream dictionary \sphinxcode{\sphinxupquote{Type}} attribute to \sphinxcode{\sphinxupquote{3D}} and the \sphinxcode{\sphinxupquote{Subtype}} attribute to \sphinxcode{\sphinxupquote{PRC}}, as shown in the following example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CosObj} \PYG{n}{attrObj} \PYG{o}{=} \PYG{n}{CosStreamDict}\PYG{p}{(}\PYG{n}{stm3D}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{attrObj}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{CosNewNameFromString}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3D}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{attrObj}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Subtype}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{CosNewName}\PYG{p}{(}\PYG{n}{cosDoc}\PYG{p}{,} \PYG{n}{false}\PYG{p}{,} \PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PRC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{CosDictPutKeyString}\PYG{p}{(}\PYG{n}{cosAnnot}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3DD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stm3D}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Creating a tessellation entity for representing faceted objects}
\label{\detokenize{Plugins_A3D_API:creating-a-tessellation-entity-for-representing-faceted-objects}}
This section explains how to add tessellation base data to an existing representation item. The Acrobat 3D SDK defines a dedicated type you can use to create faceted entities.


\subsection{Create the tessellation base data}
\label{\detokenize{Plugins_A3D_API:create-the-tessellation-base-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a A3DTessBaseData structure and set its member values to represent the facets. The following explanation assumes facets are defined as triangles, although you could define facets having more than three points.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{m\_uiCoordSize}}. Set this member to the number of coordinates required to represent all facets in the object. This value is calculated as 9 * \sphinxcode{\sphinxupquote{facetSize}}. The 9 multiplier is the number of points in each facet (3) times the number of coordinates in each point (3). The \sphinxcode{\sphinxupquote{facetSize}} variable represents the number of facets in the object.

\item {} 
\sphinxcode{\sphinxupquote{m\_pdCoords}}. Set this member to an array of \sphinxstyleemphasis{N} \sphinxcode{\sphinxupquote{A3DDouble}} entries, where \sphinxstyleemphasis{N} is the value calculated for the \sphinxcode{\sphinxupquote{m\_uiCoordSize}} member.

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Add coordinates for each vertex of each facet to the array referenced by the \sphinxcode{\sphinxupquote{m\_pdCoords}} member. The X, Y, and Z coordinates for each vertex are represented in sequential entries in the array, as shown in this example:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sTessBaseData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pdCoords}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
\PYG{n}{sTessBaseData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pdCoords}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
\PYG{n}{sTessBaseData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pdCoords}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{z}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Create the tessellation facet data}
\label{\detokenize{Plugins_A3D_API:create-the-tessellation-facet-data}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an A3DTess3DData structure and set its members to represent the facet normals:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{m\_uiNormalSize}}. Set this member to the size of the array required to represent the normals for all facets in the objects. This is calculated as 3 * \sphinxcode{\sphinxupquote{facetSize}}. The 3 multiplier is the number of cordinates to represent each vector.

\item {} 
\sphinxcode{\sphinxupquote{m\_pdNormals}}. Set this member to an array of \sphinxstyleemphasis{N} \sphinxcode{\sphinxupquote{A3DDouble}} entries, where \sphinxstyleemphasis{N} is the value calculated for the \sphinxcode{\sphinxupquote{m\_uiNormalSize}} member.

\item {} 
m\_uiTriangulatedIndexSize. Set this member to the number of entries required to represent the indexes associated with each facet in the objects. Each facet can have one to four indexes that reference texture coordinates, one index that references a facet normal, and three indexes that reference vertices. Normals are read from the \sphinxcode{\sphinxupquote{m\_pdNormals}} array, and textures are read from the \sphinxcode{\sphinxupquote{m\_pdTextureCoords}} array.

\item {} 
m\_puiTriangulatedIndexes. Set this member to an array of \sphinxstyleemphasis{N} ASUns32 entries, where \sphinxstyleemphasis{N} is the number of entries in the m\_uiTriangulatedIndexSize member. This array contains the indexes of the points (m\_pdCoords), normals (m\_pdNormals), and texture arrays for each face’s triangulated representation. The entries in this array correspond to the contents in the \sphinxcode{\sphinxupquote{A3DTessFaceData}} entity.

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Add the indexes for each facet, considering the number of entries to represent each facet. Each facet contains the following sequential representations in this array:
\begin{itemize}
\item {} 
(Optional) Index of the first texture in the array referenced by the m\_pdTextureCoords member. This entry can be followed by three more entries for additional texture indexes.

\item {} 
Index of the facet normal in the array referenced by the m\_pdNormals member.

\item {} 
Index of the first facet vertex in the array referenced by the m\_pdCoords member.

\item {} 
Index of the second facet vertex in the array referenced by the m\_pdCoords member.

\item {} 
Index of the third facet vertex in the array referenced by the m\_pdCoords member.

\end{itemize}

\end{enumerate}

In the following example for STL data, \sphinxcode{\sphinxupquote{facetSize}} is set to 0 for the first facet represented by the array and to 1 for the second facet in the array.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sTess3DData}\PYG{o}{.}\PYG{n}{m\PYGZus{}puiTriangulatedIndexes}\PYG{p}{[}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{facetSize}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
\PYG{n}{sTess3DData}\PYG{o}{.}\PYG{n}{m\PYGZus{}puiTriangulatedIndexes}\PYG{p}{[}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{facetSize} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{j}\PYG{p}{;}
\PYG{n}{sTess3DData}\PYG{o}{.}\PYG{n}{m\PYGZus{}puiTriangulatedIndexes}\PYG{p}{[}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{facetSize}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{n}{sTess3DData}\PYG{o}{.}\PYG{n}{m\PYGZus{}puiTriangulatedIndexes}\PYG{p}{[}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{facetSize}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Add the coordinates of each facet normal to the array referenced by the \sphinxcode{\sphinxupquote{m\_pdNormals}} member. The X, Y, and Z coordinates for each vector are represented in sequential entries in the array, as shown in this example:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sTess3DData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pdNormals}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
\PYG{n}{sTess3DData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pdNormals}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{;}
\PYG{n}{sTess3DData}\PYG{o}{.}\PYG{n}{m\PYGZus{}pdNormals}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{z}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
For each face, create an \sphinxcode{\sphinxupquote{A3DTessFaceData}} entity and set its member values as follows:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{m\_usUsedEntitiesFlags}}. Set this member to an enumeration that specifies the entities used in the current face tessellation. For example, the \sphinxcode{\sphinxupquote{kA3DTessFaceDataTriangleOneNormal}} enumeration specifies that the face data is a triangle with a single normal facet.

\item {} 
\sphinxcode{\sphinxupquote{m\_uiSizesTriangulatedSize}}. Set this member to the number of entries in the array referenced by the \sphinxcode{\sphinxupquote{m\_puiSizesTriangulated}} member.

\item {} 
\sphinxcode{\sphinxupquote{m\_puiSizesTriangulated}}. Set this value to the repetition sequence applied to the \sphinxcode{\sphinxupquote{m\_usUsedEntitiesFlags}} member. A single entry with a value of 1 indicates that the first flag in \sphinxcode{\sphinxupquote{m\_usUsedEntitiesFlags}} applies to all face data.

\item {} 
\sphinxcode{\sphinxupquote{m\_uiStartTriangulated}}. Set this value to the starting index for the wire in the array of point indexes of the \sphinxcode{\sphinxupquote{A3DTess3DData}} entity.

\end{itemize}

\item {} 
Set the \sphinxcode{\sphinxupquote{A3DTess3DData}} structure’s \sphinxcode{\sphinxupquote{m\_psFaceTessData}} member to reference an array that in turn references each face that applied to the facets. Set the \sphinxcode{\sphinxupquote{m\_uiFaceTessSize}} member to the number of faces in this array.

\item {} 
Declare a pointer to a null \sphinxcode{\sphinxupquote{A3DTess3D}} entity.

\item {} 
Package the tessellation data by invoking the \sphinxcode{\sphinxupquote{A3DTess3DCreate}} function, providing the location of the \sphinxcode{\sphinxupquote{A3DTess3DData}} structure as the first argument and the location of the \sphinxcode{\sphinxupquote{A3DTess3D}} pointer as the second argument.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTess3D}\PYG{o}{*} \PYG{n}{pTess3D} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{A3DTess3DCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{sTess3DData}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{pTess3D}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
Package the tessellation base data with in the \sphinxcode{\sphinxupquote{A3DTess3D}} entity by invoking the \sphinxcode{\sphinxupquote{A3DTessBaseSet}} function.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A3DTessBaseSet}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pTess3D}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{sTessBaseData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{8}
\item {} 
Add the \sphinxcode{\sphinxupquote{A3DTess3D}} data to a representation item. (See \sphinxhref{Plugins\_A3D\_API.html\#50618396\_60869}{Creating representation item PRC entities}.)

\end{enumerate}

The following code sample creates an A3D tessellation entity from a file that conforms to the STL format. It packages this entity with a poly Brep model representation item. STL is a file format native to the stereolithography CAD software created by 3D Systems.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
// Create structure for facet data
A3DTessBaseData sTessBaseData;
A3D\PYGZus{}INITIALIZE\PYGZus{}DATA(sTessBaseData);
sTessBaseData.m\PYGZus{}uiCoordSize = 9 * facetSize;
sTessBaseData.m\PYGZus{}pdCoords =
  (A3DDouble*)allocCllBck(sTessBaseData.m\PYGZus{}uiCoordSize * sizeof(A3DDouble));

//Create structure for normal vector data
A3DTess3DData sTess3DData;
A3D\PYGZus{}INITIALIZE\PYGZus{}DATA(sTess3DData);
sTess3DData.m\PYGZus{}uiNormalSize = 3 * facetSize;
sTess3DData.m\PYGZus{}pdNormals =
  (A3DDouble*)allocCllBck(sTess3DData.m\PYGZus{}uiNormalSize * sizeof(A3DDouble));


//Total amount of indexes is calculated as follows:
//(one normal + one triangle (3 points)) * Number of facets
sTess3DData.m\PYGZus{}uiTriangulatedIndexSize = 4 * facetSize;
sTess3DData.m\PYGZus{}puiTriangulatedIndexes =
  (ASUns32*)allocCllBck(sTess3DData.m\PYGZus{}uiTriangulatedIndexSize *
      sizeof(ASUns32));


//Set up variables used in reading STL data.
A3DUTF8Char name[100];
A3DUTF8Char dummy[100];
A3DDouble x, y, z;
ASInt32 iRet = 0;
ASUns32 i = 0;
ASUns32 j = 0;
const A3DUTF8Char* pcName = NULL;

rewind(stlFile);
curr = 0;
facetSize = 0;
memset(sBuffer, 0, A3D\PYGZus{}MAX\PYGZus{}BUFFER);
while(fgets(sBuffer, A3D\PYGZus{}MAX\PYGZus{}BUFFER, stlFile) \PYGZgt{} 0) \PYGZob{}
  sscanf(sBuffer, \PYGZdq{}\PYGZpc{}s\PYGZdq{}, key);
  if(!\PYGZus{}stricmp(key, \PYGZdq{}solid\PYGZdq{})) \PYGZob{}
      iRet = sscanf(sBuffer, \PYGZdq{}\PYGZpc{}s \PYGZpc{}s\PYGZdq{}, key, name);
      if (iRet != 2)
          sprintf(name,\PYGZdq{}unnamed\PYGZdq{});
  \PYGZcb{} else if (!\PYGZus{}stricmp(key, \PYGZdq{}facet\PYGZdq{})) \PYGZob{}
      iRet = sscanf(sBuffer,\PYGZdq{}\PYGZpc{}s \PYGZpc{}s \PYGZpc{}lf \PYGZpc{}lf \PYGZpc{}lf\PYGZdq{},key,dummy,\PYGZam{}x,\PYGZam{}y,\PYGZam{}z);
      sTess3DData.m\PYGZus{}puiTriangulatedIndexes[4 * facetSize] = i;
      sTess3DData.m\PYGZus{}puiTriangulatedIndexes[4 * facetSize + 1] = j;
      sTess3DData.m\PYGZus{}puiTriangulatedIndexes[4 * facetSize + 2] = j + 3;
      sTess3DData.m\PYGZus{}puiTriangulatedIndexes[4 * facetSize + 3] = j + 6;
      sTess3DData.m\PYGZus{}pdNormals[i++] = x;
      sTess3DData.m\PYGZus{}pdNormals[i++] = y;
      sTess3DData.m\PYGZus{}pdNormals[i++] = z;
      facetSize++;
  \PYGZcb{} else if (!\PYGZus{}stricmp(key, \PYGZdq{}vertex\PYGZdq{})) \PYGZob{}
      iRet = sscanf(sBuffer, \PYGZdq{}\PYGZpc{}s \PYGZpc{}lf \PYGZpc{}lf \PYGZpc{}lf\PYGZdq{}, key, \PYGZam{}x, \PYGZam{}y, \PYGZam{}z);
      sTessBaseData.m\PYGZus{}pdCoords[j++] = x;
      sTessBaseData.m\PYGZus{}pdCoords[j++] = y;
      sTessBaseData.m\PYGZus{}pdCoords[j++] = z;
  \PYGZcb{}
  curr += strlen(sBuffer);
  prgIncCllBck(curr);
  memset(sBuffer, 0, A3D\PYGZus{}MAX\PYGZus{}BUFFER);
\PYGZcb{}
fclose(stlFile);
prgEndCllBck();


//one can consider that STL consists in one single face made of total amount of triangles
A3DTessFaceData sTessFaceData;
A3D\PYGZus{}INITIALIZE\PYGZus{}DATA(sTessFaceData);
sTessFaceData.m\PYGZus{}usUsedEntitiesFlags = kA3DTessFaceDataTriangleOneNormal;
sTessFaceData.m\PYGZus{}uiSizesTriangulatedSize = 1; /* size of the next array */
sTessFaceData.m\PYGZus{}puiSizesTriangulated = \PYGZam{}facetSize;
sTessFaceData.m\PYGZus{}uiStartTriangulated = 0;


//so, only one face
sTess3DData.m\PYGZus{}uiFaceTessSize = 1;
sTess3DData.m\PYGZus{}psFaceTessData = \PYGZam{}sTessFaceData;
A3DTess3D* pTess3D = NULL;
A3DTess3DCreate(\PYGZam{}sTess3DData, \PYGZam{}pTess3D);
A3DTessBaseSet(pTess3D, \PYGZam{}sTessBaseData);


// Create a PolyBrepModel representation item
A3DRiPolyBrepModel *pRiPolyBrepModel = NULL;
A3DRiPolyBrepModelData sPolyBrepModelData;
A3D\PYGZus{}INITIALIZE\PYGZus{}DATA(sPolyBrepModelData);
sPolyBrepModelData.m\PYGZus{}bIsClosed = TRUE;
A3DRiPolyBrepModelCreate(\PYGZam{}sPolyBrepModelData, \PYGZam{}pRiPolyBrepModel);


// Assign the tessellation to the PolyBrepModel
A3DRiRepresentationItemData sRiData;
A3D\PYGZus{}INITIALIZE\PYGZus{}DATA(sRiData);
sRiData.m\PYGZus{}pTessBase = pTess3D;
A3DRiRepresentationItemSet(pRiPolyBrepModel, \PYGZam{}sRiData);
\end{sphinxVerbatim}


\chapter{Handling Exceptions}
\label{\detokenize{Plugins_Exceptions:handling-exceptions}}\label{\detokenize{Plugins_Exceptions::doc}}
This chapter explains how to handle exceptions that are raised by Acrobat core API methods. Acrobat core API methods generally do not return error codes; instead, they raise exceptions when errors occur. Exceptions are handled by exception handlers. It is recommended that you create your own exception handlers to trap and handle exceptions.


\section{Creating exception handlers}
\label{\detokenize{Plugins_Exceptions:creating-exception-handlers}}
Exception handlers typically perform object cleanup (such as releasing memory) when an exception occurs. Your exception handler can either deal with the exception or pass it along to the next handler on the exception handler stack.

You use the \sphinxcode{\sphinxupquote{DURING}}, \sphinxcode{\sphinxupquote{HANDLER}}, and \sphinxcode{\sphinxupquote{END\_HANDLER}} macros to define exception handlers. Application logic that may raise an exception appears between the \sphinxcode{\sphinxupquote{DURING}} and \sphinxcode{\sphinxupquote{HANDLER}} macros. Application logic that handles exceptions appears between the \sphinxcode{\sphinxupquote{HANDLER}} and \sphinxcode{\sphinxupquote{END\_HANDLER}} macros.

If the method raises an exception, the handler code is executed; otherwise, it is not executed. When an exception occurs, your handler can access the exception error code by using the \sphinxcode{\sphinxupquote{ERRORCODE}} macro. The value returned by the \sphinxcode{\sphinxupquote{ERRORCODE}} macro does not change until another exception is raised. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

The following code example declares an error handler that is active during a call to the \sphinxcode{\sphinxupquote{AVDocOpenFromFile}} method. If an exception occurs, an error message is displayed to the user. For information about opening a PDF document by using the \sphinxcode{\sphinxupquote{AVDocOpenFromFile}} method, see \sphinxhref{Plugins\_Documents.html\#50618416\_65430}{Opening PDF documents}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Creating an exception handler

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DURING}
  \PYG{n}{AVDoc} \PYG{n}{avd} \PYG{o}{=} \PYG{n}{AVDocOpenFromFile}\PYG{p}{(}\PYG{n}{asp}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{p}{(}\PYG{n}{char} \PYG{o}{*}\PYG{p}{)}\PYG{n}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{HANDLER}
  \PYG{n}{AVAlertNote}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error opening file}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{END\PYGZus{}HANDLER}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For code brevity, most of the code examples located in this guide do not include \sphinxcode{\sphinxupquote{DURING}}, \sphinxcode{\sphinxupquote{HANDLER}}, and \sphinxcode{\sphinxupquote{END\_HANDLER}} macros to handle exceptions. You should include these macros in your own custom code.
\end{sphinxadmonition}


\section{Returning a value from an exception handler}
\label{\detokenize{Plugins_Exceptions:returning-a-value-from-an-exception-handler}}
To return a value from a \sphinxcode{\sphinxupquote{DURING}} \sphinxcode{\sphinxupquote{HANDLER}} block, do not use a return statement. Instead, use the \sphinxcode{\sphinxupquote{E\_RETURN(x)}} or \sphinxcode{\sphinxupquote{E\_RTRN\_VOID}} macros. The \sphinxcode{\sphinxupquote{E\_RETURN(x)}} macro returns a value and the \sphinxcode{\sphinxupquote{E\_RTRN\_VOID}} macro does not return a value (this is equivalent to a \sphinxcode{\sphinxupquote{void}} function).

The \sphinxcode{\sphinxupquote{E\_RETURN(x)}} macro must not invoke a function that might raise an exception, because the macro pops an exception frame off the stack before evaluating the expression to return. If this evaluation raises an exception, it does not call your handler, but instead calls the next handler up the stack. For example, consider the following application logic:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{E\PYGZus{}RETURN}\PYG{p}{(}\PYG{n}{myfn}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This is not recommended if there is any possibility that \sphinxcode{\sphinxupquote{myfn}} could raise an exception. If you need to invoke a function, it is best to do it this way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result} \PYG{o}{=} \PYG{n}{myfn}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

 \PYG{n}{E\PYGZus{}RETURN}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, if \sphinxcode{\sphinxupquote{myfn}} raises an exception, your handler will be executed.


\section{Raising exceptions}
\label{\detokenize{Plugins_Exceptions:raising-exceptions}}
Although many Acrobat core API methods raise exceptions, some methods do return error codes or \sphinxcode{\sphinxupquote{NULL}} if something goes wrong. Inside a \sphinxcode{\sphinxupquote{DURING HANDLER}} block, if your plugin detects one of these cases, it can invoke the \sphinxcode{\sphinxupquote{ASRaise}} method, which generates an exception. This has the effect of causing the \sphinxcode{\sphinxupquote{HANDLER END\_HANDLER}} code to execute, just as if the original method raised an exception.

You can also use the \sphinxcode{\sphinxupquote{RERAISE}} macro when you do not want your exception handler to handle an exception, but want to pass the exception to the next exception handler on the stack.

\begin{sphinxadmonition}{note}{Note:}
Your plugin should use the \sphinxcode{\sphinxupquote{ASRegisterErrorString}} method to define its own exceptions.
\end{sphinxadmonition}


\section{Exception handling scenarios}
\label{\detokenize{Plugins_Exceptions:exception-handling-scenarios}}
This section discusses the following potential problems with exception handling:
\begin{itemize}
\item {} 
Goto statements

\item {} 
Nested exception handlers in a single function

\item {} 
Register usage

\end{itemize}


\subsection{Using goto statements}
\label{\detokenize{Plugins_Exceptions:using-goto-statements}}
It is recommended that you not use a \sphinxcode{\sphinxupquote{goto}} within a \sphinxcode{\sphinxupquote{DURING HANDLER}} block. Jumping outside a \sphinxcode{\sphinxupquote{DURING HANDLER}} block disrupts the stack frame, as shown in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DURING}
     \PYG{n}{goto} \PYG{n}{error}\PYG{p}{;}
 \PYG{n}{HANDLER}
 \PYG{n}{END\PYGZus{}HANDLER}
 \PYG{n}{error}\PYG{p}{:}
\end{sphinxVerbatim}

This action leads to unpredictable results because the top stack frame has not been removed. As a result, the frame is incorrect. Instead, use the \sphinxcode{\sphinxupquote{ASRaise}} method and then use the \sphinxcode{\sphinxupquote{goto}} statement within the \sphinxcode{\sphinxupquote{HANDLER END\_HANDLE}} block, as shown in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DURING}  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
     \PYG{n}{ASRaise}\PYG{p}{(}\PYG{n}{myspecialerrorcode}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{HANDLER}
 \PYG{k}{if} \PYG{n}{ERRORCODE} \PYG{o}{==} \PYG{n}{myspecialerrorcode}
     \PYG{n}{goto} \PYG{n}{error}\PYG{p}{;}
 \PYG{n}{END\PYGZus{}HANDLER}
 \PYG{n}{error}\PYG{p}{:}
\end{sphinxVerbatim}

For information about the \sphinxcode{\sphinxupquote{goto}} statement, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\subsection{Using nested exception handlers}
\label{\detokenize{Plugins_Exceptions:using-nested-exception-handlers}}
Avoid using nested exception handlers within a single function. The exception handling macros change the call stack, and nesting them can disrupt the stack. Your plugin can safely nest an exception handler if the nested handler is in another function called inside the \sphinxcode{\sphinxupquote{DURING HANDLER}} block, as shown in the following example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DURING}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
     \PYG{n}{MyFunction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{n}{HANDLER}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{n}{END\PYGZus{}HANDLER}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
     \PYG{n}{void} \PYG{n}{MyFunction}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{n}{DURING}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{n}{HANDLER}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{n}{END\PYGZus{}HANDLER}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If you insist on nesting exception handlers in a single function, do not return from the inner exception handler (either through a call to return in a handler or \sphinxcode{\sphinxupquote{E\_RETURN}} from body code). This action leaves the exception stack out of sync with the call stack. Any errors raised in body code surrounded by the outer exception handler will restore the incorrect calling environment and lead to unpredictable results, as shown in the following example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}
 DURING /* Places one frame on the exception stack */
 pdoc = AVDocGetPDDoc(avdoc);
     DURING /* Places a second frame on the stack */
         rootBm = PDDocGetBookmarkRot(pdDoc);
         if (!PDBookmarkIsValid(rootBm))\PYGZob{}
         E\PYGZus{}RTRN\PYGZus{}VOID
         /*
         Returning here interferes with the exception stack
         because two frames have been placed on the stack
         and E\PYGZus{}RTRN\PYGZus{}VOID only clears one of them before
         returning
         */
 \PYGZcb{}
 pdAction = PDBookMarkGetAction(parentBm);
 HANDLER
         AVAlertNote(\PYGZdq{}Bad AVDoc\PYGZdq{});
         return (1);
         /*
         Returning here interferes with the exception stack
         because there is still a frame on the stack from
         the outer DURING macro and it will not be cleared
         before the function returns
         */
 END\PYGZus{}HANDLER
 HANDLER
     AVAlertNote(\PYGZdq{}Bad PDDoc\PYGZdq{});
 END\PYGZus{}HANDLER
 \PYGZcb{}
\end{sphinxVerbatim}


\subsection{Using register variables}
\label{\detokenize{Plugins_Exceptions:using-register-variables}}
The \sphinxcode{\sphinxupquote{DURING}} and \sphinxcode{\sphinxupquote{HANDLER}} macros use the standard C \sphinxcode{\sphinxupquote{setjmp/longjmp}} mechanism. The \sphinxcode{\sphinxupquote{DURING}} macro calls \sphinxcode{\sphinxupquote{setjmp}}. An exception results in a \sphinxcode{\sphinxupquote{longjmp}} to the context that was saved by the most recent \sphinxcode{\sphinxupquote{setjmp}}. When a \sphinxcode{\sphinxupquote{longjmp}} occurs, all registers, including those containing variables the compiler optimized into register variables, are restored to the values they held when the \sphinxcode{\sphinxupquote{setjmp}} occurred.

As a result, the state of local variables that have been optimized into registers is unpredictable when the exception handler is invoked. To avoid this situation, declare all variables that are set in the main body of the code and used in the exception handler or beyond (if the handler lets execution continue) as volatile. This ensures that they are never optimized into register variables, but are always referenced from memory.

When using the \sphinxcode{\sphinxupquote{volatile}} statement, place the keyword in the correct location, such as the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{volatile} \PYG{n}{myStruct}\PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The previous statement declares the instance of the structure to be volatile. The next statement declares the pointer itself to be volatile:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{myStruct}\PYG{o}{*} \PYG{n}{volatile} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

In general, the second version is the one to use.


\chapter{Working with Acrobat Extended APIs}
\label{\detokenize{Plugins_ExtendedAPI:working-with-acrobat-extended-apis}}\label{\detokenize{Plugins_ExtendedAPI::doc}}
Some of Acrobat’s default plugins expose their APIs for use by third parties. These are Acrobat’s extended APIs. These APIs are specified in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{Search extended API}
\label{\detokenize{Plugins_ExtendedAPI:search-extended-api}}
The Adobe Acrobat Search plugin allows users to perform text searches in PDF documents. It adds menus, menu items, a toolbar button, and a Search panel to the Acrobat viewer.

The Search plugin exports a host function table (HFT) that contains methods that can be used by other plugins. The HFT’s name is Search, and its version number is 0. To use the Search plugin’s HFT, a plugin must include the header file SrchClls.h. The plugin must also import the HFT using the \sphinxcode{\sphinxupquote{ASExtensionMgrGetHFT}} method and assign the HFT returned by this call to a plugin\sphinxhyphen{}defined global variable named \sphinxcode{\sphinxupquote{gSearchHFT}}. (See \sphinxhref{Plugins\_Hft.html\#50618412\_37928}{Working with Host Function Tables}.)

Acrobat 6.0 and later has two versions of the Search plugin:
\begin{itemize}
\item {} 
The Search plugin uses a search engine licensed from Lextek International. Lextek can be contacted at \sphinxhref{http://www.lextek.com.}{http:   //www.lextek.com}.

\item {} 
The Search5 plugin uses a search engine licensed from Verity, Inc. Verity can be contacted at \sphinxhref{www.verity.com}{http:   //www.verity.com}.

\end{itemize}

You can perform the following tasks with either version of the Search plugin:
\begin{itemize}
\item {} 
Create or delete indexes

\item {} 
Determine what indexes are available

\item {} 
Send queries to an existing index

\end{itemize}

You cannot use either version of the Search plugin to directly obtain the results of a search, for manipulation or for display in an application other than Adobe Acrobat. For information about the methods included in the Search extended API, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{Catalog extended API}
\label{\detokenize{Plugins_ExtendedAPI:catalog-extended-api}}
Acrobat Catalog is a plugin that allows you to create a full\sphinxhyphen{}text index of a set of PDF documents. A full\sphinxhyphen{}text index is a searchable database of all the text in the documents. After building an index, you can use the Search command to search the entire library quickly. Searches of full\sphinxhyphen{}text indexes created using Catalog are faster and more convenient than using the Find command.

The Catalog plugin has an HFT consisting of several methods that plugin developers can import and use. In addition, Catalog supports DDE, and broadcasts several Windows messages. For information about the methods included in the Catalog extended API, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{PDF Consultant and Accessibility Checker extended API}
\label{\detokenize{Plugins_ExtendedAPI:pdf-consultant-and-accessibility-checker-extended-api}}
Acrobat comes with a plugin called the PDF Consultant and Accessibility Checker. This plugin walks through PDF documents, visiting each object and determining its type and other statistics. It can make certain modifications or repairs to the PDF document. The objects that the consultant visits can range from simple, primitive types such as Cos strings to higher\sphinxhyphen{}level objects such as images. Users invoke the consultant to operate on a particular PDF document, choose which tests or repairs to run, then view the results and select repair options.

The consultant visits the objects in a PDF document according to instructional flags you pass to it. After the consultant visits an object, the object may be different. The consultant reclassifies modified objects before moving on to the next object.

As the consultant traverses a PDF document, gathering objects of interest, it can perform the following tasks:
\begin{itemize}
\item {} 
Walk a given hierarchy

\item {} 
Keep track of cycles

\item {} 
Ensure that objects are only visited once, if desired

\item {} 
Recognize object types

\item {} 
Keep a traversal stack list

\end{itemize}


\subsection{Acrobat agents}
\label{\detokenize{Plugins_ExtendedAPI:acrobat-agents}}
The consultant accomplishes its task by using agents, which are pieces of code you design to gather the statistics and recommend to the consultant the necessary repairs of the document. Separate agents handle each area of analysis and repair. The agents inform the consultant of the particular types of objects in which they are interested by registering with the consultant. When the consultant has one or more agents registered, it hands each object of the requested type(s) in the current document to each of the agents that requested that type. The consultant gives objects to each agent in turn, depending on the order in which they registered.

The consultant must intelligently determine the type of each object it comes across (both direct and indirect), so it can pass appropriate objects to the agents, or replace or remove ones that it has been instructed to handle itself. The consultant communicates directly with agents, keeping lists of which agents are interested in which objects, and obtaining instructions from the agent as to an object’s visitation status.

Agents can perform their own repairs and modifications to the PDF document, and can return a corrected object to serve as a replacement for the object the consultant originally passed to it. Agents can also modify the Cos graph themselves (including adding or removing Cos objects or modifying the contents such as keys or array elements).

The consultant keeps a list of each object (starting with the object which began the traversal) that it visits on its way to any given object. Agents must be careful not to make any modifications that would affect any of the objects in the list, which is referred to as the traversal stack. For this reason, agents can specify a post\sphinxhyphen{}processing callback that the consultant invokes once it has finished traversing the entire document.


\subsection{Reclassifying and revisiting}
\label{\detokenize{Plugins_ExtendedAPI:reclassifying-and-revisiting}}
If an agent or the consultant modifies an object, the consultant reclassifies that object, possibly changing its type.

Agents also pass visitation flags to the consultant that determine how object types should be visited. Limiting the traversal is important, as PDF documents are graphs, arbitrarily complex, and often there are many ways to visit a single object. If the consultant reclassifies an object, it may also change the way that object is revisited. You must keep this in mind as you develop your agents.


\subsection{Agent architecture}
\label{\detokenize{Plugins_ExtendedAPI:agent-architecture}}
Your agent code will primarily consist of a structure, as defined in the ConsExpt.h header file. Acrobat provides a C++ wrapper class to facilitate writing agents; you can derive an agent class from this base class.


\subsection{How the consultant works}
\label{\detokenize{Plugins_ExtendedAPI:how-the-consultant-works}}
The consultant completes a full, non\sphinxhyphen{}recursive traversal of the Cos graph that comprises a PDF document, keeping track of cycles as it goes. Note that there is no guarantee that objects will be visited in any particular order, only that the consultant will visit all objects (except isolated objects such as the \sphinxcode{\sphinxupquote{DocInfo}} object or previously orphaned objects) at least once, provided no agents modify the graph such that graph paths are removed or redirected.


\subsubsection{Removing or modifying objects}
\label{\detokenize{Plugins_ExtendedAPI:removing-or-modifying-objects}}
If an agent removes, replaces, or modifies an object, the consultant passes the modified objects (if they are encountered) to other agents. For example, \sphinxcode{\sphinxupquote{DictA}} refers to \sphinxcode{\sphinxupquote{DictB}}.The first agent replaces all references to \sphinxcode{\sphinxupquote{DictB}} with references to \sphinxcode{\sphinxupquote{DictC}}, so when later agents receive \sphinxcode{\sphinxupquote{DicA}} from the consultant, they will see the references to \sphinxcode{\sphinxupquote{DictC}}.


\subsubsection{Reclassifying objects}
\label{\detokenize{Plugins_ExtendedAPI:reclassifying-objects}}
In general, the consultant reclassifies an object after an agent is finished performing operations on it. It is possible that, in the process of modifying the object, the agent may actually change the type of the object. This could mean that agents originally interested in the object may not be interested in it. So the consultant must reclassify an object after each agent has finished with it. Because the default behavior in the revisit upon reclassification mode is to revisit objects when they are reclassified, new objects added in this mode will actually be visited again if they are reclassified as the traversal continues.

Determining the higher\sphinxhyphen{}level type (the \sphinxcode{\sphinxupquote{PDFObjType}}, as the consultant code calls it) of a given Cos object is not always easy. The consultant not only looks at the construction of objects (what keys are present in the object) but also at how the object was reached (through what particular object type and via what keys). Objects that are interpreted differently depending on how they are traversed can be properly identified.


\subsubsection{Consultant process}
\label{\detokenize{Plugins_ExtendedAPI:consultant-process}}
The following steps describe the consultant process:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
You create a consultant.

\item {} 
You create an agent.

\item {} 
Register your agent with the consultant, with information as to which object types are of interest.

\item {} 
The user invokes the consultant to work on a particular PDF document.

\item {} 
The consultant creates a traversal stack to keep track of where it is in walking through the PDF document.

\item {} 
The consultant begins traversing the PDF document. If agents have instructed the consultant to modify or remove the object, it does so, returning the appropriate replacement.

\item {} 
The consultant pushes the object onto the traversal stack and sends a message to the agent that the object was found.

\item {} 
The agent sends messages to the consultant about what to do to objects: replace them, remove them, revisit them later or not.

\item {} 
When the entire PDF document has been traversed, the consultant calls the agent back to perform any post\sphinxhyphen{}processing repairs it may want to do.

\item {} 
The consultant unregisters all agents.

\item {} 
You release the agent object.

\item {} 
You release the consultant object.

\end{enumerate}


\subsection{Important issues for consultant development}
\label{\detokenize{Plugins_ExtendedAPI:important-issues-for-consultant-development}}
First, you must decide if you actually do want to use a consultant. A consultant walks through an entire PDF document. If you only need to modify a small number of objects, and you know how to locate those objects, it makes more sense to write the object\sphinxhyphen{}finding code yourself.

If you decide to use the consultant, here are some planning considerations:
\begin{itemize}
\item {} 
Avoid implementing an agent that modifies objects on the traversal stack while the consultant is still walking through the document, otherwise infinite loops and other problems can occur (see \sphinxhref{Plugins\_ExtendedAPI.html\#50618414\_93514}{Maintaining the traversal stack}).

\item {} 
Decide whether the consultant or the agent does the work (see \sphinxhref{Plugins\_ExtendedAPI.html\#50618414\_78898}{Deciding consultant or the agent does the work}).

\item {} 
Determine order in which agents interact with the consultant. This order is important because agents can modify objects that other agents want to view (see \sphinxhref{Plugins\_ExtendedAPI.html\#50618414\_53252}{Avoiding agent collisions}).

\item {} 
Decide whether to allow the consultant to revisit objects that have multiple classifications and what conditions must exist to allow such repeat visits (see \sphinxhref{Plugins\_ExtendedAPI.html\#50618414\_42237}{Avoiding visitation collisions}).

\end{itemize}

You should make your decisions about all of these issues before you write your code. Some of these issues lead to errors that are difficult to debug, so it is best to understand them all while creating your plugin.


\subsubsection{Maintaining the traversal stack}
\label{\detokenize{Plugins_ExtendedAPI:maintaining-the-traversal-stack}}
The consultant keeps track of the objects it has visited in the PDF document in the traversal stack. If an agent modifies an object such that it affected the traversal stack, the entire process is derailed. The consultant may no longer know if it had visited an object, which could cause infinite loops, multiple, unnecessary visitations, or objects that remain unvisited.

It is extremely important that the integrity of the traversal stack remain undamaged. You must design your agent carefully so as to avoid this problem. You can use the postprocessing step of your agent to handle many repair tasks, thereby avoiding dealing with objects still on the traversal stack.


\subsubsection{Deciding consultant or the agent does the work}
\label{\detokenize{Plugins_ExtendedAPI:deciding-consultant-or-the-agent-does-the-work}}
If the consultant performs object modifications, it does so as it goes through its traversal. Modifications that affect an object’s type or properties alter the traversal stack and corrupt the traversal process. For these kinds of modifications, set up an agent to perform the tasks in the postprocessing step.

For example, suppose an agent wants to remove annotations while there are form widgets present in the document. There are a few ways the agent can remove the annotations while the consultant is working, but they all have problems:
\begin{itemize}
\item {} 
Invoking the agent for all annotations and removing them at the Cos level does not clean up the forms tree if there are Widget Annots in the document.

\item {} 
Invoking the agent for all annotations and using the \sphinxcode{\sphinxupquote{PDPageAnnotRemove}} method modifies the page object, which may still be in the traversal stack.

\end{itemize}

The best solution in this case is to enumerate all of the \sphinxcode{\sphinxupquote{Annot}} objects by having the consultant look for \sphinxcode{\sphinxupquote{Annot}} objects and keep a list of them, then let the agent invoke \sphinxcode{\sphinxupquote{PDPageAnnotRemove}} on them in the post\sphinxhyphen{}processing step.


\subsubsection{Avoiding agent collisions}
\label{\detokenize{Plugins_ExtendedAPI:avoiding-agent-collisions}}
When running multiple agents on a document, the order in which you register your agents is the order in which the consultant will hand them objects. If your earlier agents modify objects, they may change the objects in such a way that they are missing important information or are of a different type than they were originally. For example, one agent may consider it correct to remove a given field of an object, while another would complain that the field was not present and would want to add it. If the first agent modified the object type, subsequent agents would no longer think they were interested in it, and their processing would not take place. You must group your agents so that you do not run multiple agents with conflicting goals at the same time.

A rarer problem could occur with self\sphinxhyphen{}referential objects. For example, if \sphinxcode{\sphinxupquote{DictA}} contains a reference to itself and the first agent replaces \sphinxcode{\sphinxupquote{DictA}} with \sphinxcode{\sphinxupquote{DictB}} (which would still contain a reference to \sphinxcode{\sphinxupquote{DictA}} ), another agent cannot work with \sphinxcode{\sphinxupquote{DictB}} until the internal reference is changed. But if you are running the agents concurrently, there will be a collision. This would be a case best handled by the consultant.


\subsubsection{Avoiding visitation collisions}
\label{\detokenize{Plugins_ExtendedAPI:avoiding-visitation-collisions}}
Objects that have multiple classifications can be reached from multiple paths. In such cases you may allow the consultant to revisit such objects if, and only if, they were reclassified on a new path. However, you must take care not to allow revisitation under other circumstances, or the consultant could miss objects, which would defeat the reason for using a mode that considers object classification.


\subsection{Importing the consultant HFTs into a plugin}
\label{\detokenize{Plugins_ExtendedAPI:importing-the-consultant-hfts-into-a-plugin}}
The consultant exports its functions using an HFT. The variable name your plugin uses for the HFT must be of type HFT and named \sphinxcode{\sphinxupquote{gConsultantHFT}}. The consultant’s HFT allows you to create consultants. The consultant exports an HFT that deals with the general operation of the consultant, including the creation and deletion of consultant objects and agent registration. You must load the consultant plugin before the HFTs plugins can import it. Importing the consultant’s HFT is the same as importing any other plugin’s HFT. (See \sphinxhref{Plugins\_Hft.html\#50618412\_72145}{Importing an existing HFT}.)

To access the HFT, you must include the ConsHFT.h file into your project. In a plugin, the \sphinxcode{\sphinxupquote{PluginImportReplaceAndRegister}} method should contain the code that imports the HFT.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HFT} \PYG{n}{gConsultantHFT}\PYG{o}{=} \PYG{p}{(}\PYG{n}{HFT}\PYG{p}{)}\PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{ACCB1} \PYG{n}{ASBool} \PYG{n}{ACCB2} \PYG{n}{PluginImportReplaceAndRegister}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{ASBool} \PYG{n}{bRetVal} \PYG{o}{=} \PYG{n}{false}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Import} \PYG{n}{the} \PYG{n}{Consultant}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s main HFT}
 \PYG{n}{gConsultantHFT} \PYG{o}{=} \PYG{n}{Init\PYGZus{}PDFConsultantHFT}\PYG{p}{;}    \PYG{o}{/}\PYG{o}{/} \PYG{n}{Macro} \PYG{o+ow}{in} \PYG{n}{ConsHFT}\PYG{o}{.}\PYG{n}{h}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{gConsultantHFT} \PYG{o}{!=} \PYG{p}{(}\PYG{n}{HFT}\PYG{p}{)}\PYG{n}{NULL}\PYG{p}{)}
      \PYG{n}{bRetVal} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
  \PYG{k}{else}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Put} \PYG{o+ow}{in} \PYG{n}{error} \PYG{n}{message} \PYG{n}{about} \PYG{n}{the} \PYG{n}{absence} \PYG{n}{of} \PYG{n}{the} \PYG{n}{Consultant} \PYG{n}{HFT}
 \PYG{k}{return} \PYG{n}{bRetVal}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The consultant defines the following methods for HFT usage:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ConsultantCreate}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantDestroy}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantTraverseFrom}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantRegisterAgent}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantSetStart}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantNextObj}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantGetPercentDone}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantGetNumDirectVisited}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantGetNumIndirectVisited}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantSuspend}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantResume}}

\item {} 
\sphinxcode{\sphinxupquote{ConsStackGetCount}}

\item {} 
\sphinxcode{\sphinxupquote{ConsStackIndexGetObj}}

\item {} 
\sphinxcode{\sphinxupquote{ConsStackIndexGetTypeCount}}

\item {} 
\sphinxcode{\sphinxupquote{ConsStackIndexGetTypeAt}}

\item {} 
\sphinxcode{\sphinxupquote{ConsStackIndexIsDict}}

\item {} 
\sphinxcode{\sphinxupquote{ConsStackIndexIsArray}}

\item {} 
\sphinxcode{\sphinxupquote{ConsStackIndexGetDictKey}}

\item {} 
\sphinxcode{\sphinxupquote{ConsStackIndexGetArrayIndex}}

\item {} 
\sphinxcode{\sphinxupquote{PDFObjTypeGetSuperclass}}

\item {} 
\sphinxcode{\sphinxupquote{ConsultantGetNumUniqueIndirectsVisited}}

\end{itemize}


\subsection{Creating and destroying consultants}
\label{\detokenize{Plugins_ExtendedAPI:creating-and-destroying-consultants}}
The consultant’s HFT allows you to create a consultant for your own use. Once you have finished writing your agent class, you are ready to register it with the consultant and begin processing documents. You should keep your agent separate from the consultant object—that is, do not make the consultant object a member of your agent class. Use a plugin as the owner for both the consultant and your agent object.

Because there is some memory overhead in creating a consultant, you should only create a \sphinxcode{\sphinxupquote{Consultant}} object when it is required, not before. If your target application is a plugin, the most logical place to perform all operations is in the menu item execute procedure. Whether or not it makes sense to destroy the \sphinxcode{\sphinxupquote{Consultant}} object after each execution of the menu item depends on your project.

The consultant HFT provides the functions \sphinxcode{\sphinxupquote{ConsultantCreate}} and \sphinxcode{\sphinxupquote{ConsultantDestroy}}, for creating and destroying \sphinxcode{\sphinxupquote{Consultant}} objects. It also provides the Consultant data type, an opaque type for passing handles to \sphinxcode{\sphinxupquote{Consultant}} objects. The \sphinxcode{\sphinxupquote{ConsultantCreate}} method returns variables of that type and requires them as parameters to all other HFT functions having the \sphinxcode{\sphinxupquote{Consultant}} prefix.

After each run the consultant unregisters all the agents that were registered with it; however the memory for the \sphinxcode{\sphinxupquote{Consultant}} object itself remains, and the object must be explicitly destroyed to free the memory. Depending on the duties you assign your consultant, you may want to destroy it after each execution of the menu item that launches it, or you may wish to keep it running.


\subsection{Registering agents with consultants}
\label{\detokenize{Plugins_ExtendedAPI:registering-agents-with-consultants}}
In order to modify or analyze documents, you must register your agent with the consultant by invoking the \sphinxcode{\sphinxupquote{ConsultantRegisterAgent}} method.

Once the agent is registered with the consultant, it remains registered until a call to \sphinxcode{\sphinxupquote{ConsultantTraverseFrom}} is made. You must re\sphinxhyphen{}register agents before each successive call to \sphinxcode{\sphinxupquote{ConsultantTraverseFrom}}.

When you register an agent, you supply a rule (one of the \sphinxcode{\sphinxupquote{RegAgentFlag}} values) for revisitation of objects as the consultant runs through the document from the starting object. The following code example registers an agent with a consultant.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{o}{/}\PYG{o}{/} \PYG{n}{Declare} \PYG{n}{volatile} \PYG{n}{consultant} \PYG{n}{because} \PYG{n}{it} \PYG{o+ow}{is} \PYG{n}{inside} \PYG{n}{a} \PYG{n}{DURING} \PYG{n}{bloc}
 \PYG{o}{/}\PYG{o}{/}   \PYG{n}{Consultant} \PYG{n}{volatile} \PYG{n}{hConsultant} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Consultant}\PYG{p}{)}\PYG{n}{NULL}\PYG{p}{;}

 \PYG{n}{DURING}
   \PYG{n}{AVDoc} \PYG{n}{hAVDoc} \PYG{o}{=} \PYG{n}{AVAppGetActiveDoc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{miAssert}\PYG{p}{(}\PYG{n}{hAVDoc} \PYG{o}{!=} \PYG{p}{(} \PYG{n}{AVDoc} \PYG{p}{)}\PYG{n}{NULL} \PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if}\PYG{p}{(} \PYG{n}{hAVDoc} \PYG{o}{!=} \PYG{p}{(} \PYG{n}{AVDoc} \PYG{p}{)}\PYG{n}{NULL} \PYG{p}{)}
       \PYG{p}{\PYGZob{}}

 \PYG{o}{/}\PYG{o}{/} \PYG{n}{Create} \PYG{n}{a} \PYG{n}{Consultant} \PYG{n+nb}{object}
 \PYG{o}{/}\PYG{o}{/}        \PYG{n}{hConsultant} \PYG{o}{=} \PYG{n}{ConsultantCreate}\PYG{p}{(}
       \PYG{n}{DumpAllObjectsAgentPercentDone} \PYG{p}{)}\PYG{p}{;}
       \PYG{n}{miAssert}\PYG{p}{(} \PYG{n}{hConsultant} \PYG{o}{!=} \PYG{p}{(} \PYG{n}{Consultant} \PYG{p}{)}\PYG{n}{NULL} \PYG{p}{)}\PYG{p}{;}

       \PYG{k}{if}\PYG{p}{(} \PYG{n}{hConsultant} \PYG{o}{!=} \PYG{p}{(} \PYG{n}{Consultant} \PYG{p}{)}\PYG{n}{NULL} \PYG{p}{)}
       \PYG{p}{\PYGZob{}}

 \PYG{o}{/}\PYG{o}{/} \PYG{n}{Get} \PYG{n}{the} \PYG{n}{current} \PYG{n}{document} \PYG{n}{root}
 \PYG{o}{/}\PYG{o}{/}            \PYG{n}{PDDoc} \PYG{n}{hPDDoc} \PYG{o}{=} \PYG{n}{AVDocGetPDDoc}\PYG{p}{(}\PYG{n}{hAVDoc}\PYG{p}{)}\PYG{p}{;}


 \PYG{o}{/}\PYG{o}{/} \PYG{n}{Create} \PYG{n}{an} \PYG{n}{agent} \PYG{o+ow}{and} \PYG{n}{register} \PYG{n}{it}
 \PYG{o}{/}\PYG{o}{/}            \PYG{n}{gDumpAllObjectsAgent} \PYG{o}{=} \PYG{n}{new} \PYG{n}{DumpAllObjectsAgent}\PYG{p}{(}\PYG{n}{hPDDoc}\PYG{p}{)}\PYG{p}{;}

           \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{gDumpAllObjectsAgent} \PYG{o}{==} \PYG{p}{(}\PYG{n}{DumpAllObjectsAgent}\PYG{o}{*}\PYG{p}{)}\PYG{n}{NULL}\PYG{p}{)}
           \PYG{o}{|}\PYG{o}{|} \PYG{p}{(}\PYG{n}{gDumpAllObjectsAgent}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{IsValid}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{false}\PYG{p}{)}\PYG{p}{)}
           \PYG{p}{\PYGZob{}}
           \PYG{n}{ASRaise}\PYG{p}{(}\PYG{n}{GenError}\PYG{p}{(}\PYG{n}{genErrNoMemory}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
           \PYG{p}{\PYGZcb{}}
           \PYG{k}{else}
           \PYG{p}{\PYGZob{}}
           \PYG{n}{ConsultantRegisterAgent}\PYG{p}{(}\PYG{n}{hConsultant}\PYG{p}{,}\PYG{o}{*}\PYG{n}{gDumpAllObjectsAgent}\PYG{p}{,}
           \PYG{n}{REG\PYGZus{}REVISITRECLASS\PYGZus{}ALL} \PYG{p}{)}\PYG{p}{;}


 \PYG{o}{/}\PYG{o}{/} \PYG{n}{Start} \PYG{n}{the} \PYG{n}{consultant}
 \PYG{o}{/}\PYG{o}{/}            \PYG{n}{ConsultantTraverseFrom}\PYG{p}{(}\PYG{n}{hConsultant}\PYG{p}{,}
           \PYG{n}{CosDocGetRoot}\PYG{p}{(}\PYG{n}{PDDocGetCosDoc}\PYG{p}{(}\PYG{n}{hPDDoc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{PT\PYGZus{}CATALOG}\PYG{p}{)}\PYG{p}{;}
           \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
 \PYG{p}{\PYGZcb{}}
 \PYG{n}{HANDLER}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Destroy} \PYG{n}{Consultant}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{n}{Free} \PYG{n}{Memory}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
 \PYG{n}{END\PYGZus{}HANDLER}
\end{sphinxVerbatim}


\subsection{Starting the consultant}
\label{\detokenize{Plugins_ExtendedAPI:starting-the-consultant}}
The \sphinxcode{\sphinxupquote{ConsultantTraverseFrom}} method instructs the consultant to begin traversing a document, starting at a specific Cos object. The Cos object should be the catalog of a currently open document. The \sphinxcode{\sphinxupquote{ConsultantTraverseFrom}} method has no return value and instead raises an exception if an error occurs. The following code example demonstrates how to use the traversal stack manipulation functions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{char}\PYG{o}{*} \PYG{n}{GetTraversalString}\PYG{p}{(}\PYG{n}{ConsStack} \PYG{n}{stack}\PYG{p}{,} \PYG{n}{char} \PYG{o}{*}\PYG{n}{traversalString}\PYG{p}{,}
\PYG{n}{ASUns32} \PYG{n}{strLen}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{n}{ASUns32} \PYG{n}{Index}\PYG{p}{,} \PYG{n}{NumItems}\PYG{p}{,} \PYG{n}{CurStrLen}\PYG{p}{;}
\PYG{n}{char} \PYG{n}{StringUns32}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{]}\PYG{p}{;} \PYG{n}{traversalString}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{CurStrLen} \PYG{o}{=} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{traversalString}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/} \PYG{n}{Get} \PYG{n}{the} \PYG{n}{number} \PYG{n}{of} \PYG{n}{items} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{current} \PYG{n}{traversal}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{NumItems} \PYG{o}{=} \PYG{n}{ConsStackGetCount}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for}\PYG{p}{(}\PYG{n}{Index} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{(}\PYG{n}{Index} \PYG{o}{\PYGZlt{}} \PYG{n}{NumItems}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{CurStrLen} \PYG{o}{\PYGZlt{}} \PYG{n}{strLen}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Index}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{CurStrLen} \PYG{o}{+}\PYG{o}{=} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{TRAVERSAL\PYGZus{}SEP}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{strLen}\PYG{p}{)}
      \PYG{n}{strcat}\PYG{p}{(}\PYG{n}{traversalString}\PYG{p}{,} \PYG{n}{TRAVERSAL\PYGZus{}SEP}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/} \PYG{n}{Add} \PYG{n}{the} \PYG{n}{parent} \PYG{n}{key}\PYG{p}{,} \PYG{k}{if} \PYG{n}{this} \PYG{n}{stack} \PYG{n}{entry} \PYG{n}{has} \PYG{n}{one} \PYG{o}{*}\PYG{o}{/}
\PYG{o}{/}\PYG{o}{/}    \PYG{k}{if}\PYG{p}{(}\PYG{n}{ConsStackIndexIsDict}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{,} \PYG{n}{Index}\PYG{p}{)}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
      \PYG{n}{char}\PYG{o}{*} \PYG{n}{strParentKey} \PYG{o}{=}   \PYG{n}{ASAtomGetString}\PYG{p}{(}\PYG{n}{ConsStackIndexGetDictKey}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{,}
      \PYG{n}{Index}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{CurStrLen} \PYG{o}{+}\PYG{o}{=} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{strParentKey}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{strLen}\PYG{p}{)}
          \PYG{n}{strcat}\PYG{p}{(}\PYG{n}{traversalString}\PYG{p}{,} \PYG{n}{strParentKey}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Add} \PYG{n}{the} \PYG{n}{parent} \PYG{n}{index}\PYG{p}{,} \PYG{k}{if} \PYG{n}{this} \PYG{n}{stack} \PYG{n}{entry} \PYG{n}{has} \PYG{n}{one}
\PYG{o}{/}\PYG{o}{/}   \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{ConsStackIndexIsArray}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{,} \PYG{n}{Index}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{StringUns32}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}u}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{ConsStackIndexGetArrayIndex}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{,} \PYG{n}{Index}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{CurStrLen} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{StringUns32}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{strLen}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
      \PYG{n}{strcat}\PYG{p}{(}\PYG{n}{traversalString}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{strcat}\PYG{p}{(}\PYG{n}{traversalString}\PYG{p}{,} \PYG{n}{StringUns32}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{strcat}\PYG{p}{(}\PYG{n}{traversalString}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{return} \PYG{n}{traversalString}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Consultant object type identification}
\label{\detokenize{Plugins_ExtendedAPI:consultant-object-type-identification}}
One of the main features the PDF Consultant and Accessibility Checker framework gives you is the use of its identification engine. This engine can look at Cos objects in a PDF file and, based on properties of the objects and of the object’s parents, assign PDF object type identifiers to them.

Each Cos object has a simple Cos type and attributes, in the scheme of the document as a whole each object serves a particular purpose. The PDF object type assigned to each object represents that object’s role in the PDF document.

Some PDF object types represent higher\sphinxhyphen{}level, conceptually\sphinxhyphen{}familiar objects like \sphinxcode{\sphinxupquote{PT\_PAGE}} (which indicates that the object is a page in the document), while others (like \sphinxcode{\sphinxupquote{PT\_AADICTIONARY}} ) are a bit more obscure, particularly to those who are not familiar with the PDF document format. PDF object types are represented using the enumerated type \sphinxcode{\sphinxupquote{PDFObjType}}, which is defined in ConsObTp.h. A good way to see all of the various PDF object types that the consultant can identify is to look at the constants defined in that file.

Some object types (in particular many simpler objects such as strings and numbers) are not assigned a particular type. The consultant can identify those objects that are of most use to you. If the consultant cannot identify a specific object, it assigns the identity of \sphinxcode{\sphinxupquote{PT\_UNKNOWN}} to the object. Just because the consultant assigns this value to an object does not mean the object is foreign or invalid (although it can potentially mean that), it may simply mean that the object type is not particularly significant in the realm of the PDF document format, and thus the consultant does not know about it.

To allow for greater agent flexibility, the consultant understands PDF object type subclasses and superclasses. Certain PDF object types are members of more generic classes of PDF object type. Agents can often make use of this information, so the consultant assigns object types that are actually arrays of types.

The consultant assigns to an object the most specific classification as well as the more generic classes of which the object is a member. Agent structures include a field called \sphinxcode{\sphinxupquote{WantSubclasses}} that indicates whether or not the agent wants to be called for all the interesting objects’ subclasses as well as their directly interesting types.

For example, the \sphinxcode{\sphinxupquote{PT\_ANNOTATION}} object type has a number of more specific subclasses such as \sphinxcode{\sphinxupquote{PT\_LINKANNOTATION}}, \sphinxcode{\sphinxupquote{PT\_LINEANNOTATION}}, and so on. If an agent requests only objects of type \sphinxcode{\sphinxupquote{PT\_ANNOTATION}}, and its \sphinxcode{\sphinxupquote{WantSubclasses}} member is \sphinxcode{\sphinxupquote{false}}, it may not be called back for very many objects. If the \sphinxcode{\sphinxupquote{WantSubclasses}} member is \sphinxcode{\sphinxupquote{true}}, then the consultant will invoke the agent back for objects of all specific types of annotations as well as those classified only as \sphinxcode{\sphinxupquote{PT\_ANNOTATION}}. This also means that when an agent retrieves the type of an object, it must specify which type it wants. The types in the array that is the classification of the object always go from the most specific (at index 0) to the least specific (the last index in the array).


\subsection{Creating an agent class}
\label{\detokenize{Plugins_ExtendedAPI:creating-an-agent-class}}
A minimal \sphinxcode{\sphinxupquote{Agent}} class needs only to define the functions defined as virtual in the \sphinxcode{\sphinxupquote{ConsultantAgentObject}} class declared in ConsExpt.h. The following example shows this definition.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}ConsExpt.h\PYGZdq{}}
\PYG{k}{class} \PYG{n+nc}{DumpAllObjectsAgent} \PYG{p}{:} \PYG{n}{public} \PYG{n}{ConsultantAgentObj}
\PYG{p}{\PYGZob{}}
\PYG{n}{protected}\PYG{p}{:}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Data} \PYG{n}{members}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{FILE}\PYG{o}{*} \PYG{n}{m\PYGZus{}DumpFile}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{static} \PYG{n}{PDFObjType} \PYG{n}{s\PYGZus{}hAgentObjects}\PYG{p}{[} \PYG{p}{]}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{static} \PYG{n}{ASUns32} \PYG{n}{s\PYGZus{}iNumAgentObjects}\PYG{p}{;}
\PYG{n}{public}\PYG{p}{:}


\PYG{o}{/}\PYG{o}{/} \PYG{n}{Constructor} \PYG{o}{/} \PYG{n}{destructor}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{DumpAllObjectsAgent}\PYG{p}{(}\PYG{n}{PDDoc} \PYG{n}{hPDDoc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{DumpAllObjectsAgent}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/} \PYG{n}{Required} \PYG{n}{methods}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{virtual} \PYG{n}{void} \PYG{n}{ConsAgentPostProcess}\PYG{p}{(}\PYG{n}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{virtual} \PYG{n}{ASInt32} \PYG{n}{ObjFound}\PYG{p}{(}\PYG{n}{CosObj} \PYG{n}{Obj}\PYG{p}{,} \PYG{n}{const} \PYG{n}{PDFObjType}\PYG{o}{*}
\PYG{n}{pObjTypeHierarchy}\PYG{p}{,}
\PYG{n}{const} \PYG{n}{ASUns32} \PYG{n}{SizeObjHierarchy}\PYG{p}{,}
\PYG{n}{TraversalStack} \PYG{n}{Stack}\PYG{p}{,}\PYG{n}{CosObj}\PYG{o}{*} \PYG{n}{pObjToReturn}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Creating agent constructors}
\label{\detokenize{Plugins_ExtendedAPI:creating-agent-constructors}}
In order to write an \sphinxcode{\sphinxupquote{Agent}} class derived from the \sphinxcode{\sphinxupquote{ConsultantAgentObj}} base class, you must invoke the base constructor in the derived classes construction list. The base constructor requires a constant array of so\sphinxhyphen{}called objects of interest (of type \sphinxcode{\sphinxupquote{PDFObjType}} ) as well as the length of the array (as \sphinxcode{\sphinxupquote{ASUns32}} ) to be passed as parameters. It is up to you as to where and how the array of types is stored; however, the storage must persist, as the base class saves only a pointer to the data. This has important implications for authoring agents; the derived class cannot initialize the data in its own constructor since the base constructor is called first.

The following example shows an example constructor. In the Agent example the array types and array length are static data members of the \sphinxcode{\sphinxupquote{Agent}} class. In larger\sphinxhyphen{}scale systems it is better to create a host object for the agent that is responsible for determining the proper objects to include in the array and for passing them on to the \sphinxcode{\sphinxupquote{Agent}} constructor. The list of object types is passed on to the consultant when \sphinxcode{\sphinxupquote{ConsultantRegisterAgent}} is invoked.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Define} \PYG{n}{static} \PYG{n}{const} \PYG{n}{data} \PYG{n}{to} \PYG{n}{be} \PYG{n}{passed} \PYG{n}{to} \PYG{n}{parent} \PYG{k}{class} \PYG{n+nc}{constructor}
\PYG{o}{/}\PYG{o}{/}   \PYG{n}{const} \PYG{n}{ASUns32} \PYG{n}{DumpAllObjectsAgent}\PYG{p}{:}\PYG{p}{:}\PYG{n}{s\PYGZus{}iNumAgentObjects} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{PDFObjType}
\PYG{n}{DumpAllObjectsAgent}\PYG{p}{:}\PYG{p}{:}\PYG{n}{s\PYGZus{}hAgentObjects}\PYG{p}{[}\PYG{n}{DumpAllObjectsAgent}\PYG{p}{:}\PYG{p}{:}

\PYG{n}{s\PYGZus{}iNumAgentObjects}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{DT\PYGZus{}ALL}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{o}{/}\PYG{o}{/} \PYG{n}{Derived} \PYG{n}{Agent} \PYG{k}{class} \PYG{n+nc}{constructor}
\PYG{n}{DumpAllObjectsAgent}\PYG{p}{:}\PYG{p}{:}\PYG{n}{DumpAllObjectsAgent}\PYG{p}{(} \PYG{n}{PDDoc} \PYG{n}{hPDDoc} \PYG{p}{)} \PYG{p}{:}
\PYG{n}{ConsultantAgentObj}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{s\PYGZus{}hAgentObjects}\PYG{p}{[} \PYG{l+m+mi}{0} \PYG{p}{]}\PYG{p}{,} \PYG{n}{s\PYGZus{}iNumAgentObjects} \PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{n}{Open} \PYG{n}{Temporary} \PYG{n}{File} \PYG{o+ow}{and} \PYG{n}{Initialize} \PYG{n}{Data} \PYG{n}{Members}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Recognizing objects of interest}
\label{\detokenize{Plugins_ExtendedAPI:recognizing-objects-of-interest}}
Agents register a list of objects with the consultant in which they are interested. When the consultant classifies an object as any of the types the agent registered with, the consultant calls the \sphinxcode{\sphinxupquote{ObjFound}} callback function, a virtual function in the \sphinxcode{\sphinxupquote{ConsultantAgentObj}} base class.
\begin{itemize}
\item {} 
The parameters the consultant passes to this function allow the function to set up a return value with information about the current object, its parents, and the state of the consultant traversal stack.

\item {} 
The return value from the callback is an \sphinxcode{\sphinxupquote{OR}} of bit flags that instruct the consultant on handling the current object.

\end{itemize}

In the \sphinxhref{Plugins\_ExtendedAPI.html\#50618414\_14456}{Creating agent constructors} example, an \sphinxcode{\sphinxupquote{Agent}} constructor simply gathers information about each object encountered and outputs it to a file. It does not need to have the consultant make any modifications to the document. Therefore, in the definition of the \sphinxcode{\sphinxupquote{ObjFound}} callback function, the return value is always \sphinxcode{\sphinxupquote{OD\_NOCHANGE}} and the object returned in \sphinxcode{\sphinxupquote{pObjToReturn}} is simply the same object that was found. In many cases it makes the most sense for an agent to make all document modifications itself, without the consultant’s replace and remove facilities. In these cases you must take special care not to modify objects that are currently on the consultant’s traversal stack.

The \sphinxcode{\sphinxupquote{DumpAllObjects}} plugin demonstrates that \sphinxcode{\sphinxupquote{PDFConsultant}} agents can access any Cos object from any point in the document. The plugin writes information about certain Cos objects to an output file, called AllObjects.txt.

The \sphinxcode{\sphinxupquote{ObjFound}} callback function of the \sphinxcode{\sphinxupquote{DumpAllObjects}} agent writes to a file the Cos object traversal path that it took to reach a specific Cos object. The function calls \sphinxcode{\sphinxupquote{GetTraversalString}}, which describes, with respect to other objects, where a given object lives in the document. For example, the following shows the format of a traversal path of a text annotation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{18} \PYG{l+m+mi}{0} \PYG{n}{obj} \PYG{n}{PT\PYGZus{}TEXTANNOTATION} \PYG{o}{|} \PYG{n}{PT\PYGZus{}ANNOTATION} \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AcroForm}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Fields}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
 \PYG{n}{P}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Annots}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

The consultant looks at all Cos objects. To simplify the output, the \sphinxcode{\sphinxupquote{DumpAllObjects}} agent only involves the most common Cos objects: \sphinxcode{\sphinxupquote{CosString}}, \sphinxcode{\sphinxupquote{CosDict}}, \sphinxcode{\sphinxupquote{CosArray}}, and \sphinxcode{\sphinxupquote{CosStream}}.


\subsection{Post processing stage}
\label{\detokenize{Plugins_ExtendedAPI:post-processing-stage}}
The second and final required function definition in any \sphinxcode{\sphinxupquote{ConsultantAgentObj}} derived class is the \sphinxcode{\sphinxupquote{PostProcess}} callback. This function is called when the consultant has finished its traversal and is preparing to unregister agents to prepare for the next possible run. This callback takes no parameters and returns no values (see ConsAgentPostProcessCallback). There are also no restrictions on what types of operations the Agent can perform on the document in this function.

The \sphinxcode{\sphinxupquote{PostProcess}} callback function is the place to perform any operations that may otherwise damage the consultant’s traversal by modifying objects up the consultant’s current traversal stack.


\section{Digital signature extended API}
\label{\detokenize{Plugins_ExtendedAPI:digital-signature-extended-api}}
Digital signatures allow a person to attest to something about a document by signing their name to it. An Acrobat signature in a document is bound to that document in such a way that altering the signed document or moving the signature to a different document invalidates the signature.

A single document may be signed more than once, and changes may occur between signings. Acrobat’s digital signatures link each signature with a particular state of the document. All changes append the PDF changes to the fully\sphinxhyphen{}preserved base PDF document. The ability to do serial signatures of protected documents is unique to Acrobat, and draws heavily on the PDF file design for an appended save.

Adobe Acrobat implements digital signatures using plugins that can handle both generic functions common to all digital signatures, and also specific kinds of signatures (signing methods), such as public\sphinxhyphen{}private key (PPK), handwriting, retinal scans, fingerprints, and so on.

The following diagram shows the security plugin relationships.

\noindent\sphinxincludegraphics{{digsig}.png}

For information about the APIs that make up the Digital signature extended API, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\subsection{The PubSec layer}
\label{\detokenize{Plugins_ExtendedAPI:the-pubsec-layer}}
The PubSec layer, introduced in Acrobat 6.0, is an interface for Acrobat public\sphinxhyphen{}key security handlers. PubSec forms a high\sphinxhyphen{}level interface to the digital signature facility; the PubSec code uses DigSig for digital signature operations, but provides many additional benefits. Developers are encouraged to use the PubSec HFT rather then DigSig HFT.

PubSec methods enable you to perform the following tasks:
\begin{itemize}
\item {} 
Count and close encrypted documents.

\item {} 
Validate a specific signature field.

\item {} 
Access and create digests for data buffers.

\item {} 
Import and export certificate data, and manage the certificates in the Acrobat Address Book (AAB).

\item {} 
Manage signature appearances (DSAP files).

\item {} 
Register and unregister handlers. Handlers can register as PubSec handlers to provide the following cryptographic services:
\begin{itemize}
\item {} 
Do private\sphinxhyphen{}key signing and signature validation

\item {} 
Act as a cryptographic source for decrypting using private keys

\item {} 
Act as a directory source for certificate\sphinxhyphen{}based identity authentication

\end{itemize}

\end{itemize}

Handlers can call back into the PubSec HFT for various services. Most calls to PubSec pass an opaque state object called a \sphinxcode{\sphinxupquote{PSEngine}}. You specify a default engine upon registering the handler, and the default engine can make use of the security UI dialog boxes provided by PubSec and DigSig.

To register a handler with PubSec, perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Implement the callbacks you need to provide customized functionality. Many of the callbacks for PubSec can be specified as NULL, in which case PubSec provides default behavior. It is recommended that you use the default behavior when possible.

\item {} 
Fill in the handler structure with pointers to your callback implementations (PubSecHandler).

\item {} 
Register the handler with PubSec by invoking the \sphinxcode{\sphinxupquote{PSRegisterHandler}} method.

\end{enumerate}


\subsection{Digital signature components}
\label{\detokenize{Plugins_ExtendedAPI:digital-signature-components}}
Digital signatures contain two parts:
\begin{itemize}
\item {} 
The signature field dictionary which is the PDF dictionary structure that stores information about the signature.

\item {} 
The signature annotation with its associated appearance (including the background and layout of name, time, and so on). A blind digital signature does not have an associated appearance.

\end{itemize}

Acrobat’s digital signature plugin creates these two parts when the user chooses to sign a document. Your plugins do not have to handle deleting the signature, as the DigSig plugin does that transparently.


\subsection{Digital signature scenarios}
\label{\detokenize{Plugins_ExtendedAPI:digital-signature-scenarios}}
Acrobat supports three digital signature scenarios. Acrobat’s Digital Signature plugin handles the first case, and allows other plugins to further handle the second and the third cases.{[}The following steps look as if they are part of a procedure, but I don’t think they are. If they’re simply three scenarios, they should be bulleted items, 5Heads, or perhaps reworked as inline headings with text. The other situation where we use a numbered list is if order is important, but I don’t think that is the situation here either. The Adobe editorial style guide says “A numbered list should be sequential. If the items in the list are not sequential, don’t number them.{]}
\begin{itemize}
\item {} 
If the user creates a signature field and does not specify a default signing method, DigSig handles that case with no communication to your plugins:
\begin{itemize}
\item {} 
DigSig creates the signature field dictionary.

\item {} 
DigSig creates the signature annotation dictionary.

\item {} 
DigSig creates the (blank) signature appearance dictionary.

\end{itemize}

\item {} 
The Forms plugin also creates Signature fields. If the user creates a signature field and specifies a default method, Forms calls DigSig to fill in default values:
\begin{itemize}
\item {} 
DigSig creates the signature field dictionary, the signature annotation dictionary, and the (blank) signature appearance dictionary.

\item {} 
DigSig calls the DSDefaultValueProc callback that your plugin provides. This callback must create the default signature value dictionary and create the /DV key in the signature field dictionary to point to it.

\end{itemize}

\item {} 
If the user asks to sign a specific signature field using the plugin, DigSig invokes callbacks into your plugin during a four\sphinxhyphen{}step sequence. Your plugin must register these callbacks during the plugin initialization phase. The four callbacks required for this scenario are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{dsNewSigData}}

\item {} 
\sphinxcode{\sphinxupquote{dsCommitSign}}

\item {} 
\sphinxcode{\sphinxupquote{dsFinshSign}}

\item {} 
\sphinxcode{\sphinxupquote{dsFreeSigData}}

\end{itemize}

\end{itemize}


\subsection{Initializing the digital signature plugin}
\label{\detokenize{Plugins_ExtendedAPI:initializing-the-digital-signature-plugin}}
When Acrobat is started, all plugins go through a three\sphinxhyphen{}step initialization process that allows plugins to establish communication among themselves without being dependent on the order of loading. Plugins that interact with Acrobat’s digital signature plugin (DigSig) use the following initialization sequence:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The DigSig plugin exports its HFT under the name DigSigHFT.

\item {} 
To work with DigSig, your plugin must import the DigSig HFT.

\item {} 
To work with DigSig, your plugin must create a \sphinxcode{\sphinxupquote{DigSigHandlerRec}} structure, assign the relevant methods, and then invoke the \sphinxcode{\sphinxupquote{DigSigRegisterFilter}} method to register the structure.

\end{enumerate}

When the user opens a document, the digital signature plugin notifies your plugin of the new document by invoking the \sphinxcode{\sphinxupquote{DSDocOpenProc}} method. You can allocate some storage or choose to automatically validate any of their respective signatures in the document.

Auto\sphinxhyphen{}validation may produce significant delays if it must read all of a large document from a CD\sphinxhyphen{}ROM or over a network, or if it must access a signature registry or authority over a network. Therefore, Adobe software only accesses signatures at user request.

When the user closes a document, the digital signature plugin invokes \sphinxcode{\sphinxupquote{DSDocCloseProc}}.


\subsection{Understanding the process}
\label{\detokenize{Plugins_ExtendedAPI:understanding-the-process}}
The steps in this section are suggestions that describe the interactions of a digital signature plugin (the SignDoc sample plugin provided with this SDK is a more complete example).


\subsubsection{Dialogs and signature gathering}
\label{\detokenize{Plugins_ExtendedAPI:dialogs-and-signature-gathering}}
The digital signature plugin invokes your \sphinxcode{\sphinxupquote{dsNewSigDataProc}} callback method, a callback that begins the signature gathering process:
\begin{itemize}
\item {} 
Your plugin interacts with the user, and allows the user to cancel if they want to do so.

\item {} 
Your plugin acquires the signature itself in a method\sphinxhyphen{}specific way. All information is saved in memory, without altering the document itself.

\item {} 
If \sphinxcode{\sphinxupquote{dsNewSigData}} does not cancel, DigSig prepares the document for saving. First, it calls \sphinxcode{\sphinxupquote{dsUnValidateSig}} on every signature in the document to put any overprinting or underprinting in canonical form. It then counts how many pages and fields have changed since any prior signature and records this.

\item {} 
For a first signature, the digital signature plugin displays the Save As dialog box, allowing the user to select file name, optimization, and encryption. The user may cancel. Other than fatal errors, such as out\sphinxhyphen{}of\sphinxhyphen{}disk\sphinxhyphen{}space, this is the last chance to stop the process.

\end{itemize}


\subsubsection{Saving a document}
\label{\detokenize{Plugins_ExtendedAPI:saving-a-document}}
The following steps describe how the digital signature plugin saves a document:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The digital signature plugin invokes your \sphinxcode{\sphinxupquote{DSCommitSignProc}} callback method to update the document with the actual signature. Your \sphinxcode{\sphinxupquote{DSCommitSignProc}} callback must perform the following tasks:
\begin{itemize}
\item {} 
Create the signature dictionary, possibly using information in the signature field /DV dictionary, perhaps using the \sphinxcode{\sphinxupquote{/ByteRange}} and \sphinxcode{\sphinxupquote{/Contents}} keys.

\item {} 
Point /V in the signature field dictionary to this. Then create the /AP /N value in the signature annotation dictionary, using a method\sphinxhyphen{}specific visible representation of the signature, including a symbol signifying “unvalidated signature.”

\item {} 
Optionally allocate dynamic storage for a marked array, an array of marked COS objects that it cares about.

\item {} 
Return a marked array that includes at least the /ByteRange and /Contents value objects.

\end{itemize}

\item {} 
The digital signature plugin inserts the /Changes array from step 1.

\item {} 
The digital signature plugin saves the PDF document to a file. For each Cos object in the marked array, DigSig records the object’s byte offset and length in the file as written. The saved file may have objects encrypted by the Acrobat standard encryption handler, if the user so chooses.

\item {} 
The first time a document is signed, the digital signature plugin may rename the file and may invoke the Optimizer, Linearizer, and Garbage Collector. Upon return from the save, all Cos objects are invalid, including those in the marked array.

\end{enumerate}

All PD\sphinxhyphen{}level objects except the \sphinxcode{\sphinxupquote{PDDoc}} are invalid. Signing methods must not depend on saving any such state between \sphinxcode{\sphinxupquote{dsCommitSign}} and \sphinxcode{\sphinxupquote{dsFinishSign}}. In particular, the byte offsets and lengths in the marked array are valid upon entry to \sphinxcode{\sphinxupquote{doSign}}, but the Cos objects are not. The order of entries is unchanged, however, these Cos objects will be rewritten as CosNull before invoking \sphinxstyleemphasis{dsFinishSign}.


\subsubsection{Finishing the process}
\label{\detokenize{Plugins_ExtendedAPI:finishing-the-process}}
The following describes how the digital signature plugin finishes the process of a signing a document:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Invokes \sphinxcode{\sphinxupquote{dsFinishSign}}, passing back in the marked array. Your \sphinxcode{\sphinxupquote{DSFinishSignProc}} callback method must perform the following tasks:
\begin{itemize}
\item {} 
Calculate the \sphinxcode{\sphinxupquote{/ByteRange}} that it desires, using the byte offsets and lengths in the marked array.

\item {} 
Overwrite the marked \sphinxcode{\sphinxupquote{/ByteRange}} value in the saved file, using the \sphinxcode{\sphinxupquote{DigSigOverwriteIntArray}} or \sphinxcode{\sphinxupquote{DigSigOverwriteBytes}} callback.

\item {} 
Overwrite any other marked Cos objects it wants to.

\item {} 
Calculate any document digest that it desires, using the \sphinxcode{\sphinxupquote{DigSigFileGetEOF, DigSigFileSetPos}}, and \sphinxcode{\sphinxupquote{DigSigFileRead}} callbacks; or it may use the \sphinxcode{\sphinxupquote{DigSigMD5ByteRange}} callback.

\item {} 
Obscure or encrypt this digest in a method\sphinxhyphen{}specific way.

\item {} 
Overwrite the marked \sphinxcode{\sphinxupquote{/Contents}} value in the saved file, using \sphinxcode{\sphinxupquote{DigSigOverwriteHexstring}} or \sphinxcode{\sphinxupquote{DigSigOverwriteBytes}}.

\item {} 
Optionally delete dynamic storage for the marked array returned by the plugin.

\end{itemize}

\item {} 
Invokes \sphinxcode{\sphinxupquote{dsFreeSigData}}, which may free up any remaining storage.

\end{enumerate}


\subsubsection{Revalidating signatures}
\label{\detokenize{Plugins_ExtendedAPI:revalidating-signatures}}
If the user reopens the file, the signatures must be validated. If the user asks to validate one or more signature fields, the digital signature plugin sequences through them one at a time. Your \sphinxcode{\sphinxupquote{DSValidateSignProc}} callback method must perform the following tasks:
\begin{itemize}
\item {} 
Recalculate any document digest that it desires, using the \sphinxcode{\sphinxupquote{DigSigFileGetEOF}}, \sphinxcode{\sphinxupquote{DigSigFileSetPos}}, and \sphinxcode{\sphinxupquote{DigSigFileRead}} callbacks; or it may use the \sphinxcode{\sphinxupquote{DigSigMD5ByteRange}} callback.

\item {} 
Compare this result to the stored one, and do any other method\sphinxhyphen{}specific checks it desires.

\item {} 
Optionally do a validation against some stored (network) registry.

\item {} 
Update the \sphinxcode{\sphinxupquote{/AP}} \sphinxcode{\sphinxupquote{/N}} value in the signature annotation dictionary to show doublechecked/pass/fail symbol.

\item {} 
Return doublechecked/pass/fail.

\end{itemize}

The user may open more than one document at a time, and may switch between open documents.


\subsubsection{Additional available callbacks}
\label{\detokenize{Plugins_ExtendedAPI:additional-available-callbacks}}
The user may ask to show a signature panel containing summary information for each signature in an open document. If multiple documents are open, there may be multiple panels, or a single panel may be repainted as the user switches between documents. DigSig manages updating the panel(s), but may call the respective method plugin for each signature to get information to display on the panel. For each signature, the signature panel has two levels of detail:{[}Same comment as on page 15 about the following not being a sequential list.{]}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
CLOSED displays a doublechecked/pass/fail/unknown/blank icon and a line of text for each signature field in the document. The default text is the name of the person signing and the date and time of signing, displayed in a language\sphinxhyphen{}independent way.

\item {} 
The digital signature plugin calls \sphinxcode{\sphinxupquote{dsGetValidState}} to choose which icon to show.

\item {} 
OPEN displays an icon and line of text for each signature, then indented lines of further text, currently consisting of the name of the signer, date and time of signing, location of signing, reason for signing, and signing method.

\item {} 
The digital signature calls \sphinxcode{\sphinxupquote{dsGetValidState}} to choose which icon to show.

\item {} 
Your plugin may update the signature panel for a document asynchronously (it may be doing validation as a background or idle\sphinxhyphen{}loop task). To do this, use the \sphinxcode{\sphinxupquote{DigSigUpdatePanel}} callback.

\end{enumerate}


\subsubsection{Additional plugin support}
\label{\detokenize{Plugins_ExtendedAPI:additional-plugin-support}}
Whenever a signature is created or verified, the plugin may optionally alter the appearance of the signature in the document, for the purpose of displaying or printing. For example, it could change an overprinted question mark on an unverified signature to an underprinted logo for a verified signature. To help with this, DigSig provides an HFT callback \sphinxcode{\sphinxupquote{DigSigGetStdXObj}} that returns an XObject for a blank appearance, a question mark, or a cross. These are suitable as targets of the Do operator in a signature’s appearance stream.

To avoid saving a signature to a file with an appearance of valid (rather than unvalidated), just before each file save, DigSig loops through all the signature fields and calls the specific method’s \sphinxcode{\sphinxupquote{dsUnValidateSig}} entry. This routine restores the signature’s appearance to the unvalidated state.

The AcroForms Widget Annot handler calls into DigSig using four entries. These calls all reflect user actions taken in the document view, not the Signatures panel view.

When the user selects an annotation by tabbing to it or by clicking it with the mouse, and that annotation is for a signature field, AcroForms calls DigSigDraw. If the annotation is selected, then \sphinxcode{\sphinxupquote{bIsSelected}} is true. When the user tabs to a signature annotation and activates it by hitting the spacebar or enter key, this is equivalent to a left mouse click.

AcroForms calls \sphinxcode{\sphinxupquote{DigSigKeyDown}}. The parameters parallel those of \sphinxcode{\sphinxupquote{AVAnnotHandlerDoKeyDownProc}}. When the user left\sphinxhyphen{}clicks inside a signature annotation, AcroForms calls \sphinxcode{\sphinxupquote{DigSigClick}}. The parameters parallel those of \sphinxcode{\sphinxupquote{DoClickProcType}}.

When the user right\sphinxhyphen{}clicks inside a signature annotation, AcroForms calls DigSigRightClick.


\subsubsection{Rollback support}
\label{\detokenize{Plugins_ExtendedAPI:rollback-support}}
There is a constraint on the values in the /ByteRange array. This constraint allows DigSig to implement rollbacks prior to signatures.

The largest offset + length value in the /ByteRange array for a given signature must be equal to the length of the PDF file containing that signature; that is, it must equal offset + 1 of the “F” in the \%\%EOF at the end of the file.

In addition, the following constraints also apply:
\begin{itemize}
\item {} 
All offsets must be in the range 0..2147483647.

\item {} 
All lengths must be in the range 1..2147483647.

\item {} 
Offset{[}n+1{]} must be strictly greater than offset{[}n{]} + length{[}n{]}.

\end{itemize}


\section{Forms extended API}
\label{\detokenize{Plugins_ExtendedAPI:forms-extended-api}}
The Acrobat Forms plugin exports its own Host Function Table (HFT), whose methods can be used by other plugins. To use the Acrobat Forms plugin’s HFT, a plugin must:
\begin{itemize}
\item {} 
Include the FormsHFT.h header file (which includes AF\_ExpT.h and AF\_Sel.h).

\item {} 
Import the HFT using the \sphinxcode{\sphinxupquote{ASExtensionMgrGetHFT}} method. A convenient way to perform this task is to use the \sphinxcode{\sphinxupquote{Init\_AcroFormHFT}} macro defined in FORMSHFT.H.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}define Init\PYGZus{}AcroFormHFT}
 \PYG{n}{ASExtensionMgrGetHFT}\PYG{p}{(}\PYG{n}{ASAtomFromString}\PYG{p}{(}\PYG{n}{AcroFormHFT\PYGZus{}NAME}\PYG{p}{)}\PYG{p}{,}
 \PYG{n}{AcroFormHFT\PYGZus{}LATEST\PYGZus{}VERSION}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Assign the HFT returned by this call to a plugin\sphinxhyphen{}defined global variable named \sphinxcode{\sphinxupquote{gAcroFormHFT}}.

\end{itemize}

Data may be imported and exported into Acrobat Forms in forms data format (FDF). FDF is used to submit form data to a server, as well as to receive the response and incorporate it into a form. FDF is based on PDF and uses the same syntax and set of basic object types as PDF. It also has the same file structure, except that the cross\sphinxhyphen{}reference table is optional. See the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference}. for more information about the structure of a PDF document.

For information about the APIs included in the Forms extended API, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{Weblink extended API}
\label{\detokenize{Plugins_ExtendedAPI:weblink-extended-api}}
A link in a PDF document that references a URL is referred to as a Weblink.

The Acrobat Weblink plugin exports its own Host Function Table (HFT), whose methods can be used by other plugins. The HFT’s name is defined in the WLHFTNAME macro, and its version number is \sphinxcode{\sphinxupquote{WEB\_LINK\_HFT\_LATEST\_VERSION}}.

To use the Weblink plugin’s HFT, a plugin must include the header file WeblinkHFT.h. The plugin must also import the HFT using \sphinxcode{\sphinxupquote{ASExtensionMgrGetHFT}} and assign the HFT returned by this call to a plugin\sphinxhyphen{}defined global variable named \sphinxcode{\sphinxupquote{gWLHFT}}. The easiest way to do this is to use the \sphinxcode{\sphinxupquote{Init\_gWLHFT}} macro defined in the header files.

For information about the APIs included in the Weblink extended API, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\subsection{Weblink services}
\label{\detokenize{Plugins_ExtendedAPI:weblink-services}}
The Weblink plugin provides the following services:
\begin{itemize}
\item {} 
Maintenance of links (editing and storage of URLs associated with links, and so on)

\item {} 
Manipulation of links (appropriate cursor changes and dynamic display of URL destinations)

\item {} 
Selection of the external web browser

\item {} 
Manipulation of the Adobe standard web driver

\item {} 
Basic progress status services (progress monitor, wait cursor, and so on)

\end{itemize}

The Weblink plugin includes a standard driver, known as the Adobe Standard Web Driver. It allows support for transport mechanisms or web browsers to be added at a later time.

The Standard Web Driver uses DDE messages and Apple events to communicate with a web browser. It supports a protocol that consists of a suite of verbs—some going to and some coming from—the web browser. These verb definitions are provided so that web browsers can implement this protocol to be compatible with the Adobe standard web driver. Each verb is specified in terms of the platform\sphinxhyphen{}specific implementation: DDE for Windows and Apple events for Mac OS. The standard driver’s use of each verb is also described. Browsers that wish to use their own protocol may do so by writing a custom driver.

The Weblink plugin communications software in the Weblink driver is independent of the Acrobat mechanism for handling links (the PDF implementation of URLs). This separation improves portability by isolating the highly platform\sphinxhyphen{}specific interapplication communication messages. Even on a given platform, there is no standard among web browsers for handling interapplication communication, and the actual transport mechanism may vary over time. By separating out the transport code, the Weblink plugin remains portable across platforms, across different vendors’ implementations of web browsers, and across different versions of web browsers from the same vendor.


\subsection{Writing a custom driver}
\label{\detokenize{Plugins_ExtendedAPI:writing-a-custom-driver}}
A driver is an Acrobat core plugin, written like any other plugin. A driver must register itself with the Weblink plugin during the import, replace, and register phases of the plugin initialization process by invoking \sphinxcode{\sphinxupquote{RegisterWebDriver}}. You pass this method a \sphinxcode{\sphinxupquote{WebDriverVector}} structure containing a version number and six pointers to functions that your driver provides to handle web\sphinxhyphen{}browser\sphinxhyphen{}specific tasks.

A driver is responsible for performing the following tasks:
\begin{itemize}
\item {} 
Connecting with external services (either directly or through an external application)

\item {} 
Communicating with external services

\item {} 
Associating a base URL with a given document

\item {} 
Identifying external browsers that are compatible with the driver

\end{itemize}

In a typical session, the following actions can occur:{[}Same question as page 15. Is the following numbered list sequential?{]}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The user starts Acrobat.
\begin{itemize}
\item {} 
The Weblink plugin publishes a Host Function Table (HFT) during the \sphinxcode{\sphinxupquote{exportHFTsCallback}} phase of initialization.

\item {} 
During the \sphinxcode{\sphinxupquote{importReplaceAndRegisterCallback}} phase, all drivers in turn invoke \sphinxcode{\sphinxupquote{RegisterWebDriver}} in the Weblink plugin’s HFT to register themselves as available.

\item {} 
During the \sphinxcode{\sphinxupquote{initCallback}} phase, the Weblink plugin, if possible, selects an appropriate driver and notifies it that it is the active driver.

\end{itemize}

\item {} 
The user opens a PDF document with Weblinks and clicks a Weblink.
\begin{itemize}
\item {} 
The Weblink plugin extracts the URL from the link and passes it to the driver.

\item {} 
The driver packages the URL into an interapplication communication (IAC) message and sends it to an external web browser (launching the browser application, if necessary).

\item {} 
The external web browser brings itself to the foreground unless the URL’s MIME type is application/pdf.

\end{itemize}

\item {} 
The web browser retrieves the document and packages an IAC message.
\begin{itemize}
\item {} 
The driver accepts the IAC message from the browser and opens the PDF document by using the \sphinxcode{\sphinxupquote{AVDocOpenFromFile}} method. The driver should associate the URL with the document.

\item {} 
To resolve relative links, Weblink prepends either a base URL with the document, or if there is no base URL, the appropriate portion of the URL of the document the link is in.

\end{itemize}

\end{enumerate}


\section{Spelling extended API}
\label{\detokenize{Plugins_ExtendedAPI:spelling-extended-api}}
Acrobat provides a Spelling plugin, which exports a Host Function Table (HFT) implementing a spell\sphinxhyphen{}check API for use by plugin developers.

To use the spelling HFT, a plugin must include the header file SpellerHFT.h, which includes Speller\_Sel.h.

The following is a typical sequence of calls made by a plugin using the Spelling HFT. During its \sphinxcode{\sphinxupquote{importReplaceAndRegister}} callback, the plugin should:
\begin{itemize}
\item {} 
Import the HFT, using \sphinxcode{\sphinxupquote{ASExtensionMgrGetHFT}}, and assign the HFT returned by this call to a plugin\sphinxhyphen{}defined global variable named \sphinxcode{\sphinxupquote{gSpellerHFT}}. The easiest way to do this is to use the Init\_SpellerHFT macro defined in SpellerHFT.h.

\item {} 
Allocate and initialize one \sphinxcode{\sphinxupquote{SpellCheckParam}} block for each spelling domain the client will add.

\item {} 
Add zero or more domains using the \sphinxcode{\sphinxupquote{SpellAddDomain}} call.

\end{itemize}

During execution, a plugin performs the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Respond to the following callbacks for each domain:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SCEnableProc}} is called by Spelling to ask if this domain has anything that needs to be checked

\item {} 
\sphinxcode{\sphinxupquote{SCGetTextProc}} is called to get a text buffer to be checked.

\item {} 
\sphinxcode{\sphinxupquote{SCCompletionProc}} is called after the user has modified the text buffer.

\end{itemize}

\item {} 
The client may call other Spelling HFT services during execution even if it did not add a domain.

\end{enumerate}

During its \sphinxcode{\sphinxupquote{unloadCallback}}, a plugin should perform the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Remove all spelling domains added during initialization using the \sphinxcode{\sphinxupquote{SpellRemoveDomain}} method.

\item {} 
Free all memory associated with \sphinxcode{\sphinxupquote{SpellCheckParam}} block(s) (\sphinxcode{\sphinxupquote{scInBuffer}}, \sphinxcode{\sphinxupquote{scOutBuffer}}, and \sphinxcode{\sphinxupquote{scClientData}} ).

\item {} 
Free the \sphinxcode{\sphinxupquote{SpellCheckParam}} block(s).

\end{enumerate}

Several of the Spelling API methods (\sphinxcode{\sphinxupquote{SpellCheck}}, \sphinxcode{\sphinxupquote{SpellCheckText}}, and \sphinxcode{\sphinxupquote{SpellCheckWord}} ) take input strings as parameters, and several methods return strings as output parameters.

Input strings are either big\sphinxhyphen{}endian Unicode strings with the bytes 0xFE 0xFF prepended, or strings with \sphinxcode{\sphinxupquote{PDFDocEncoding}}. In either case a string is expected to have the appropriate null\sphinxhyphen{}termination. If a string is UCS\sphinxhyphen{}2 it may have embedded language and country information.

Output text is in big\sphinxhyphen{}endian UCS\sphinxhyphen{}2 format with the bytes 0xFE 0xFF prepended. This string can be converted to a host encoded string by using the \sphinxcode{\sphinxupquote{ASTextFromPDText}} and \sphinxcode{\sphinxupquote{ASTextGetEncodedCopy}} methods.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{altArray} \PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
 \PYG{n}{ASInt32} \PYG{n}{altCount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
 \PYG{n}{ASBool} \PYG{n}{status} \PYG{o}{=} \PYG{n}{SpellCheckWord}\PYG{p}{(}\PYG{n}{acd}\PYG{p}{,} \PYG{n}{cWord}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{altArray}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{altCount}\PYG{p}{)}\PYG{p}{;}
 \PYG{k}{if} \PYG{p}{(}\PYG{n}{altCount}\PYG{p}{)} \PYG{p}{\PYGZob{}}
     \PYG{n}{ASText} \PYG{n}{ast} \PYG{o}{=} \PYG{n}{ASTextFromPDText}\PYG{p}{(}\PYG{n}{altArray}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
     \PYG{n}{char}\PYG{o}{*} \PYG{n}{altWord} \PYG{o}{=} \PYG{n}{ASTextGetEncodedCopy}\PYG{p}{(}\PYG{n}{ast}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ASHostEncoding}\PYG{p}{)}
     \PYG{n}{PDGetHostEncoding}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{AcroColor extended API}
\label{\detokenize{Plugins_ExtendedAPI:acrocolor-extended-api}}
AcroColor is an HFT that allows you to access the Adobe Color Engine (ACE), which provides color profile management for Acrobat and for other Adobe applications. Plugins can import the AcroColor HFT to use the color management methods.

The AcroColor extended API is the only extended API that is not installed as a plugin. It is part of the Acrobat core, but is considered an extended API. The AcroColor APIs, unlike the other extended APIs, can be used by the PDF Library.

The AcroColor HFT encapsulates color management into a set of convenient objects and functions. The objects represent basic color\sphinxhyphen{}management entities:
\begin{itemize}
\item {} 
The color management engine, or ACE, which is used by the underlying software to control a color management session.

\item {} 
Device\sphinxhyphen{}specific ICC color profiles, which provide specific mapping between standard color specifications and specific values for particular output devices that produce those colors. Additional support objects include profile lists.

\item {} 
Color spaces for the different kinds of color production (such as grayscale, RGB, and CMYK). Additional support objects include calibrated color spaces for standard color specifications.

\item {} 
Transformations between profiles or color spaces.

\item {} 
Color settings, as listed in the Acrobat Preferences. Color settings files contain, for instance, references to color profiles, and apply across Adobe products. Additional support objects include a string object and preset lists of settings.

\end{itemize}

You can create an ICC color profile from available data (\sphinxcode{\sphinxupquote{ACMakeBufferProfile}} ), or use profiles that are installed on the system (\sphinxcode{\sphinxupquote{ACGetWorkingSpaceProfile}} ), or stored in color settings files (\sphinxcode{\sphinxupquote{ACGetSettingsProfile}} ).

You can extract information directly from profiles, such as a string to use in the UI (\sphinxcode{\sphinxupquote{ACProfileDescription}} ). However, the most important thing you do with color profiles is use them to make transformations (\sphinxcode{\sphinxupquote{ACMakeColorTransform}} ). You can then apply it (\sphinxcode{\sphinxupquote{ACApplyTransform)}} to transform a set of image data from one profile to another, so that it appears with the same colors on a different display device.

AcroColor objects are reference\sphinxhyphen{}counted. Each object type has an unreference method (such as \sphinxcode{\sphinxupquote{ACUnReferenceProfile}} ). Whenever you create one of these objects, you are responsible for using the corresponding unreference method to release it when you are finished with it.

The following diagram shows objects and their relationships.

\noindent\sphinxincludegraphics{{AcroColor}.png}


\subsection{Color conversion operations}
\label{\detokenize{Plugins_ExtendedAPI:color-conversion-operations}}
The Color Conversion API has been extended in Acrobat 8.0 to include new APIs that enable you to add color conversion operations to your plugin or PDF Library applications. By using this extended API, you can convert a page based on a list of conversion actions. Each conversion action contains a set of matching fields (object attribute or type, color space, rendering intent), what the action should do if an object matches the matching fields, and conversion parameters (rendering intent, black point compensation, and target color space).

The list of conversion actions is evaluated in order. For example, a list could contain the following actions:
\begin{itemize}
\item {} 
Convert JPEG images to CMYK.

\item {} 
Convert all images to CMYK.

\item {} 
Convert line art using saturation intent.

\end{itemize}


\subsubsection{Object attributes}
\label{\detokenize{Plugins_ExtendedAPI:object-attributes}}
An object located within a PDF document can contain the following attributes:
\begin{itemize}
\item {} 
Image (for example, JPEG/JPEG2K, lossless)

\item {} 
Line art (for example, fill or stroke)

\item {} 
Text

\item {} 
Smooth shade

\item {} 
Transparency

\item {} 
Overprinting

\end{itemize}


\subsubsection{Color space attributes}
\label{\detokenize{Plugins_ExtendedAPI:color-space-attributes}}
The following list describes color space attributes:
\begin{itemize}
\item {} 
Color space (RGB, CMYK, grayscale, Lab)

\item {} 
Calibrated

\item {} 
Device (for example, not calibrated)

\item {} 
Special (Separation/DeviceN)

\item {} 
Indexed

\item {} 
NChannel

\item {} 
Alternate color space

\item {} 
Base of indexed color space

\end{itemize}


\subsubsection{Conversion actions}
\label{\detokenize{Plugins_ExtendedAPI:conversion-actions}}
The following is a list of conversion actions:
\begin{itemize}
\item {} 
Convert to a color space

\item {} 
Preserve the object as it is

\item {} 
Alias a separation to a different one

\item {} 
Decalibrate the object, if possible (for example, replace calibrated spaces with device). This does not work with Lab color spaces.

\item {} 
Downconvert from NChannel to DeviceN

\end{itemize}


\subsubsection{Action modifiers}
\label{\detokenize{Plugins_ExtendedAPI:action-modifiers}}
The following action modifiers apply if the action converts the object:
\begin{itemize}
\item {} 
Render Intent:
\begin{itemize}
\item {} 
Override the color conversion with one of the ICC intents

\item {} 
Use document intent

\end{itemize}

\item {} 
Preserve black

\item {} 
Black point compensation: on or off

\item {} 
Embed or do not embed the target profile if the object was converted

\end{itemize}


\subsubsection{Ink aliasing}
\label{\detokenize{Plugins_ExtendedAPI:ink-aliasing}}
Along with the list of actions, there is a list of inks, such as specific colorants, which can control whether a particular ink is converted to process or aliased to another colorant.


\subsubsection{Data structures}
\label{\detokenize{Plugins_ExtendedAPI:data-structures}}
The AcroColor extended API contains methods, such as \sphinxcode{\sphinxupquote{PDDocColorConvertPage}}, that accept data structure instances as arguments. These data structures consist of a list of action records and a list of inks. Each action record specifies attributes, color spaces, and rendering intent, along with an action. That is, what to do with the particular object if a match is located. The ink list defines ink aliasing or conversion to process for particular named colorants.

The following list specifies the data structures that you use to work with the AcroColor extended API:

\sphinxstylestrong{PDColorConvertAction}: Defines a color conversion action for a combination of attributes, color space, and rendering intent.

\sphinxstylestrong{PDColorConvertParams}: Represents a list of actions that will be performed.

For information about these data structures and their data members, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\subsubsection{Data enum values}
\label{\detokenize{Plugins_ExtendedAPI:data-enum-values}}
Some data structure members require enum values as values. For example, the \sphinxcode{\sphinxupquote{mAction}} member, that belongs to the \sphinxcode{\sphinxupquote{PDColorConvertAction}} data structure, requires a \sphinxcode{\sphinxupquote{PDColorConvertActionType}} value. The following list specifies the data enum values that you use to work with the AcroColor extended API:

\sphinxstylestrong{PDColorConvertObjectAttributeFlags}: Specifies object attributes.

\sphinxstylestrong{PDColorConvertSpaceTypeFlags}: Specifies color space attributes.

\sphinxstylestrong{PDColorConvertActionType}: Specifies action types that occur when an object is matched.

For information about these enum values, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\subsubsection{Converting a document to RGB}
\label{\detokenize{Plugins_ExtendedAPI:converting-a-document-to-rgb}}
You can use the AcroColor extended API to convert a document to RGB by performing the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create an instance of the \sphinxcode{\sphinxupquote{PDColorConvertParams}} data structure.

\item {} 
Create an \sphinxcode{\sphinxupquote{AC\_Profile}} object. This object is used to assign a value to the \sphinxcode{\sphinxupquote{mConvertProfile}} data member that belongs to the \sphinxcode{\sphinxupquote{PDColorConvertAction}} data structure. When you are done with this object, invoke the \sphinxcode{\sphinxupquote{ACUnReferenceProfile}} method to release it from memory.

\item {} 
Invoke the \sphinxcode{\sphinxupquote{ACProfileFromCode}} method and pass the following arguments:
\begin{itemize}
\item {} 
The address of the \sphinxcode{\sphinxupquote{AC\_Profile}} object.

\item {} 
The value \sphinxcode{\sphinxupquote{AC\_Profile\_AppleRGB}} (this is an \sphinxcode{\sphinxupquote{AC\_ProfileCode}} value)

\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Create a \sphinxcode{\sphinxupquote{PDColorConvertActionType}} variable and assign it the value \sphinxcode{\sphinxupquote{kColorConvConvert}}. This variable is used to assign a value to the \sphinxcode{\sphinxupquote{mAction}} data member that belongs to the \sphinxcode{\sphinxupquote{PDColorConvertAction}} data structure.

\item {} 
Create an instance of the \sphinxcode{\sphinxupquote{PDColorConvertAction}} data structure and assign the following values to its data members:

\end{enumerate}

\sphinxstylestrong{mMatchAttributesAny}: Assign \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}

\sphinxstylestrong{mMatchSpaceTypeAny}: Assign \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}

\sphinxstylestrong{mMatchIntent}: Assign \sphinxcode{\sphinxupquote{AC\_UseProfileIntent}} (an \sphinxcode{\sphinxupquote{AC\_RenderIntent}} value)

\sphinxstylestrong{mConvertProfile}: Assign the \sphinxcode{\sphinxupquote{AC\_Profile}} object

\sphinxstylestrong{mEmbed}: Assign \sphinxcode{\sphinxupquote{true}}

\sphinxstylestrong{mPreserveBlack}: Assign \sphinxcode{\sphinxupquote{false}}

\sphinxstylestrong{mUseBlackPointCompensation}: Assign \sphinxcode{\sphinxupquote{true}}

\sphinxstylestrong{mAction}: Assign the \sphinxcode{\sphinxupquote{PDColorConvertActionType}} variable
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Assign the following values to the PDColorConvertParams data members:

\end{enumerate}

\sphinxstylestrong{mActions}: Assign the instance of the \sphinxcode{\sphinxupquote{PDColorConvertAction}} data structure to this data member

\sphinxstylestrong{mNumActions}: Assign \sphinxcode{\sphinxupquote{1}}

\sphinxstylestrong{mInks}: Assign \sphinxcode{\sphinxupquote{NULL}}

\sphinxstylestrong{mNumInks}: Assign \sphinxcode{\sphinxupquote{0}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
Invoke the \sphinxcode{\sphinxupquote{PDDocColorConvertPage}} method and pass the following arguments:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{PDDoc}} object that represents the document in which to convert a page. (See \sphinxhref{Plugins\_Documents.html\#50618416\_97094}{Creating a PDDoc object}.)

\item {} 
The instance of the \sphinxcode{\sphinxupquote{PDColorConvertParams}} data structure that describes how color conversions are performed.

\item {} 
An \sphinxcode{\sphinxupquote{ASInt32}} value that specifies the page number to convert. This value is a 0\sphinxhyphen{}based index.

\item {} 
An \sphinxcode{\sphinxupquote{ASProgressMonitor}} object that represents the progress monitor callback. You can pass \sphinxcode{\sphinxupquote{NULL}} if you do not want to provide a progress monitor callback.

\item {} 
The data element to pass to the progress monitor callback. You can pass \sphinxcode{\sphinxupquote{NULL}} if you do not want to provide a progress monitor callback.

\item {} 
A \sphinxcode{\sphinxupquote{PDColorConvertReportProc}} object that represents the reporting callback. You can pass \sphinxcode{\sphinxupquote{0}} to indicate that there is no reporting callback.

\item {} 
The data element to pass to the reporting callback. You can pass \sphinxcode{\sphinxupquote{NULL}} if you do not want to provide a reporting callback.

\item {} 
The address of an \sphinxcode{\sphinxupquote{ASBool}} variable. If a conversion is made to the specified page, \sphinxcode{\sphinxupquote{true}} is assigned.

\end{itemize}

\end{enumerate}

The following code example converts a page in a PDF document to Apple RGB.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{the} \PYG{n}{color} \PYG{n}{parameters}
\PYG{n}{PDColorConvertParams} \PYG{n}{myColorParams}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{the} \PYG{n}{color} \PYG{n}{actions}
\PYG{n}{PDColorConvertAction} \PYG{n}{myAction}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{an} \PYG{n}{AC\PYGZus{}Profile} \PYG{n+nb}{object}
\PYG{n}{AC\PYGZus{}Profile} \PYG{n}{prof}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Define} \PYG{n}{AppleRGB} \PYG{k}{as} \PYG{n}{the} \PYG{n}{profile} \PYG{n}{to} \PYG{n}{use}
\PYG{n}{ACProfileFromCode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{prof}\PYG{p}{,} \PYG{n}{AC\PYGZus{}Profile\PYGZus{}AppleRGB}\PYG{p}{)}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Declare} \PYG{n}{a} \PYG{n}{PDColorConvertActionType} \PYG{n}{variable}
\PYG{n}{PDColorConvertActionType} \PYG{n}{actionType} \PYG{o}{=}  \PYG{n}{kColorConvConvert}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Populate} \PYG{n}{the} \PYG{n}{PDColorConvertAction} \PYG{n}{data} \PYG{n}{members}
\PYG{n}{myAction}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mMatchAttributesAny} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{myAction}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mMatchSpaceTypeAny} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{myAction}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mMatchIntent}\PYG{o}{=} \PYG{n}{AC\PYGZus{}UseProfileIntent}\PYG{p}{;}
\PYG{n}{myAction}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mConvertProfile}\PYG{o}{=}\PYG{n}{prof} \PYG{p}{;}
\PYG{n}{myAction}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mEmbed} \PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{myAction}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mPreserveBlack} \PYG{o}{=} \PYG{n}{false}\PYG{p}{;}
\PYG{n}{myAction}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mUseBlackPointCompensation}\PYG{o}{=} \PYG{n}{true}\PYG{p}{;}
\PYG{n}{myAction}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mAction} \PYG{o}{=} \PYG{n}{actionType}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Populate} \PYG{n}{the} \PYG{n}{PDColorConvertParams} \PYG{n}{pointer}
\PYG{n}{myColorParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mActions}\PYG{o}{=}\PYG{n}{myAction}\PYG{p}{;}
\PYG{n}{myColorParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNumActions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{myColorParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mInks}\PYG{o}{=} \PYG{n}{NULL}\PYG{p}{;}
\PYG{n}{myColorParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mNumInks}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Convert} \PYG{n}{the} \PYG{n}{second} \PYG{n}{page} \PYG{n}{to} \PYG{n}{Apple} \PYG{n}{RGB}
\PYG{n}{PDDocColorConvertPage} \PYG{p}{(}\PYG{n}{theDoc}\PYG{p}{,} \PYG{n}{myColorParams}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,} \PYG{n}{NULL}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{NULL}\PYG{p}{,}\PYG{n}{false}\PYG{p}{)}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/}\PYG{n}{Deallocate} \PYG{n}{the} \PYG{n}{AC\PYGZus{}Profile} \PYG{n+nb}{object}
\PYG{n}{ACUnReferenceProfile}\PYG{p}{(}\PYG{n}{prof}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For information about the APIs included in the AcroColor extended API, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{PDF Optimizer API}
\label{\detokenize{Plugins_ExtendedAPI:pdf-optimizer-api}}
PDF Optimizer API is part of the AV layer and is exported using the AcroView HFT. You use this API to work with the PDF Optimizer tool, which optimizes an active PDF document and then saves it using the \sphinxcode{\sphinxupquote{PDDocSaveWithParams}} method to a specified location. The PDF Optimizer API is available with Acrobat Pro and Acrobat Pro Extended, but not with Acrobat Standard or with Adobe Reader.

Using this API, you can reduce the size of bulky PDF files and run Distiller optimizations on PDF files without having to print them. Avoiding the print route enables you to retain bookmarks, tags, links, and so on. You can also make PDF files compatible with specific versions of Acrobat.

You can invoke the \sphinxcode{\sphinxupquote{AVDocSaveOptimized}} method to run the PDF Optimizer tool on a specified PDF document. An optimized document is created using the settings specified in the \sphinxcode{\sphinxupquote{PDFOptParams}} structure. The optimized document is saved to disk at the location specified in the parameter’s structure. If the operation is successful, the active document is closed and the optimized document is opened for viewing. If the operation fails, the active document remains open.

The \sphinxcode{\sphinxupquote{AVDoc}} object passed to the proc should not be dirty. PDF Optimizer is unavailable in external windows like those of a web browser, so the \sphinxcode{\sphinxupquote{AVDoc}} object should not be from a document open in an external window. The document should not be of a version greater than the default PDF version of the Acrobat application.

When you invoke the \sphinxcode{\sphinxupquote{AVDocSaveOptimized}} method, pass the following arguments:
\begin{itemize}
\item {} 
An \sphinxcode{\sphinxupquote{AVDoc}} object that represents the PDF document to optimize.

\item {} 
An instance of a \sphinxcode{\sphinxupquote{PDFOptParams}} data structure. (See the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.)

\end{itemize}


\chapter{Creating an Adobe Reader plugin}
\label{\detokenize{Plugins_ReaderPlug:creating-an-adobe-reader-plugin}}\label{\detokenize{Plugins_ReaderPlug::doc}}
Developing for Reader requires that you:
\begin{itemize}
\item {} 
Set up definitions for your plugin project

\item {} 
Obtain the public key that Adobe uses to create your Adobe Integrated Key

\item {} 
Apply that key to a plugin.

\end{itemize}

The following diagram illustrates the development and contractual tasks required to develop and enable a plugin to work with Adobe Reader. The gray\sphinxhyphen{}filled boxes indicate tasks that Adobe performs.

\noindent\sphinxincludegraphics{{tasks}.png}


\section{Configuring preprocessor definitions}
\label{\detokenize{Plugins_ReaderPlug:configuring-preprocessor-definitions}}
Before building an Adobe Reader plugin, you must set up your project properties with preprocessor definitions for \sphinxcode{\sphinxupquote{READER\_PLUGIN}}.

A common cause of difficulty when Reader\sphinxhyphen{}enabling a plugin is that the plugin attempts to acquire one or more Host Function Tables (HFTs) during startup that are not available within Adobe Reader. To avoid this problem on Windows and Mac OS, ensure that the \sphinxcode{\sphinxupquote{READER\_PLUGIN}} symbol is defined. With this symbol defined, only those HFTs available in Adobe Reader are acquired. (See \sphinxhref{Plugins\_Hft.html\#50618412\_37928}{Working with Host Function Tables}.)

To define the READER\_PLUGIN symbol in a Mac OS project:

Add the \sphinxcode{\sphinxupquote{READER\_PLUGIN}} symbol to the Xcode project\sphinxhyphen{}level build settings by selecting the plugin project in the Groups \& Files pane and opening the Project Inspector. On the Build tab, under the GCC 4.0 Preprocessing settings, add \sphinxcode{\sphinxupquote{READER\_PLUGIN=1}} to the Preprocessor Macros setting.

To define the READER\_PLUGIN symbol in a Visual C++ project (Windows):

To define the READER\_PLUGIN symbol in a Win32 project:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Locate the \sphinxcode{\sphinxupquote{AcroDspOptions.rsp}} file in the SDK’s \sphinxcode{\sphinxupquote{/PluginSupport/Samples}} directory.

\item {} 
Open the \sphinxcode{\sphinxupquote{AcroDspOptions.rsp}} file in a text editor.

\item {} 
Change ACRO\_SDK\_LEVEL to 0x000A0000 from 0x00090000

\item {} 
Remove the \sphinxcode{\sphinxupquote{AcroColorHFT}} define by removing the following line from the file:

\end{enumerate}

\sphinxcode{\sphinxupquote{/D PI\_ACROCOLOR\_VERSION=0x00060000}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Add the READER\_PLUGIN define by adding the following to the file:

\end{enumerate}

\sphinxcode{\sphinxupquote{/D READER\_PLUGIN}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
Save the \sphinxcode{\sphinxupquote{AcroDspOptions.rsp}} file.

\item {} 
Open and rebuild your Visual C++ plugin project.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
This change affects all SDK plugins built after the change is made.
\end{sphinxadmonition}


\section{Creating the public and private key pairs}
\label{\detokenize{Plugins_ReaderPlug:creating-the-public-and-private-key-pairs}}
Use the MakeKeys tool to create the public and private key pairs for your plugin.

The MakeKeys tool is a command line (Terminal tool). You can find this tool in the PluginSupport/Tools/Reader\sphinxhyphen{}enabling Tools directory in the Acrobat SDK. You can also download a ZIP file that contains this tool from \sphinxurl{http://www.adobe.com/go/rikla\_tools}.

To create public and private key pairs:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Open a Command Prompt (Windows) or Terminal (Mac OS).

\item {} 
Go to the directory that contains the MakeKeys tool.

\item {} 
Run the MakeKeys tool, providing it with the following parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}kp}} option followed by the name of the file in which to store the key pair. The directory must already exist. The file name cannot exceed the platform limitations on file name lengths.

\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}pk}} option followed by the name of the file in which to store the public key. The directory must already exist. The file name cannot exceed the platform limitations on file name lengths.

\item {} 
A random string that you create. The MakeKeys tool uses the string to generate a random number. The random string must contain only letters and digits. There is no limit on the length of the string.

\end{itemize}

\end{enumerate}

The following example command line shows the options and parameters you supply to the MakeKeys tool. The italics in the command line indicate placeholders that you must replace with meaningful values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MakeKeys} \PYG{o}{\PYGZhy{}}\PYG{n}{kp} \PYG{n}{KeyPairFileName} \PYG{o}{\PYGZhy{}}\PYG{n}{pk} \PYG{n}{PubKeyFileName} \PYG{n}{RandomString}
\end{sphinxVerbatim}

The size of the resulting key pair file is approximately 450 bytes. The size of the public key pair file is approximately 98 bytes.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Submit the public key file to Adobe using the PDF form that you received by email, as described in ` <Plugins\_ReaderPlug.html\#50618405\_28317>`\_\_.

\end{enumerate}


\section{Enabling the plugin for Adobe Reader}
\label{\detokenize{Plugins_ReaderPlug:enabling-the-plugin-for-adobe-reader}}
After receiving the Reader Integrated Key from Adobe, use the SignPlugin tool to enable the plugin for Adobe Reader.

The SignPlugin tool is a command line (Terminal tool). You can find this tool in the PluginSupport/Tools/Reader\sphinxhyphen{}enabling Tools directory in the Acrobat SDK. You can also download a ZIP file that contains this tool from \sphinxurl{http://www.adobe.com/go/rikla\_tools}.

To enable the plugin for Adobe Reader:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Open a Command Prompt (Windows) or Terminal (Mac OS).

\item {} 
Go to the directory that contains the SignPlugin tool.

\item {} 
Run the SignPlugin tool, providing it with the following parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}kp}} option followed by the location of the file that contains the key pair. This file was produced by the MakeKeys tool. (See \sphinxhref{Plugins\_ReaderPlug.html\#50618405\_51981}{Creating the public and private key pairs}.)

\item {} 
\sphinxcode{\sphinxupquote{\sphinxhyphen{}cf}} option followed by the location of the file that contains the Reader Integrated Key provided by Adobe. (See ` <Plugins\_ReaderPlug.html\#50618405\_28317>`\_\_.)

\item {} 
Location of the plugin.

\end{itemize}

\end{enumerate}

The following example command line shows the options and parameters you supply to the SignPlugin tool. The italics in the command line indicate placeholders that you must replace with meaningful values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{SignPlugin} \PYG{o}{\PYGZhy{}}\PYG{n}{kp}
\PYG{n}{keypairFileName}
 \PYG{o}{\PYGZhy{}}\PYG{n}{cf} \PYG{n}{Reader\PYGZus{}Integrated\PYGZus{}Key\PYGZus{}}
\PYG{n}{FileName}

  \PYG{o}{/}\PYG{n}{MyDirectory}\PYG{o}{/}\PYG{n}{MyPlugin}
\end{sphinxVerbatim}

If SignPlugin is successful, it returns the message: “Plugin.acroplugin successfully Reader Enabled.”

The plugin can now be loaded by Adobe Reader. If you encounter any difficulties, see \sphinxhref{Plugins\_ReaderPlug.html\#50618405\_49958}{Troubleshooting an Adobe Reader plugin}.

\begin{sphinxadmonition}{note}{Note:}
This procedure must be repeated each time the plugin is built.
\end{sphinxadmonition}

The SignPlugin has been been upgraded to a 64 Bit executable to support running on Mac OS Catalina.

\begin{sphinxadmonition}{tip}{Tip:}
On Mac OS, to easily copy paths to the command line, drag files from the Finder window to the Terminal window.
\end{sphinxadmonition}


\section{Troubleshooting an Adobe Reader plugin}
\label{\detokenize{Plugins_ReaderPlug:troubleshooting-an-adobe-reader-plugin}}
There are some issues that can cause a plugin not to load in Adobe Reader. The most common issues are documented here. If the problem persists, contact Acrobat Developer Support.


\subsection{Plugin appears to be ignored by Adobe Reader}
\label{\detokenize{Plugins_ReaderPlug:plugin-appears-to-be-ignored-by-adobe-reader}}
Several problems can cause this symptom:
\begin{itemize}
\item {} 
The plugin was compiled without the \sphinxcode{\sphinxupquote{READER\_PLUGIN}} symbol being defined (Windows and Mac OS platforms only).

\end{itemize}

A common cause of difficulty when enabling a Adobe Reader plugin is that the plugin attempts to acquire one or more HFTs during startup that are not available in Adobe Reader. To avoid this problem on Windows and Mac OS, ensure that the \sphinxcode{\sphinxupquote{READER\_PLUGIN}} symbol is defined. (See \sphinxhref{Plugins\_ReaderPlug.html\#50618405\_81765}{Setting up your project with preprocessor definitions}.)

With this symbol defined, only those HFTs available in Adobe Reader are acquired. For information about an HFT, see \sphinxhref{Plugins\_Hft.html\#50618412\_37928}{Working with Host Function Tables}.
\begin{itemize}
\item {} 
The Certified Plugins Only preference is set (Windows and Mac OS platforms only).

\end{itemize}

Adobe Reader recognizes only Adobe plugins as certified.

Ensure that the Certified Plugins Only option is not selected in the Options Preferences dialog box.
\begin{itemize}
\item {} 
The plugin was not correctly enabled.

\end{itemize}

The resources file sent by Adobe may have been corrupted during delivery. Verify that the file sizes match those documented in the previous sections. If the public/private key pair or public key files are corrupt, you must regenerate new files and request a new Reader Integrated Key from Adobe. If the file that contains the key is corrupt, you must request a new Reader Integrated Key from Adobe, using the existing public key file.


\subsection{Adobe Reader error messages}
\label{\detokenize{Plugins_ReaderPlug:adobe-reader-error-messages}}
The following are the most commonly received error messages:
\begin{itemize}
\item {} 
“There was an error while loading the plugin name.api. The plugin is incompatible with this version of the viewer.”

\item {} 
“There was an error while loading the plugin name.api. The plugin failed to initialize.”

\item {} 
“There was an error while loading the plugin ‘ \sphinxstyleemphasis{your plugin name} ‘. Two plugins are attempting to register with the same name.”

\end{itemize}

The first error is displayed if the plugin returns \sphinxcode{\sphinxupquote{false}} from the \sphinxcode{\sphinxupquote{PISetupSDK}} method (defined in PIMain). The method returns \sphinxcode{\sphinxupquote{false}} if the plugin attempts to acquire an HFT that is not available. (See \sphinxhref{Plugins\_Hft.html\#50618412\_37928}{Working with Host Function Tables}.)


\chapter{Reader Plugins}
\label{\detokenize{Reader_Plugins:reader-plugins}}\label{\detokenize{Reader_Plugins::doc}}
The Acrobat core and extended APIs allow you to write plugins that integrate with Adobe Reader. For details, see this guide and the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.


\section{Reader enablement}
\label{\detokenize{Reader_Plugins:reader-enablement}}
Any plugins written for Adobe Reader must be Reader\sphinxhyphen{}enabled, which means that you will need to obtain permission and licensing from Adobe Systems.

When developing a Reader\sphinxhyphen{}enabled plugin, follow the steps described in ` <../../../../../Common/docs\_fm/PluginAppsDeveloperGuide/Plugins\_ReaderPlug.html\#11144>`\_\_ to make specific changes to your plugin code in order for Adobe Reader to recognize and load it. For information on obtaining a license key for enabling your Reader plugin, see the site for the Acrobat DC Reader Integration Key License (RIKLA) Program at \sphinxurl{http://www.adobe.com/go/rikla\_program}.

A Reader\sphinxhyphen{}enabled plugin is a dynamically linked extension to Adobe Reader created using C/C++ APIs, and can be developed for any supported platform:
\begin{itemize}
\item {} 
DLLs on Windows (using the extension \sphinxcode{\sphinxupquote{.api}} )

\item {} 
Shared libraries (code fragments) on Mac OS X

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Don’t confuse \sphinxstyleemphasis{Reader enablement} with \sphinxstyleemphasis{rights\sphinxhyphen{}enabled PDF}. Reader enablement enables a plugin to work with Adobe Reader. A rights\sphinxhyphen{}enabled PDF turns on additional user features in Adobe Reader, such as the ability to save forms offline.
\end{sphinxadmonition}


\section{APIs available for Adobe Reader}
\label{\detokenize{Reader_Plugins:apis-available-for-adobe-reader}}
Host Function Tables (HFTs) are tables of function pointers, essentially providing a means by which plugins call methods in Adobe Reader. The following HFTs are available for development with Adobe Reader:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{AcroSupport}}

\item {} 
\sphinxcode{\sphinxupquote{AcroView}}

\item {} 
\sphinxcode{\sphinxupquote{AcroViewSweetPea}}

\item {} 
\sphinxcode{\sphinxupquote{ASExtra}}

\item {} 
\sphinxcode{\sphinxupquote{Catalog}}

\item {} 
\sphinxcode{\sphinxupquote{Cos}}

\item {} 
\sphinxcode{\sphinxupquote{PDModel}}

\item {} 
\sphinxcode{\sphinxupquote{ASExtra}}

\item {} 
\sphinxcode{\sphinxupquote{PDSRead}}

\item {} 
\sphinxcode{\sphinxupquote{AcroSupport}}

\item {} 
\sphinxcode{\sphinxupquote{Core}}

\item {} 
\sphinxcode{\sphinxupquote{Forms}}

\item {} 
\sphinxcode{\sphinxupquote{TTS}}

\item {} 
\sphinxcode{\sphinxupquote{DigSigHFT}}

\item {} 
\sphinxcode{\sphinxupquote{AcroHLS}}

\item {} 
\sphinxcode{\sphinxupquote{PubSecHFT}}

\item {} 
\sphinxcode{\sphinxupquote{Search}}

\item {} 
\sphinxcode{\sphinxupquote{WebLink}}

\end{itemize}

Additional details reside in the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}