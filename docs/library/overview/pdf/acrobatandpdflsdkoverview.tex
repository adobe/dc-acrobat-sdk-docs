%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,12pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}

        \usepackage{tocloft}
        \usepackage{tabularx}
        \usepackage{titlesec}
        \usepackage{titling}
        \usepackage{fancyhdr}
        \pagestyle{fancy}
        \usepackage{graphicx}
        \usepackage{fontspec}
        \setmainfont{AdobeClean-Regular}
        \makeatletter
    \fancypagestyle{normal}{
        \fancyhf{}
        \fancyfoot[LE,RO]{{\py@HeaderFamily\thepage}}
        \fancyfoot[LO,RE]{{\textcopyright\ 2021, Adobe Inc.}}
        \fancyhead[LE,RO]{{\py@HeaderFamily \@title\sphinxheadercomma\py@release}}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0.4pt}
    }
    \fancypagestyle{plain}{
        \fancyhf{}
        \fancyfoot[LE,RO]{{\py@HeaderFamily\thepage}}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0.4pt}
        \fancyfoot[LO,RE]{{\textcopyright\ 2021, Adobe Inc.}}
    }
\makeatother
    

\title{Acrobat and PDFL SDK Overview}
\date{Jun 20, 2022}
\release{}
\author{unknown}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}

    \begin{titlepage}
        \begin{figure}[h]
        \centering{\includegraphics[scale=1.5]{../images/adobelogo.png}}
        \end{figure}
        \centering
        \vspace*{40mm}
        \textbf{\Huge Acrobat and PDFL SDK Overview}

        \vspace{15mm}
        \Large \textbf{{This PDF is programmatically generated: Review copy only}}
        \vfill
        \small \textcopyright\ 2022, Adobe Inc.
    \end{titlepage}
    \clearpage
    \tableofcontents
    \clearpage
    
\pagestyle{plain}

\pagestyle{normal}
\phantomsection\label{\detokenize{toc::doc}}





\chapter{Acrobat and PDFL SDK Overview}
\label{\detokenize{index:acrobat-and-pdfl-sdk-overview}}\label{\detokenize{index::doc}}
The Acrobat SDK is a set of tools that help you develop software that interacts with Acrobat technology. The SDK contains header files, type libraries, simple utilities, sample code, and documentation. These tools provide several methods for developing software that integrates with Acrobat products, including JavaScript, plugins, and interapplication communication. These assets should help you design and develop projects such as:
\begin{itemize}
\item {} 
External applications that communicate with and control Acrobat DC and Acrobat Reader.

\item {} 
Scripts written in JavaScript that control Acrobat DC and Acrobat Reader.

\item {} 
Plug\sphinxhyphen{}ins that extend Acrobat product functionality.

\end{itemize}


\section{Developer support}
\label{\detokenize{index:developer-support}}
The Acrobat Developer Support team supports software development with the Acrobat DC SDK’s core APIs. Developers can purchase support via the \sphinxhref{https://helpx.adobe.com/ie/support/programs/cc-exchange-developer-support.html}{Adobe Creative Cloud Exchange Developer Support program} . Supported SDK development activities include those for which the product is designed, tested, and licensed. Acrobat Developer Support does not support use cases that do not involve the Acrobat core API.

Only the last two major SDK versions with interim updates are eligible for support.

\begin{sphinxadmonition}{note}{Note:}
For non\sphinxhyphen{}programmatic issues, such as questions about installing, using, customizing, or deploying Acrobat, contact \sphinxhref{https://helpx.adobe.com/uk/contact/what-contact-options.html}{Acrobat Technical Support}
\end{sphinxadmonition}




\section{Licensing and distribution}
\label{\detokenize{index:licensing-and-distribution}}
Some of the Acrobat products may be licensed for commercial redistribution.

Products built around Acrobat DC products must comply with the Acrobat End\sphinxhyphen{}User License Agreement (EULA). For example, customers who purchase third\sphinxhyphen{}party developer products that use Acrobat must still comply with the Acrobat EULA.


\subsection{Acrobat Reader}
\label{\detokenize{index:acrobat-reader}}
You may distribute Acrobat Reader, subject to the terms set forth in the license agreement. However, you must use the installer that comes with Acrobat Reader. You may invoke the Acrobat Reader installer from your installer, but the Acrobat Reader installer must remain intact and the End User License Agreement (EULA) must be displayed at first use. For information on customizing the Acrobat Reader installer, see \sphinxhref{apxDevFAQ.html\#94789}{How can I customize the Acrobat installer?}

If you would like to distribute Acrobat Reader, see the Acrobat Reader distribution page given below in \sphinxhref{apxDevFAQ.html\#44820}{Additional resources}.




\subsection{Additional resources}
\label{\detokenize{index:additional-resources}}
Acrobat Reader distribution: \sphinxurl{http://www.adobe.com/products/acrobat/distribute.html?readstep}

Volume software licensing: \sphinxurl{http://www.adobe.com/aboutadobe/openoptions/main.html}




\subsection{Technical and licensing limitations}
\label{\detokenize{index:technical-and-licensing-limitations}}
The following is a list of Acrobat SDK uses that are not supported. Most activities are identified as \sphinxstyleemphasis{technically infeasible} and/or \sphinxstyleemphasis{contrary to licensing} .
\begin{itemize}
\item {} 
Use of any Acrobat product in a multithreaded way ( \sphinxstyleemphasis{technically infeasible} ).

\end{itemize}

Any multithreaded access to the Acrobat core API is likely to crash or hang the application. Acrobat makes the following methods available that can help a plug\sphinxhyphen{}in or application manage its thread’s access to the Acrobat core API, as documented in the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AVAppRegisterNotification}
 \PYG{n}{AVAppRegisterIdleProc}
\end{sphinxVerbatim}

When registering for a notification, the method is passed a function to be called by the Acrobat viewer when the event occurs. Registering for an \sphinxcode{\sphinxupquote{IdleProc}} calls the function when nothing else is occurring. All notifications and \sphinxcode{\sphinxupquote{IdleProcs}} are queued and called in order. Registering for notifications of events or \sphinxcode{\sphinxupquote{IdleProcs}} can help a multithreaded application ensure that Acrobat is not accessed by multiple threads simultaneously; however, it is still the application’s responsibility to manage its threads that access Acrobat.
\begin{itemize}
\item {} 
Use of any Acrobat product as a server process accessed by multiple clients, unless it is specifically stated in product documentation as designed and licensed for such purpose ( \sphinxstyleemphasis{technically infeasible} | \sphinxstyleemphasis{contrary to licensing} ).

\end{itemize}

Unless specifically stated in the product documentation and licensing agreement, Acrobat products are not designed, tested, or licensed for this purpose. This use is in violation of the licensing restrictions, as described in the End User License Agreement displayed during Acrobat installation and is not supported by Acrobat Developer Support.
\begin{itemize}
\item {} 
Use of Distiller as a Windows NT service ( \sphinxstyleemphasis{technically infeasible} ).

\end{itemize}

Acrobat Distiller requires the ability to open a window on the desktop to run. It is not possible to use Distiller as a Windows NT service.

\begin{sphinxadmonition}{warning}{Warning:}
For customers needing this capability, Acrobat Professional DC 7 introduced support for \sphinxstyleemphasis{watched folders} . This same support is also present in Acrobat Pro Extended 10. When Distiller finds a PostScript file located in the In folder of a watched folder, it converts the file to PDF and then moves the PDF (and usually the PostScript file and any associated log file) to the Out folder.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
Use of \sphinxcode{\sphinxupquote{MenuItemExecute}} to bring up Acrobat DC dialog boxes when a PDF file is displayed in an external window using OLE automation ( \sphinxstyleemphasis{technically infeasible} ).

\end{itemize}

Due to problems of managing window focus, using the Acrobat DC dialog boxes (using \sphinxcode{\sphinxupquote{MenuItemExecute}} ) when a PDF file is displayed in an external window using OLE automation is not supported. The actions executed by the dialog box may or may not affect the intended PDF file and there can be problems of windows not redrawing properly. The only supported workaround is to use the OLE automation methods or to develop a plug\sphinxhyphen{}in to achieve any functionality not available in the OLE API to Acrobat DC. The \sphinxhref{http://adobe.com/go/acrobat\_developer}{Adobe Reader Integration Key License Agreement} only permits displaying in an external window when Acrobat DC is used, not Acrobat Reader.
\begin{itemize}
\item {} 
Use of the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} to develop a third\sphinxhyphen{}party application that writes PDF files without the use of Acrobat DC products.

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
The Adobe PDF Library, available under license, can be used to simplify development of these types of applications.
\end{sphinxadmonition}

We do not provide support to developers who are creating their own PDF generation capabilities without the use of Adobe products. The \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} is the best resource for this kind of development. The use of Adobe products to create PDF files as a benchmark for your own development is recommended. Acrobat Developer Support will not debug PDF files created with non\sphinxhyphen{}Adobe products. Questions regarding the completeness or accuracy of the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} will be answered. The \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} is available for free download from the \sphinxhref{http://www.adobe.com/go/acrobat\_developer}{Acrobat Developer Center} .
\begin{itemize}
\item {} 
Interapplication communication (IAC) between a plug\sphinxhyphen{}in and a third\sphinxhyphen{}party application.

\end{itemize}

Interapplication communication between a plug\sphinxhyphen{}in and a third\sphinxhyphen{}party application does not differ significantly from interapplication communication between two stand\sphinxhyphen{}alone applications. Documentation for your development platform’s API and development environment are the best resources for this type of development. The Acrobat SDK contains two samples that can serve as examples.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DDEServer}} demonstrates DDE communication between a stand\sphinxhyphen{}alone application and a plug\sphinxhyphen{}in.

\item {} 
\sphinxcode{\sphinxupquote{ExternalWindow}} uses Windows messaging to communicate with a stand\sphinxhyphen{}alone application.

\end{itemize}

One typical difficulty for developers occurs when a multithreaded stand\sphinxhyphen{}alone application communicates with a plug\sphinxhyphen{}in. See \sphinxhref{Overview\_GettingStarted.html\#81443}{Developing for Acrobat Reader}.
\begin{itemize}
\item {} 
Use of platform API methods or the API methods of applications other than Acrobat DC.

\end{itemize}

Acrobat Developer Support can help you with the API to the Acrobat family of products. Questions regarding the use of platform API methods should be directed to the manufacturer of your operating system.
\begin{itemize}
\item {} 
Use of the ActiveX® control or Netscape plug\sphinxhyphen{}in to display a PDF file in an external application besides Internet Explorer or Netscape. The methods used by Acrobat DC to display a PDF file in Netscape and Internet Explorer are intended only for use with these browsers. Use of the ActiveX Control and Netscape plug\sphinxhyphen{}in installed by Acrobat Reader is not licensed to other applications. Development with these interfaces is not supported and no documentation is available.

\item {} 
Automating the import of image files using the Import plug\sphinxhyphen{}in to Acrobat DC ( \sphinxstyleemphasis{technically infeasible} ).

\end{itemize}

The Import plug\sphinxhyphen{}in to Acrobat does not provide an API that allows it to be called from a plug\sphinxhyphen{}in or another application. Executing the Import Image menu item with \sphinxcode{\sphinxupquote{MenuItemExecute}} brings up a dialog box requiring user input.




\section{Samples provided with the Acrobat SDK}
\label{\detokenize{index:samples-provided-with-the-acrobat-sdk}}
The Acrobat SDK provides a large number of sample applications, plug\sphinxhyphen{}ins, and scripts to demonstrate how to use the SDK technologies. Reviewing the samples may guide you in choosing JavaScript, plug\sphinxhyphen{}ins, or IAC functionality for a particular implementation. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_samplesguide}{Acrobat SDK Samples Guide} .




\section{Developing for Acrobat Reader}
\label{\detokenize{index:developing-for-acrobat-reader}}

\subsection{Acrobat vs. Reader}
\label{\detokenize{index:acrobat-vs-reader}}
Acrobat provides a full\sphinxhyphen{}featured development environment that includes the entire Acrobat core API. Like Acrobat, the primary technologies for creating software to extend or customize Adobe Reader are JavaScript, interapplication communication, and plug\sphinxhyphen{}ins. There are some small differences between the public APIs available in Acrobat DC and Acrobat Reader. Moreover, the APIs that may be used for Acrobat Reader are limited technically and legally.

Both Acrobat and Acrobat Reader accept plug\sphinxhyphen{}ins. The primary difference between the two is that, in general, Acrobat Reader can neither make changes to a file nor save a file. API methods that change a file in such a way that a save would be required are not available in Acrobat Reader.


\subsection{Acrobat Reader plug\sphinxhyphen{}in guidelines}
\label{\detokenize{index:acrobat-reader-plug-in-guidelines}}
If you are considering plug\sphinxhyphen{}ins for Acrobat Reader, remember the following:
\begin{itemize}
\item {} 
You may not develop an Acrobat Reader plug\sphinxhyphen{}in without approval from Adobe. There is a web\sphinxhyphen{}based application where you describe your plug\sphinxhyphen{}in and submit the information to Adobe; Adobe will then review it and let you know whether your application has been approved. The application and the Acrobat Reader Integration Key Licensing Agreement can only be submitted as a web form and are found at \sphinxurl{http://www.adobe.com/go/acrobat\_developer} .

\item {} 
There is a fee to obtain the enabling key.

\item {} 
There is a restricted set of APIs available in Acrobat Reader.

\item {} 
For information on how to access the Host Function Tables (HFTs) available to Acrobat Reader plug\sphinxhyphen{}ins and how to enable your plugin, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide.}

\end{itemize}


\subsection{Reader enabled plugins}
\label{\detokenize{index:reader-enabled-plugins}}
Acrobat Reader only accepts “Reader\sphinxhyphen{}enabled” plug\sphinxhyphen{}ins, which can access a subset of the APIs available to Acrobat DC. Certain APIs are available to a Reader\sphinxhyphen{}enabled plug\sphinxhyphen{}in if the PDF document has been assigned additional usage rights (rights\sphinxhyphen{}enabled). With a rights\sphinxhyphen{}enabled PDF document, the free and ubiquitous Acrobat Reader c an be used to download, save, fill in, digitally sign, and submit electronic PDF forms.

Though the APIs available for Adobe Reader are limited, additional APIs can be used for a given PDF document if that document is rights\sphinxhyphen{}enabled, meaning that it has additional usage rights. The extra functionality makes the following activities possible:
\begin{itemize}
\item {} 
Saving forms with results offline

\item {} 
Connecting forms to databases or online services

\item {} 
Attaching files and media clips

\item {} 
Saving copies of documents with changes intact

\item {} 
Submitting completed documents electronically

\item {} 
Digitally signing documents

\item {} 
Sharing documents with others to review and add comments using intuitive markup tools such as electronic sticky notes, highlight, and text strikethrough.

\end{itemize}


\section{SDK technologies and options}
\label{\detokenize{index:sdk-technologies-and-options}}
You can develop software that integrates with Acrobat DC and Acrobat Reader in three ways: JavaScript, plug\sphinxhyphen{}ins, and IAC.

Based on your application’s requirements, choose the appropriate technologies for development. In some situations, the desired functionality is only available using one technology. In other situations, you can choose between two or more technologies. For example, you can add menu items to Acrobat DC using either JavaScript or a plug\sphinxhyphen{}in. You can also use more than one technology in a single application or single document. For example, you can use both plug\sphinxhyphen{}ins and JavaScript to implement a particular feature.

Options include:
\begin{itemize}
\item {} 
\sphinxstylestrong{JavaScript} — Write scripts, either in an individual PDF document or externally, to extend product functionality.

\item {} 
\sphinxstylestrong{Plug\sphinxhyphen{}ins} — Create plug\sphinxhyphen{}ins that are dynamically linked to and extend product functionality.

\item {} 
\sphinxstylestrong{Interapplication communication} — Write a separate application process that uses interapplication communication (IAC) to control the product. DDE and OLE are supported on Microsoft Windows, and Apple events/AppleScript on Mac OS.

\item {} 
\sphinxstylestrong{PDF manipulation without Acrobat} \sphinxhref{http://www.adobe.com/go/pdflibrary}{: You can also use the PDF Library (PDFL) to develop applications that create and manipulate PDF documents but do not interact with Acrobat. For more information, see} \sphinxhref{Overview\_GettingStarted.html\#66717}{Adobe PDF Library} .

\end{itemize}




\subsection{JavaScript}
\label{\detokenize{index:javascript}}
Through its JavaScript extensions, Acrobat DC exposes much of its functionality and its plug\sphinxhyphen{}ins to the document author. The JavaScript objects, properties and methods can also be accessed through Visual Basic or C\# to automate the processing of PDF documents.

Acrobat DC defines several objects that allow your code to interact with the Acrobat DC application, a PDF document, or fields within a PDF document. The most commonly used objects control the Acrobat DC or Acrobat Reader application, the JavaScript console, the PDF document, SOAP web services, databases, security, searches, and JavaScript events.

JavaScript can be applied at a variety of levels. Each of the levels represents a context in which processing occurs, which affects when the scripts are loaded and how they are accessed inside and outside documents.

The placement of a script at a given level also determines its reusability. For example, folder level scripts are available within all documents, document level scripts are available to all fields within a given document, and field level scripts are visible only to the fields with which they are associated.




\subsection{Plug\sphinxhyphen{}ins}
\label{\detokenize{index:plug-ins}}
Plug\sphinxhyphen{}ins are dynamically\sphinxhyphen{}linked extensions to Acrobat DC or Acrobat Reader. They can hook in to the user interface in a number of ways and can register to be called when a variety of events occur in the application.

A plug\sphinxhyphen{}in is written in ANSI C/C++ and uses the Acrobat DC public APIs. It can add functionality to Acrobat Pro Extended, Acrobat Professional DC, Acrobat DC Standard, or Acrobat Reader. A plug\sphinxhyphen{}in program file goes into a Plug\_ins folder or directory and is initialized during Acrobat DC or Acrobat Reader startup.

There are three types of plug\sphinxhyphen{}ins:
\begin{itemize}
\item {} 
\sphinxstylestrong{Regular Acrobat DC plug\sphinxhyphen{}ins} — These plug\sphinxhyphen{}ins run on Acrobat Professional DC and Acrobat DC Standard. Plug\sphinxhyphen{}ins for Acrobat Professional DC can use any of the Acrobat SDK APIs. Plug\sphinxhyphen{}ins for Acrobat DC Standard do not have access to some APIs. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide.}

\item {} 
\sphinxstylestrong{Acrobat Reader\sphinxhyphen{}enabled plug\sphinxhyphen{}ins} — These plug\sphinxhyphen{}ins use a restricted set of APIs. Acrobat Reader\sphinxhyphen{}enabled plug\sphinxhyphen{}ins are developed with permission from Adobe and require special processing to load under Acrobat Reader. Plug\sphinxhyphen{}ins for Acrobat Reader can use additional APIs if the PDF document has additional usage rights.

\item {} 
\sphinxstylestrong{Certified plug\sphinxhyphen{}ins} — These plug\sphinxhyphen{}ins have undergone extensive testing to ensure that they do not compromise the integrity of Acrobat DC’s security model. A checkbox in the Acrobat DC and Acrobat Reader user interface can be used to ensure that only certified plug\sphinxhyphen{}ins are loaded. Certified plug\sphinxhyphen{}ins can be provided only by Adobe.

\end{itemize}

Plug\sphinxhyphen{}ins are deployed differently on each platform:
\begin{itemize}
\item {} 
Windows: DLLs. Note, however, that plug\sphinxhyphen{}in names must end in .API, not .DLL.

\item {} 
Mac: Code fragments on Mac OS.

\end{itemize}


\subsubsection{Plug\sphinxhyphen{}in development environments}
\label{\detokenize{index:plug-in-development-environments}}
Windows developers can develop plug\sphinxhyphen{}ins using C and C++ with Visual Studio.

There is currently no support for development of plug\sphinxhyphen{}ins using managed languages such as C\# or VB.NET. However, managed languages are supported for use with interapplication communication (IAC). This enables those languages to take full advantage of Acrobat DC’s functionality through use of the JavaScript bridge.

All plug\sphinxhyphen{}ins developed on Mac OS X must use the Mach\sphinxhyphen{}O runtime architecture and must be built as a bundle. Apple Xcode 9.2 is required because SDK projects depend on certain header files that are included with the Xcode development environment.




\subsubsection{Acrobat core API}
\label{\detokenize{index:acrobat-core-api}}
Plug\sphinxhyphen{}ins access and control the resources of the Acrobat application host environment using the Acrobat DC core API. The core API consists of a set of methods that operate on objects. The objects have types and encapsulate their data. This object orientation is a conceptual model, implemented using a standard ANSI C programming interface. Methods are C functions; objects are opaque data types. The core API is supported on Windows and Mac.

The API is organized into several layers.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Layer
&\sphinxstyletheadfamily 
Description
\\
\hline
AV
&
The AV layer, also known as AcroView or AV Model, works with the Acrobat DC or Acrobat Reader application. Its methods allow plug\sphinxhyphen{}ins to manipulate components of the Acrobat DC or Acrobat Reader application itself, such as menus and menu items.
\\
\hline
PD
&
The PD layer, also known as PDModel, provides access to components of PDF documents. Its methods allow plug\sphinxhyphen{}ins to manipulate document components such as document pages and annotations.
\\
\hline
AS
&
The AS layer (a support layer) provides platform\sphinxhyphen{}independent utility functions and allows plug\sphinxhyphen{}ins to override the built\sphinxhyphen{}in file\sphinxhyphen{}handling mechanisms.
\\
\hline
Cos
&
The Cos Object System layer provides access to the building blocks used to construct documents. Cos methods allow plug\sphinxhyphen{}ins to manipulate low\sphinxhyphen{}level data such as dictionary and string objects in a PDF file.

Whenever possible, you should use higher level APIs to access and manipulate PDF files. Though you can use the Cos layer APIs to perform most types of access or manipulation of a PDF file, it can be difficult and requires in\sphinxhyphen{}depth knowledge of PDF file structure.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The core API also includes platform\sphinxhyphen{}specific plug\sphinxhyphen{}in utilities to handle issues that are unique to Windows and Mac. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide.}


\subsubsection{Extended APIs for plug\sphinxhyphen{}ins}
\label{\detokenize{index:extended-apis-for-plug-ins}}
Plug\sphinxhyphen{}ins can expose their own functionality and make it available to other plug\sphinxhyphen{}ins in the same way that Acrobat DC functionality is available through the core API. Acrobat DC uses many plug\sphinxhyphen{}ins to implement features, such as the Search and Digital Signature plug\sphinxhyphen{}ins. In fact, the Acrobat DC architecture encourages the use of plug\sphinxhyphen{}ins to expose APIs for use by other plug\sphinxhyphen{}ins.

API exposure is accomplished through a mechanism called the Host Function Table (HFT). A plug\sphinxhyphen{}in can export an HFT for use by other plug\sphinxhyphen{}ins, and it can import the HFTs of other plug\sphinxhyphen{}ins. The following Adobe plug\sphinxhyphen{}ins export HFTs:
\begin{itemize}
\item {} 
Catalog

\item {} 
Digital Signature

\item {} 
Forms

\item {} 
PDF Consultant

\item {} 
Search

\item {} 
Spelling

\item {} 
Weblink

\item {} 
SaveAsXML

\end{itemize}

For more information on plug\sphinxhyphen{}ins and HFTs, see the the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide} and the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} .


\subsection{JavaScript vs. plugins: pros and cons}
\label{\detokenize{index:javascript-vs-plugins-pros-and-cons}}
While developers writing plug\sphinxhyphen{}ins have direct access to the Acrobat Core API, JavaScript applications tend to be easier to write and implement, since they are developed using the editor and debugger that are included in Acrobat. JavaScript applications are also easier to distribute since they can be included directly within a PDF file, whereas plug\sphinxhyphen{}ins must be placed in the Plug\_ins folder by either an installer or the user. JavaScript for Acrobat can be used across multiple platforms, while a plug\sphinxhyphen{}in must have separate versions for each platform in order to handle certain platform\sphinxhyphen{}specific issues.

In general, plug\sphinxhyphen{}ins allow for more direct control over Acrobat DC than JavaScript. There is a richer set of APIs that you can use from a plug\sphinxhyphen{}in. Since it is interpreted rather than compiled, execution of JavaScript for Acrobat code is slower than plug\sphinxhyphen{}in code. However, the difference tends to be noticeable only in computationally intensive applications, such as a full text search in a large PDF file.


\subsubsection{Implementation comparison}
\label{\detokenize{index:implementation-comparison}}
Comparison of plug\sphinxhyphen{}ins and JavaScript


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{index:section-1}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
Plug\sphinxhyphen{}ins
&\sphinxstyletheadfamily 
JavaScript
\\
\hline
\sphinxstylestrong{Scope}
&
A plug\sphinxhyphen{}in affects all PDF documents viewed by Acrobat DC.
&
JavaScript can affect either a single document or all PDF documents.
\\
\hline
\sphinxstylestrong{Installation and
distribution}
&
Plug\sphinxhyphen{}ins must be placed in the Plug\_ins folder or directory by an installer or by the user.
&
Document\sphinxhyphen{}level JavaScript code is easier to distribute since it can be included directly within the PDF file and does not require an installer. Folder\sphinxhyphen{}level JavaScript code must be placed in the Acrobat DC application JavaScript folder or the user’s JavaScript folder.
\\
\hline
\sphinxstylestrong{Low\sphinxhyphen{}level access}
&
Plug\sphinxhyphen{}ins can access and manipulate low\sphinxhyphen{}level objects in the PDF object model, such as the Cos layer.
&
JavaScript can access a limited set of AV and PD layer objects.
\\
\hline
\sphinxstylestrong{Execution speed}
&
Plug\sphinxhyphen{}ins are compiled and loaded when Acrobat DC initializes.
&
Execution of JavaScript code is slower than plug\sphinxhyphen{}in code because it is interpreted instead of compiled. However, the difference is noticeable only in computation\sphinxhyphen{}intensive applications, such as a full\sphinxhyphen{}text search in a large PDF file.
\\
\hline
\sphinxstylestrong{Ease of
implementation}
&
Plug\sphinxhyphen{}ins are developed in C or C++ and are compiled and linked in the appropriate development environment. You must include all necessary header files for your application.
&
JavaScript scripts are easier to write and implement since they are developed using the editor and debugger that come as part of Acrobat Professional DC. Developers can also use an external editor to create and edit JavaScript code.
\\
\hline
\sphinxstylestrong{Cross\sphinxhyphen{}platform
compatibility}
&
Plug\sphinxhyphen{}ins must be built on different platforms to handle certain platform\sphinxhyphen{}specific issues.
&
JavaScript is cross\sphinxhyphen{}platform compatible.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Feature comparison}
\label{\detokenize{index:feature-comparison}}
Finally, while some JavaScript and plug\sphinxhyphen{}in capabilities overlap, others are only available in JavaScript while others are only available with a plug\sphinxhyphen{}in as summarized in the table below. JavaScript for Acrobat is well\sphinxhyphen{}suited to quickly tasks such as adding user interface capabilities, forms processing, interacting with databases and web services, and so on.

\begin{sphinxadmonition}{tip}{Tip:}
Some of these example tasks, such as SOAP and web services, can in fact be done with a plug\sphinxhyphen{}in by using low\sphinxhyphen{}level APIs. However, this is a time\sphinxhyphen{}consuming approach and requires an in\sphinxhyphen{}depth knowledge of the low\sphinxhyphen{}level APIs.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{index:section-2}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Capability
&\sphinxstyletheadfamily 
JavaScript
&\sphinxstyletheadfamily 
Plug\sphinxhyphen{}in
\\
\hline
Use SOAP and web services
&
Yes
&
No
\\
\hline
Manipulating multimedia
&
Yes
&
No
\\
\hline
Automate email review workflow
&
Yes
&
No
\\
\hline
Search Acrobat Help
&
Yes
&
No
\\
\hline
Use Acrobat security policies
&
Yes
&
No
\\
\hline
Use content stream and other low\sphinxhyphen{}layer access
&
No
&
Yes
\\
\hline
Add content to a PDF file by using a content stream
&
No
&
Yes
\\
\hline
Create new menus or toolbars
&
No
&
Yes
\\
\hline
Create new annotation or action types
&
No
&
Yes
\\
\hline
Modify the ASFixed scaling factor for large PDF file sizes
&
No
&
Yes
\\
\hline
Access platform\sphinxhyphen{}specific services or events
&
No
&
Yes
\\
\hline
Getting and setting wireframe drawing mode
&
No
&
Yes
\\
\hline
Accessing Cos and other low\sphinxhyphen{}layer objects
&
No
&
Yes
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}




\subsection{Interapplication communication}
\label{\detokenize{index:interapplication-communication}}
To take advantage of Acrobat DC functionality from within an external application, use interapplication communication (IAC). Acrobat DC provides support for IAC through OLE automation and DDE on Windows as well as Apple events and AppleScript on Mac OS. Acrobat Reader also supports IAC, but does not support OLE on Windows.

IAC support allows programs to control Acrobat DC or Acrobat Reader in much the same way a user would. You can also use IAC support to render a PDF file into an external application window instead of the Acrobat DC window. The IAC methods and events serve as wrappers for some of the core API calls in the SDK.

On Windows, you can develop IAC applications using Visual Basic .NET, Visual C++ .NET, or Visual C\# .NET. On Mac OS, you develop IAC applications using Xcode. CodeWarrior is not supported.

For more documentation, see the \sphinxhref{http://www.adobe.com/go/acrobat\_developer}{IAC Developer Guide} .


\subsection{Viewing PDF documents from an external application}
\label{\detokenize{index:viewing-pdf-documents-from-an-external-application}}
If your Windows application only views a PDF document and does not need to edit it in any way, use the PDF Browser Controls to view the document from your external VB or C\# application. When you open a document for viewing using the PDF Browser Controls, the document is displayed in the application window. Acrobat DC toolbars are also displayed and can be used with no additional API calls. The toolbars can be hidden. Acrobat DC or Acrobat Reader must be installed for the PDF Browser Controls to work.

You can also use the IAC API to open and view a PDF document. However, when you use the IAC API, no toolbars are displayed. You must place your own buttons with corresponding API calls for standard toolbar tasks such as printing and searching.


\subsection{Controlling Acrobat from an external application}
\label{\detokenize{index:controlling-acrobat-from-an-external-application}}
If you need to do more than just view a PDF document from your application, you can use the IAC API to perform these tasks:
\begin{itemize}
\item {} 
Get annotations, text and form data from a PDF document

\item {} 
Search a PDF document

\item {} 
Manipulate a PDF document, editing and adding content

\end{itemize}

Control Acrobat DC (but not Acrobat Reader) remotely




\subsubsection{Plug\sphinxhyphen{}ins for IAC}
\label{\detokenize{index:plug-ins-for-iac}}
You can extend the functionality of the IAC interfaces by writing plug\sphinxhyphen{}ins that use core API objects that are not already part of the IAC support system. The Acrobat SDK provides a sample that demonstrates this. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_samplesguide}{Acrobat SDK Samples Guide} .


\subsubsection{JavaScript support}
\label{\detokenize{index:javascript-support}}
Acrobat DC provides a rich set of JavaScript programming interfaces that are designed to be used from within the Acrobat DC environment. It also provides a mechanism that allows external clients to access the same functionality from environments such as VB .NET, Visual C++ .NET and Visual C\# .NET.


\subsubsection{Windows support}
\label{\detokenize{index:windows-support}}
Acrobat DC is an OLE server and also responds to a variety of OLE automation messages. You can embed PDF documents into documents created by an application that is an OLE client. Acrobat Reader does not support OLE.

On Windows, you can display a PDF document in applications using simplified browser controls. In this case, the PDF is treated as an ActiveX document, and the interface is available in Acrobat Reader.

Once the PDF document is loaded, you can implement browser controls to perform the following tasks:
\begin{itemize}
\item {} 
Determine which page to display

\item {} 
Control view and zoom modes

\item {} 
Determine whether to display bookmarks, thumbnails, scrollbars, and toolbars

\item {} 
Print pages using various options

\item {} 
Highlight a text selection

\end{itemize}


\subsubsection{Apple event support}
\label{\detokenize{index:apple-event-support}}
The Acrobat DC viewers support Apple events and a number of Apple event objects on Mac OS. IAC support includes some of the objects and events described in \sphinxstyleemphasis{Apple Event Registry: Standard Suites} , as well as Acrobat DC\sphinxhyphen{}specific objects and events.

You can find information on Apple events supported by the Acrobat DC Search plug\sphinxhyphen{}in by referring to the \sphinxstyleemphasis{Acrobat and PDF Library API Reference} . Other plug\sphinxhyphen{}ins supporting additional Apple events are described in \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide} .




\subsection{Adobe PDF Library}
\label{\detokenize{index:adobe-pdf-library}}
The Adobe PDF Library is based on the core technology of the Acrobat DC line of products and offers complete functionality for generating, manipulating, rendering, and printing Adobe PDF documents.

Designed specifically for OEMs, ISVs, system integrators, and enterprise IT developers, the Adobe PDF Library SDK contains a set of functions for developing third\sphinxhyphen{}party solutions and workflows around PDF. The library enables PDF functionality to be seamlessly embedded within applications without the presence of Acrobat DC or Acrobat Reader. It also provides a reliable, accurate, and Adobe\sphinxhyphen{}supported implementation of the latest PDF specification.

There is significant overlap between the functionality provided by the PDF Library SDK and the Acrobat SDK. They differ in providing access to the Acrobat DC user interface:
\begin{itemize}
\item {} 
The Acrobat SDK is designed for Acrobat product environments and allows you to control and interact with the Acrobat DC user interface.

\item {} 
The PDF Library SDK is intended for interaction between PDF and other applications, such as high volume batch processing and PDF generation applications. It does not export methods for creating or managing Acrobat DC user interface elements—that is, the AcroView (AV) layer of the core API.

\end{itemize}

For more documentation, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{IAC Developer Guide} .


\chapter{Sandbox Broker Extensibility}
\label{\detokenize{SandboxBrokerExt:sandbox-broker-extensibility}}\label{\detokenize{SandboxBrokerExt::doc}}
A plug\sphinxhyphen{}in loaded in a sandboxed process executes within the restrictions of the sandbox and it may need to implement a broker to perform any privileged operations or access resources that are blocked by the sandbox. This might require adding to the existing broker APIs to get its features working in the sandbox environment.

Broker extensibility provides a generic plug\sphinxhyphen{}and\sphinxhyphen{}play architecture that would enable extending the existing broker functionality provided by Protected Mode in the app. This architecture allows new features to work seamlessly in the sandbox environment on demand and at run time.


\section{Extending broker APIs at run time}
\label{\detokenize{SandboxBrokerExt:extending-broker-apis-at-run-time}}
The \sphinxcode{\sphinxupquote{sandbox\_pisdk\_client}} and \sphinxcode{\sphinxupquote{sandbox\_pisdk\_server}} libraries have been made available for broker extensibility. Plugins need to link to this library to implement broker extensibility. Doing so allows plug\sphinxhyphen{}ins loaded in sandbox process to extend broker APIs at run time and make IPC calls to the broker process to access the extended functionality.

The following figure illustrates the sandbox plug\sphinxhyphen{}in architecture provided to extend the broker API functionality by individual plug\sphinxhyphen{}ins at run time:

\noindent\sphinxincludegraphics{{sandboxarch}.png}


\section{Components}
\label{\detokenize{SandboxBrokerExt:components}}

\subsection{Plugin (PI)}
\label{\detokenize{SandboxBrokerExt:plugin-pi}}
The plug\sphinxhyphen{}in is loaded in the sandbox process that runs under restricted rights. Every plug\sphinxhyphen{}in that requires some added broker functionality must implement its own plug\sphinxhyphen{}in broker process to implement new broker APIs. These broker APIs can be used only by that plug\sphinxhyphen{}in and are not visible to any other code/module loaded inside the sandbox process. Plugins can use the sandbox plugin SDK for this.


\subsection{Sandbox process}
\label{\detokenize{SandboxBrokerExt:sandbox-process}}
This is the renderer process running in protected mode under restricted rights. All application and plug\sphinxhyphen{}in code runs in this process. It has restricted access to files, registry, processes, window handles etc. It communicates with the broker process over the sandbox\sphinxhyphen{}broker IPC channel to service actions outside the sandbox boundary.


\subsection{Broker process (The broker process running with full rights)}
\label{\detokenize{SandboxBrokerExt:broker-process-the-broker-process-running-with-full-rights}}
This is the broker process which runs with full user rights and imposes policy white lists. It grants access to files, registry, and processes as per policy white list. It implements the broker APIs to service the functionality requested by the sandbox process outside the sandbox boundary. The sandbox process communicates with it over the sandbox\sphinxhyphen{}broker IPC channel.


\subsection{Plugin broker (The plugin broker process that extends the broker APIs at runtime)}
\label{\detokenize{SandboxBrokerExt:plugin-broker-the-plugin-broker-process-that-extends-the-broker-apis-at-runtime}}
This is the plugin broker process which is private to the associated plug\sphinxhyphen{}in. This implements the plug\sphinxhyphen{}in specific broker APIs required for the full functionality of the plug\sphinxhyphen{}in in sandbox environment. We call them extended broker APIs, as they extend the existing broker APIs to fulfill the plug\sphinxhyphen{}in requirements.

The plug\sphinxhyphen{}in, which runs in Protected Mode context, communicates with this process directly over a separate IPC channel, 1 \sphinxhyphen{}> 6 \sphinxhyphen{}> 4, to service additional functionality outside the sandbox boundary which is not provided by broker APIs.

This process is launched by the broker process; it runs with full user rights and independent of the sandbox context. Also, by default it does not honor any policy restrictions or other security mechanisms. Thus it is the plug\sphinxhyphen{}in developer’s responsibility to design and implement it with security in focus; otherwise it can be used to escape the sandbox context.

Also, this binary along with the description (input and output parameters) of the APIs it exposes have to be submitted to Adobe for code signing. Please note that signature of the plug\sphinxhyphen{}in broker executable is verified before launch if the ‘Use only Certified plug\sphinxhyphen{}ins’ is checked, so it is the responsibility of the plug\sphinxhyphen{}in developer to ensure that this is signed otherwise this would just not work.


\subsection{SandboxHFT (Public HFT provided by sandbox for broker extensibility)}
\label{\detokenize{SandboxBrokerExt:sandboxhft-public-hft-provided-by-sandbox-for-broker-extensibility}}
This HFT contains two APIs which can be called by plug\sphinxhyphen{}ins to implement broker extensibility:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SbxAppGetIsSandboxed}} : This public API can be called from any plug\sphinxhyphen{}in that imports SandboxHFT to check whether the app is running with Protected Mode ON or OFF.
The prototype for this API is:
\sphinxcode{\sphinxupquote{ASBool SbxAppGetIsSandboxed(void);}}

\item {} 
\sphinxcode{\sphinxupquote{SbxLaunchPIBrokerExe}} : This is the public API provided by sandbox process to extend broker API at run time. The plug\sphinxhyphen{}in makes a request via the \sphinxcode{\sphinxupquote{SbxLaunchPIBrokerExe}} API to start its plugin broker process and do some initial handshake with it.

\end{itemize}

All the processes placed in \sphinxcode{\sphinxupquote{App Install Directory(app name)plug\_inspi\_brokers}} are white listed. Third party plug\sphinxhyphen{}in developers must place their plugin broker processes at this location and can use this HFT. The prototype for this API is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HANDLE} \PYG{n}{SbxLaunchPIBrokerExe}\PYG{p}{(}
\PYG{n}{const} \PYG{n}{wchar\PYGZus{}t} \PYG{o}{*}\PYG{n}{piBroker} \PYG{o}{/}\PYG{o}{/} \PYG{n}{IN}\PYG{p}{:}\PYG{n}{plugin} \PYG{n}{broker} \PYG{n}{process} \PYG{n}{name}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It takes the plugin broker process name in piBroker as input, looks it up in its process white list, if it succeeds then launches the piBroker process, and finally establishes IPC channel between the plug\sphinxhyphen{}in and piBroker. If everything succeeds, it then returns handle to the underlying IPC mechanism (in this it’s the \sphinxcode{\sphinxupquote{NamedPipe}} ) otherwise INVALID\_HANDLE\_VALUE is returned.

To aid thrid\sphinxhyphen{}party developers in setting up the IPC between plugin and plugin broker process (1 \sphinxhyphen{}> 6 \sphinxhyphen{}> 4), we have provided an API SandboxPISDK::InitSandboxPIBrokerIPCChannel which launches the PI\sphinxhyphen{}broker (by using above HFT function SbxLaunchPIBrokerExe) and sets up the IPC. See \sphinxhref{SandboxBrokerExt.html\#47413}{Building a plug\sphinxhyphen{}in} for more details.

Please note that there’s one more API in this HFT \sphinxhyphen{} SbxLaunchPIBrokerExtn which has been deprecated from A11


\subsection{IPC channel between plugin and plugin broker, 1\sphinxhyphen{}>6\sphinxhyphen{}>4}
\label{\detokenize{SandboxBrokerExt:ipc-channel-between-plugin-and-plugin-broker-1-6-4}}
This is the dedicated IPC channel across which the plug\sphinxhyphen{}in and its plug\sphinxhyphen{}in broker process communicate. The IPC channel is established at run time, when the plugin makes a request via the InitSandboxPIBrokerIPCChannel API, to start its plugin broker process. The broker process looks up in its process white list and launches the requested plugin broker process and establishes the IPC channel. This communication channel bypasses the usual 1 \sphinxhyphen{}> 2 \sphinxhyphen{}> 3 trusted IPC channel between the plugin (in Protected Mode process) and broker process and talks directly to the PI broker process via 1\sphinxhyphen{}>6\sphinxhyphen{}>4.


\subsection{simple\sphinxhyphen{}ipc\sphinxhyphen{}lib and SandboxPISDK}
\label{\detokenize{SandboxBrokerExt:simple-ipc-lib-and-sandboxpisdk}}
\sphinxcode{\sphinxupquote{simple\sphinxhyphen{}ipc\sphinxhyphen{}lib}} : This is a very light weight C++ inter\sphinxhyphen{}process communication library. It is used to communicate over the \sphinxcode{\sphinxupquote{NamedPipe}} . This library needs to be built and linked into both the plugin and the plugin broker.

\sphinxcode{\sphinxupquote{SandboxPISDK}} : plugin developers must use this SDK to implement broker Extensibility for their Plugin. This SDK abstracts out a lot of internal details and has wrappers and macros to aid developers.




\subsection{Building a plug\sphinxhyphen{}in}
\label{\detokenize{SandboxBrokerExt:building-a-plug-in}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Add ipc\_lib project to the plug\sphinxhyphen{}in’s project dependency list and also link to it.

\item {} 
Add the following headers from the SandboxPISDK into your project:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SandboxPIIPCDefs.h}}

\item {} 
\sphinxcode{\sphinxupquote{SandboxPIClientDefs.h}}

\item {} 
\sphinxcode{\sphinxupquote{SandboxPISDKClientMacros.h}}

\end{itemize}

\item {} 
Implement \sphinxcode{\sphinxupquote{<plugin>CrossCalls.h}} and \sphinxcode{\sphinxupquote{<plugin>IPCClient.cpp}} to add the client side of the Plugin specific broker Extensibility functionality. See \sphinxhref{SandboxBrokerExt.html\#26339}{Implement CrossCalls (make calls from plug\sphinxhyphen{}in to plug\sphinxhyphen{}in’s broker process)}.

\item {} 
Link to the \sphinxcode{\sphinxupquote{sandbox\_pisdk\_client.lib}} provided along with SandboxPISDK

\item {} 
Call the API, \sphinxcode{\sphinxupquote{InitSandboxPIBrokerIPCChannel}} provided with SandboxPISDK to setup the IPC channel with your Plugin’s broker process.

\end{enumerate}


\subsection{Building a plugin’s broker process}
\label{\detokenize{SandboxBrokerExt:building-a-plugin-s-broker-process}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Add \sphinxcode{\sphinxupquote{ipc\_lib}} project to the plug\sphinxhyphen{}in’s project dependency list and also link to it.

\item {} 
Add the following headers from the SandboxPISDK into your project:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SandboxPIIPCDefs.h}}

\item {} 
\sphinxcode{\sphinxupquote{SandboxPIServerDefs.h}}

\item {} 
\sphinxcode{\sphinxupquote{SandboxPISDKServerMacros.h}}

\end{itemize}

\item {} 
Add the \sphinxcode{\sphinxupquote{SandboxPIServerMain.cpp}} to the project

\item {} 
Implement \sphinxcode{\sphinxupquote{<plugin>IPCServer.cpp}} to add the server/broker side of the Plugin broker Extensibility functionality. See \sphinxhref{SandboxBrokerExt.html\#26339}{Implement CrossCalls (make calls from plug\sphinxhyphen{}in to plug\sphinxhyphen{}in’s broker process)}.

\item {} 
Add \sphinxcode{\sphinxupquote{ipc\_lib}} project to your <Plugin>broker project’s dependency list and also link to it.

\item {} 
Link to the \sphinxcode{\sphinxupquote{sandbox\_pisdk\_server.lib}} provided along with SandboxPISDK

\end{enumerate}

Refer the sample plugin/pluginbroker source code for more details.


\section{Handshake between plugin and plugin broker}
\label{\detokenize{SandboxBrokerExt:handshake-between-plugin-and-plugin-broker}}
These steps create the initial setup for the IPC channel between the Plugin and its broker required to make the cross calls. The following sequence of steps takes place during the initial setup:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The plug\sphinxhyphen{}in provides a plug\sphinxhyphen{}in broker process placed at \sphinxcode{\sphinxupquote{(app name)plug\_inspi\_brokers}} .

\item {} 
The plug\sphinxhyphen{}in sends a request via the \sphinxcode{\sphinxupquote{InitSandboxPIBrokerIPCChannel}} call which in turn uses SandboxHFT call \sphinxcode{\sphinxupquote{SbxLaunchPIBrokerExe}} to launch its piBroker process.

\item {} 
The broker process then validates the \sphinxcode{\sphinxupquote{piBroker}} process name against a white list.

\item {} 
If the above validation succeeds, then the broker process launches the \sphinxcode{\sphinxupquote{piBroker}} process. It then establishes the IPC channel using the \sphinxcode{\sphinxupquote{simple\sphinxhyphen{}ipc\sphinxhyphen{}lib}} between \sphinxcode{\sphinxupquote{piBroker}} process and plug\sphinxhyphen{}in.

\item {} 
If \sphinxcode{\sphinxupquote{InitSandboxPIBrokerIPCChannel}} returns true then plug\sphinxhyphen{}in is now ready to make cross calls to the \sphinxcode{\sphinxupquote{piBroker}} directly over the IPC channel to execute extended broker functionality.

\end{enumerate}

Refer to the sample project to get started and for example code.




\section{Implement CrossCalls (make calls from plug\sphinxhyphen{}in to plug\sphinxhyphen{}in’s broker process)}
\label{\detokenize{SandboxBrokerExt:implement-crosscalls-make-calls-from-plug-in-to-plug-in-s-broker-process}}
The entire purpose of providing broker Extensibility to plugins is to offer plug\sphinxhyphen{}ins a mechanism to make CrossCalls i.e. perform privileged operations that don’t work when called directly from the plug\sphinxhyphen{}in, for example, sending messages to HWND, read/write to files/registries, launch any application etc. The plug\sphinxhyphen{}in’s broker run under the user rights and doesn’t have any sandbox restrictions as a plugin running inside the app process has. So when a CrossCall is made, the plugin’s broker performs the same operation on the plugin’s behalf and returns the result to plugin. We are using chrome’s \sphinxcode{\sphinxupquote{simple\sphinxhyphen{}ipc\sphinxhyphen{}lib}} to perform Inter\sphinxhyphen{}process Communication and have written macros to define and make CrossCalls relatively easier.

Let’s take an example where plugin needs to send \sphinxcode{\sphinxupquote{WM\_COPYDATA}} message to a window.


\subsection{Changes required in the plugin (client)}
\label{\detokenize{SandboxBrokerExt:changes-required-in-the-plugin-client}}

\subsubsection{File <plugin>CrossCalls.h}
\label{\detokenize{SandboxBrokerExt:file-plugin-crosscalls-h}}
Create a unique id for new call and add it in between \sphinxcode{\sphinxupquote{DECLARE\_CROSS\_CALL\_START}} and \sphinxcode{\sphinxupquote{DECLARE\_CROSS\_CALL\_END:}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DECLARE\PYGZus{}CROSS\PYGZus{}CALL\PYGZus{}START}

            \PYG{n}{CROSS\PYGZus{}CALL\PYGZus{}ID}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{UniqueId1}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

            \PYG{n}{CROSS\PYGZus{}CALL\PYGZus{}ID}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{UniqueId2}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

            \PYG{n}{CROSS\PYGZus{}CALL\PYGZus{}ID}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{UniqueIdN}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

            \PYG{n}{CROSS\PYGZus{}CALL\PYGZus{}ID}\PYG{p}{(}\PYG{n}{SbxPISendMessage}\PYG{p}{)}

\PYG{n}{DECLARE\PYGZus{}CROSS\PYGZus{}CALL\PYGZus{}END}
\end{sphinxVerbatim}

Now the \sphinxcode{\sphinxupquote{INPUT PARAMETERS}} (params that are passed from plugin to broker) and \sphinxcode{\sphinxupquote{OUTPUT PARAMERERS}} (params that are returned from broker to plugin) and their order need to be defined.

Macros \sphinxcode{\sphinxupquote{DEFINE\_IPC\_MSG\_CLIENT(<UniqueId>, <numOfInputParams>)}} and \sphinxcode{\sphinxupquote{DEFINE\_IPC\_MSG\_SERVER(<UniqueId>, <numOfOutputParams>)}} have been designed exactly for this purpose. For \sphinxcode{\sphinxupquote{SbxPISendMessage}} CrossCall, the 4 input parameters are \sphinxcode{\sphinxupquote{HWND}} (passed as \sphinxcode{\sphinxupquote{VoidPtr}} ), \sphinxcode{\sphinxupquote{MsgType}} (passed as \sphinxcode{\sphinxupquote{UINT}} ), \sphinxcode{\sphinxupquote{WPARAM}} (passed as \sphinxcode{\sphinxupquote{UINT}} ), and \sphinxcode{\sphinxupquote{buffer}} (passed as \sphinxcode{\sphinxupquote{ByteArray}} ), and 2 output parameters are result – retrun value of \sphinxcode{\sphinxupquote{SendMessage}} call (passed as \sphinxcode{\sphinxupquote{UINT}} ) and \sphinxcode{\sphinxupquote{LastError}} – \sphinxcode{\sphinxupquote{GetLastError}} result after \sphinxcode{\sphinxupquote{SendMessage}} (passed as \sphinxcode{\sphinxupquote{UINT}} ).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
            \PYG{n}{DEFINE\PYGZus{}IPC\PYGZus{}MSG\PYGZus{}CLIENT}\PYG{p}{(}\PYG{n}{SbxPISendMessage}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{p}{\PYGZob{}}

                        \PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}VOID\PYGZus{}PTR}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

                        \PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}UINT}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

                        \PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}UINT}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}

                        \PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}BUFFER}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}

            \PYG{p}{\PYGZcb{}}\PYG{p}{;}

            \PYG{n}{DEFINE\PYGZus{}IPC\PYGZus{}MSG\PYGZus{}SERVER}\PYG{p}{(}\PYG{n}{SbxPISendMessage}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{\PYGZob{}}

                        \PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}UINT}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

                        \PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}UINT}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The following IPC data types are supported (as defined in files \sphinxcode{\sphinxupquote{SandboxPISDKClientMacros.h}} and \sphinxcode{\sphinxupquote{SandboxPISDKServerMacros.h}} ) :\sphinxhyphen{}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}VOID\PYGZus{}PTR} \PYG{o}{\PYGZhy{}} \PYG{k}{for} \PYG{n}{void}\PYG{o}{*}
\PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}INT} \PYG{o}{\PYGZhy{}} \PYG{n+nb}{int}
\PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}UINT} \PYG{o}{\PYGZhy{}} \PYG{n}{unsigned} \PYG{n+nb}{int}
\PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}LONG} \PYG{o}{\PYGZhy{}} \PYG{n}{long}
\PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}ULONG} \PYG{o}{\PYGZhy{}} \PYG{n}{unsigned} \PYG{n}{long}
\PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}STRING} \PYG{o}{\PYGZhy{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string}
\PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}WSTRING} \PYG{o}{\PYGZhy{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{wstring}
\PYG{n}{INPUT\PYGZus{}PARAM\PYGZus{}BUFFER} \PYG{o}{\PYGZhy{}} \PYG{n}{ipc}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ByteArray}
\PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}VOID\PYGZus{}PTR} \PYG{o}{\PYGZhy{}} \PYG{k}{for} \PYG{n}{void}\PYG{o}{*}
\PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}INT} \PYG{o}{\PYGZhy{}} \PYG{n+nb}{int}
\PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}UINT} \PYG{o}{\PYGZhy{}} \PYG{n}{unsigned} \PYG{n+nb}{int}
\PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}LONG} \PYG{o}{\PYGZhy{}} \PYG{n}{long}
\PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}ULONG} \PYG{o}{\PYGZhy{}} \PYG{n}{unsigned} \PYG{n}{long}
\PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}STRING} \PYG{o}{\PYGZhy{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string}
\PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}WSTRING} \PYG{o}{\PYGZhy{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{wstring}
\PYG{n}{OUTPUT\PYGZus{}PARAM\PYGZus{}BUFFER} \PYG{o}{\PYGZhy{}} \PYG{n}{ipc}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ByteArray}
\end{sphinxVerbatim}


\subsubsection{File <plugin>IPCClient.cpp}
\label{\detokenize{SandboxBrokerExt:file-plugin-ipcclient-cpp}}
In this file, the entire client side of the CrossCall needs to be defined. Macro \sphinxcode{\sphinxupquote{DEFINE\_CLIENT\_CROSS\_CALL(<UniqueId>, <numOfInputParams>, <numOfOutputParams>)}} does all the work of generating the requisite class (client side).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DEFINE\PYGZus{}CROSS\PYGZus{}CALL\PYGZus{}CLIENT}\PYG{p}{(}\PYG{n}{SbxPISendMessage}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

So once you have defined the cross call by using above macro, you have to use macro \sphinxcode{\sphinxupquote{MAKE\_CROSS\_CALL() and MAKE\_CROSS\_CALL\_WITH\_RETURN\_VAL()}} to call the function at the broker end. Whenever any UI is involved at the broker end and window handle from plugin is passed to the \sphinxcode{\sphinxupquote{PIBroker}} , the macro \sphinxcode{\sphinxupquote{MAKE\_CROSS\_CALL\_WITH\_MSG\_PUMP()}} or \sphinxcode{\sphinxupquote{MAKE\_CROSS\_CALL\_WITH\_MSG\_PUMP\_AND\_RETURN\_VAL()}} can be used which ensures that all UI messages from \sphinxcode{\sphinxupquote{PIBroker}} to the plugin. Remember, the order of input and output parameters have to be exactly same as defined in \sphinxcode{\sphinxupquote{<plugin>CrossCalls.h}} header file. Also, note that the input parameters are passed as const reference and output parameters are passed as reference.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{return\PYGZus{}value} \PYG{o}{=} \PYG{n}{false}\PYG{p}{;}

\PYG{n}{MAKE\PYGZus{}CROSS\PYGZus{}CALL\PYGZus{}WITH\PYGZus{}RETURN\PYGZus{}VAL}\PYG{p}{(}\PYG{n}{SbxPISendMessage}\PYG{p}{,} \PYG{n}{return\PYGZus{}value}\PYG{p}{)}\PYG{p}{(}\PYG{n}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{LPVOID}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{hWnd}\PYG{p}{)}\PYG{p}{,} \PYG{n}{msgType}\PYG{p}{,} \PYG{n}{wParam}\PYG{p}{,} \PYG{n}{ByteArrayBuffer}\PYG{p}{,} \PYG{n}{outRetVal}\PYG{p}{,} \PYG{n}{outLastErr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Changes required in the plugin’s broker (server)}
\label{\detokenize{SandboxBrokerExt:changes-required-in-the-plugin-s-broker-server}}

\subsubsection{File <plugin>IPCServer.cpp}
\label{\detokenize{SandboxBrokerExt:file-plugin-ipcserver-cpp}}
In this file, the entire server side of the CrossCall needs to be defined. Macro \sphinxcode{\sphinxupquote{DEFINE\_SERVER\_CROSS\_CALL\_START(<UniqueId>, <numOfInputParams>, <numOfOutputParams>)}} does all the work of generating the requisite server side class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 DEFINE\PYGZus{}SERVER\PYGZus{}CROSS\PYGZus{}CALL\PYGZus{}START(SbxPISendMessage, 4, 2)

      virtual void Proc(const LVOID\PYGZam{} input1, const UINT\PYGZam{} input2, const UINT\PYGZam{} input3, ipc::ByteArray \PYGZam{}input4, UINT\PYGZam{} out1, UINT\PYGZam{} out2)

     \PYGZob{}

        LRESULT result = 0;

        HWND hWnd = static\PYGZus{}cast\PYGZlt{}HWND\PYGZgt{}(input1);

        //  likewise take other parameters and make them ready to be passed to

        // SendMessage

        result = SendMessage(hWnd, WM\PYGZus{}CPYDATA, \PYGZlt{}other parameters\PYGZgt{});

        out1 = (result == FALSE) ? 0 : 1;

        out2 = GetLastError();

      \PYGZcb{}

DEFINE\PYGZus{}CROSS\PYGZus{}CALL\PYGZus{}SERVER\PYGZus{}END
\end{sphinxVerbatim}

Please note that if Proc above raises any exception then it will be eaten away by the internal implementation, so you need to use your own try catch block if you want to pass on any exception raised here to the plug\sphinxhyphen{}in.

And finally use the \sphinxcode{\sphinxupquote{MACRO \sphinxhyphen{} ADD\_MSG\_HANDLER}} to add above Cross all Proc to list of message handlers so that whenever \sphinxcode{\sphinxupquote{SbxPISendMessage}} message arrives at the \sphinxcode{\sphinxupquote{PIBroker}} end, it can be appropriately routed to its Proc.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DEFINE\PYGZus{}CROSS\PYGZus{}CALL\PYGZus{}HANDLER\PYGZus{}START}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Plugin}\PYG{o}{\PYGZhy{}}\PYG{n}{Name}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
      \PYG{n}{ADD\PYGZus{}MSG\PYGZus{}HANDLER}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Cross}\PYG{o}{\PYGZhy{}}\PYG{n}{Call} \PYG{n}{UniqueId1}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
      \PYG{n}{ADD\PYGZus{}MSG\PYGZus{}HANDLER}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{Cross}\PYG{o}{\PYGZhy{}}\PYG{n}{Call} \PYG{n}{UniqueId2}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
      \PYG{n}{ADD\PYGZus{}MSG\PYGZus{}HANDLER}\PYG{p}{(}\PYG{n}{SbxPISendMessage}\PYG{p}{)}
 \PYG{n}{DEFINE\PYGZus{}CROSS\PYGZus{}CALL\PYGZus{}HANDLER\PYGZus{}END}
\end{sphinxVerbatim}


\paragraph{Individual policy configuration for 3rd parties}
\label{\detokenize{SandboxBrokerExt:individual-policy-configuration-for-3rd-parties}}
The 2020 release introduces a new mechanism which allows plugins to use individual custom policy config files. The new config files adhere to same format and syntax as the original config file. To create one:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a custom policy config file parallel to Acrobat.exe in Acrobat’s installation folder.

\item {} 
Open the registry to \sphinxcode{\sphinxupquote{HKEY\_LOCAL\_MACHINESOFTWAREPoliciesAdobeAcrobat Acrobat<Track>FeatureLockDown}}

\item {} 
Create a key: \sphinxcode{\sphinxupquote{cProtectedModeConfigFiles}}

\item {} 
Add new preferences with a string with the name as your plugin’s name and data as your config file name under:

\end{enumerate}


\paragraph{Getting started with SampleExtn}
\label{\detokenize{SandboxBrokerExt:getting-started-with-sampleextn}}
To use the example, do the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Copy the \sphinxcode{\sphinxupquote{SampleExtn}} folder to the \sphinxcode{\sphinxupquote{…{[}PluginSupport{]}Sample}} folder of your \sphinxcode{\sphinxupquote{SDK}} folder as: \sphinxcode{\sphinxupquote{<Acrobat\_SDK\_Root>AdobeAcrobatSDKVersion1{[}PluginSupport{]}Samples{[}SampleExtn{]}}} . This folder contains the source code for SamplePI(Reader Plugin) and SamplePIBroker(PIBroker).

\item {} 
Open the Solution File: \sphinxcode{\sphinxupquote{SampleExtnwin32{[}SampleExtn{]}.sln}} and build it with VisualStudio 2019 SP1. Note: You will have to Reader Enable the \sphinxcode{\sphinxupquote{SamplePI.api}} as described in Developing and enabling an Adobe Reader plug\sphinxhyphen{}in–Reader plugins must be signed; Acrobat\sphinxhyphen{}only plugins do not need signing.

\item {} 
Copy the Reader Enabled \sphinxcode{\sphinxupquote{SamplePI.api}} to \sphinxcode{\sphinxupquote{<Reader\_Installed\_Path>plug\_ins{[}SamplePI{]}.api}}

\item {} 
Copy the SamplePIBroker.exe process to \sphinxcode{\sphinxupquote{<Reader\_Installed\_Path>plug\_inspi\_brokers{[}SamplePIBroker{]}.exe}}

\item {} 
Start in Protected Mode and play with \sphinxcode{\sphinxupquote{SamplePI.api}} from Acrobat SDK/SamplePI Menu.

\end{enumerate}


\chapter{PDF File Creation}
\label{\detokenize{Overview_PDFCreation:pdf-file-creation}}\label{\detokenize{Overview_PDFCreation::doc}}
This chapter provides information about how you can use the Acrobat DC SDK to create PDF files.




\section{Creating PDF files from an authoring application}
\label{\detokenize{Overview_PDFCreation:creating-pdf-files-from-an-authoring-application}}
Authoring applications can simplify the creation of PDF files by making the following steps appear seamless:
\begin{itemize}
\item {} 
Invoking Acrobat DC Distiller® through Apple events or DDE

\item {} 
Printing to a PostScript file

\item {} 
Automatically generating advanced Acrobat DC features using pdfmark

\end{itemize}




\subsection{Acrobat Distiller}
\label{\detokenize{Overview_PDFCreation:acrobat-distiller}}
Acrobat Distiller is essentially a PostScript interpreter that can be used to convert PostScript to PDF. Distiller is the PDF creation application intended for batch processing and for the creation of PDF files containing high\sphinxhyphen{}end print publishing features such as OPI comments, CMYK color spaces, and spot colors. Distiller also has the ability to interpret PostScript extensions called pdfmarks and to convert them into PDF objects such as links, bookmarks, optional content (OC), and annotations.

On Windows, you can automate Distiller through OLE automation (commonly referred to as ActiveX or COM). The automation interface makes it easy to start and control Distiller from any programming language that supports automation. Distiller supports programming environments written for Visual Basic and for Visual C++ with and without MFC.

The Mac OS version of Distiller supports Apple events. Apple events can be used from external applications written in programming languages such as C or from AppleScript. Because AppleScript is more straightforward, it is recommended.

For more information on Distiller, see the Distiller Help and the Acrobat Distiller API Reference




\subsection{Automated creation of PDF documents from Windows}
\label{\detokenize{Overview_PDFCreation:automated-creation-of-pdf-documents-from-windows}}
The Acrobat DC SDK has a set of APIs that allow you to automate the creation of PDF files from an external Windows application.

When you use OLE automation, the Distiller splash screen and status are displayed even when the process is automated. With the API, there is no interaction with the user and no display on the screen. The API allows you to specify the name and location of the output PDF file. To do so, you must modify the Windows registry. For more information, see the Acrobat Distiller API Reference.




\subsection{Automatic generation of advanced Acrobat features}
\label{\detokenize{Overview_PDFCreation:automatic-generation-of-advanced-acrobat-features}}
The most convenient place to generate advanced Acrobat DC features is in the authoring application itself, because that application defines the structure of the document. Advanced PDF features are generated using the pdfmark PostScript operator. The authoring application must generate a PostScript language file that contains the appropriate pdfmark operators for the document structure. The resulting PostScript language file is converted into a PDF file by Distiller. In addition, Acrobat DC allows logical structure information to be added to a document. For instance, paragraphs in a page’s contents can be associated with a structural element representing a paragraph.

For more information, see the \sphinxhref{http://www.adobe.com/go/pdfmark}{pdfMark Reference} .




\subsection{Attaching a native document to a PDF file}
\label{\detokenize{Overview_PDFCreation:attaching-a-native-document-to-a-pdf-file}}
Another way that an authoring application can integrate with Acrobat DC or Acrobat DC Reader is to allow the user access to the original authoring document through the Acrobat DC user interface. Through the use of private data in a PDF file, an authoring application can embed the entire authoring document as part of the PDF file that represents it. This way, not only can the resulting electronic document be viewed by anyone using Acrobat DC, it can also be edited by users who have the authoring application.

You must write a plug\sphinxhyphen{}in for Acrobat DC to allow users to embed and extract the authoring document. This plug\sphinxhyphen{}in would add the authoring document as a private data stream when embedding, and, when extracting, save the stream to a temporary file and invoke the authoring application.

\begin{sphinxadmonition}{note}{Note:}
Acrobat DC and Acrobat DC Reader ignore private data. Embedding authoring documents in PDF files greatly increases the size of the PDF file.
\end{sphinxadmonition}

An association between the PDF file and the authoring document can also be maintained through the use of links in the PDF file. Links can be created that invoke files and their associated applications. If a document management system places such a link in the PDF file, users can invoke the original authoring document by executing the link.




\subsection{Batch processing with Distiller}
\label{\detokenize{Overview_PDFCreation:batch-processing-with-distiller}}
You do not need to use the Distiller API to integrate Distiller with your product. Distiller has the ability to watch directories over a network and to convert any PostScript files saved to those directories to PDF. It is also possible to set different job options for each directory so that one directory can be used, for example, for high\sphinxhyphen{}end color output, while the other can generate a more compressed file suitable for web use. These features of Distiller are not supported by Acrobat Developer Support. Check the help documentation packaged with the product or books by Adobe Press and other publishers for using Distiller through the user interface.

The Distiller API can be used to programmatically process files and set the output path and file names while Acrobat Professional DC can be used to set up watched folders.




\subsection{Tagged PDF documents}
\label{\detokenize{Overview_PDFCreation:tagged-pdf-documents}}
PDF files are well known for representing the physical layout of a document; that is, the page markings that comprise the page contents. In addition, PDF provides a mechanism for describing logical structure in PDF files. This includes information such as the organization of the document into chapters and sections, as well as figures, tables, and footnotes.

Tagged PDF is a particular use of structured PDF that allows page content to be extracted and used for various purposes, including:
\begin{itemize}
\item {} 
Reflow of text and graphics

\item {} 
Conversion to file formats such as HTML and XML

\item {} 
Access for the visually impaired

\end{itemize}




\section{Creating PDF files using plug\sphinxhyphen{}ins or JavaScript}
\label{\detokenize{Overview_PDFCreation:creating-pdf-files-using-plug-ins-or-javascript}}
You can use Acrobat DC and the Acrobat DC SDK to create a new, empty PDF file and to create a PDF file from supported file types.




\subsection{Empty PDF files}
\label{\detokenize{Overview_PDFCreation:empty-pdf-files}}
Using either a plug\sphinxhyphen{}in or JavaScript, you can dynamically create a PDF file and modify its contents in an automated fashion. This can help make a document responsive to user input and enhance the workflow process.

JavaScript provides support for dynamic PDF file creation and content generation. Using a plug\sphinxhyphen{}in, you can also create a new, empty PDF file. You can then use methods to add content to the created file.




\subsection{PDF files from multiple files}
\label{\detokenize{Overview_PDFCreation:pdf-files-from-multiple-files}}
It is possible to use either a plug\sphinxhyphen{}in, IAC, or JavaScript to dynamically add content from other sources into a new PDF file. The sources can include files whose types conform to Multipurpose Internet Mail Extensions (MIME) type definitions.

Using JavaScript, you can import an external file into a PDF document. After doing this, it is possible to extract information from the data object for placement and presentation within the PDF document. You can automate the insertion of multiple PDF files into a single PDF document through a series of method calls, and you can also use a portion of the current document to create a new document.

With a plug\sphinxhyphen{}in or IAC, you can extract data from other file types, and then bind the resulting PDF files into one PDF file. The relevant APIs can also be executed directly from an IAC application.


\section{Creating PDF files without using Acrobat}
\label{\detokenize{Overview_PDFCreation:creating-pdf-files-without-using-acrobat}}
Some developers have developed the capability of generating PDF from their own applications without using Adobe products. Some of these developers have used the Adobe PDF Library product to extend their own application. Others have built PDF\sphinxhyphen{}generation capability into their applications from scratch. This type of development is not supported by Adobe.

\sphinxhref{http://www.adobe.com/go/pdfreference}{The best resource for building PDF\sphinxhyphen{}generation capability is the} \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} , which fully documents the PDF specification. The PDF file format is complex, and developing code to generate it requires a significant amount of development.


\chapter{Working with PDF Features}
\label{\detokenize{Overview_Editing:working-with-pdf-features}}\label{\detokenize{Overview_Editing::doc}}
This chapter discusses how you can work with various features of PDF documents using the Acrobat SDK.




\section{Navigation in PDF documents}
\label{\detokenize{Overview_Editing:navigation-in-pdf-documents}}



\subsection{Bookmarks}
\label{\detokenize{Overview_Editing:bookmarks}}
A bookmark corresponds to an outline object in a PDF document. A document outline consists of a tree\sphinxhyphen{}structured hierarchy of bookmarks

that displays the document’s structure, allowing the user to navigate interactively from one part of the document to another. Each bookmark has a title that appears on screen and an action that specifies what happens when the user clicks on the bookmark.

Bookmarks can be either created interactively through the Acrobat DC user interface or generated programmatically. Typically, a user\sphinxhyphen{}created bookmark is used to move to another location in the current document, although other actions can be specified, such as opening a web link, opening a file, playing a sound, or executing JavaScript.

You can use JavaScript, a plug\sphinxhyphen{}in, or IAC to get or set the following properties:
\begin{itemize}
\item {} 
The open attribute of a bookmark

\item {} 
The text used for the bookmark’s title

\item {} 
The action that is invoked when the bookmark is selected

\end{itemize}




\subsection{Thumbnails}
\label{\detokenize{Overview_Editing:thumbnails}}
Page thumbnails are miniature previews of the pages in a document. You can use page thumbnails in Acrobat DC to jump quickly to a selected page and to adjust the view of the page.

When you move, copy, or delete a page thumbnail, you actually move, copy, or delete the corresponding page. You can embed page thumbnails in a PDF document so that they need not be redrawn every time you select the Pages tab. They can easily be removed and embedded again if necessary.

You can use the Acrobat SDK to create and remove thumbnails in a PDF document.




\subsection{Links}
\label{\detokenize{Overview_Editing:links}}
Links, or hyperlinks, let users jump to other locations in the same document, to other electronic documents, or to websites. You can use links when you want to ensure that your reader has immediate access to related information. You can also use links to initiate actions.

The Acrobat SDK provides support for the addition, customization, or removal of links within PDF documents. These links can be used to access URLs, file attachments, or destinations within the document.

In addition, JavaScript can be used to specify whether cross\sphinxhyphen{}document links are opened in the same window or in a new one.




\subsection{Actions for special effects}
\label{\detokenize{Overview_Editing:actions-for-special-effects}}
Thumbnails, bookmarks, links, and other objects have actions associated with them, and you can use JavaScript to customize their behavior. For example, you can use them to display messages, jump to destinations in the same document or any other, open attachments, open web pages, execute menu commands, or perform a variety of other tasks.

You can also customize these actions so that they change their appearance after the user has clicked on them.




\section{PDF page manipulation}
\label{\detokenize{Overview_Editing:pdf-page-manipulation}}
You can use the Acrobat SDK to insert or remove pages from a PDF document. For example, you can do the following tasks:
\begin{itemize}
\item {} 
Create an empty page in the current document (not with IAC)

\item {} 
Insert pages from another document into the current document

\item {} 
Move a page to another location in the same document (not with IAC and AppleScript)

\item {} 
Replace pages with pages from another document

\item {} 
Delete pages from the current document

\end{itemize}

You can also access JavaScript functionality from an external application.




\subsection{Page content}
\label{\detokenize{Overview_Editing:page-content}}
Page content is a major component of a PDF file. It represents the visible marks on a page that are drawn by a set of PDF marking operators. The set of marking operators for a page is also referred to as a \sphinxstyleemphasis{display list} , since it is a list of marking operations that represent the displayed portion of a page. For more information on page content streams, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} .

You can use the PDFEdit API to access PDF page contents. With PDFEdit, your plug\sphinxhyphen{}in can treat a page’s contents as a list of objects rather than manipulating the content stream’s marking operators. There is no JavaScript equivalent to the PDFEdit API to allow you to manipulate page content. For more information on this API, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} and the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_snippet}{Snippet Runner Cookbook} .




\subsection{Document logical structure}
\label{\detokenize{Overview_Editing:document-logical-structure}}
You can insert logical structure into a PDF document by creating a tagged PDF document. The PDSEdit API provides the ability to add, modify, and view this logical structure. For more information, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} .

Authoring applications can also add structure pdfmarks to the PostScript language code generated when a document is printed. For more information, see the . \sphinxhref{http://www.adobe.com/go/pdfmark}{pdfmark Reference} .




\subsection{Other ways of modifying PDF documents}
\label{\detokenize{Overview_Editing:other-ways-of-modifying-pdf-documents}}
You can use a plug\sphinxhyphen{}in or JavaScript to modify a PDF document by cropping and rotating pages, numbering pages, and adding headers and footers.




\section{Watermarks}
\label{\detokenize{Overview_Editing:watermarks}}
JavaScript provides methods to create watermarks within a document, and place them in optional content groups (OCGs). You can also add watermarks using C APIs. The Acrobat SDK contains a sample plug\sphinxhyphen{}in that adds a watermark. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_samplesguide}{Acrobat SDK Samples Guide.}




\section{Spell\sphinxhyphen{}checking}
\label{\detokenize{Overview_Editing:spell-checking}}
Acrobat DC provides a Spelling plug\sphinxhyphen{}in that can scan a document for spelling errors. Using any of the Acrobat SDK technologies, you can do the following tasks:
\begin{itemize}
\item {} 
Add or remove a dictionary from the list of available dictionaries

\item {} 
Add or remove a spelling domain (search scope) from the Spell Check dialog box

\item {} 
Add or remove a word in the user’s dictionary

\item {} 
Check the spelling of an individual word

\item {} 
Ignore all occurrences of a word in a document when spell\sphinxhyphen{}checking

\item {} 
Scan a text buffer and return the next word

\item {} 
Set the document’s dictionary search order

\item {} 
Set the document’s dictionary search order from an array of ISO 639\sphinxhyphen{}2 and 3166 language codes, allowing you to identify a dictionary by language rather than by name

\end{itemize}

The following additional functionality is available to plug\sphinxhyphen{}ins and external applications, but is not available using JavaScript:
\begin{itemize}
\item {} 
Check a text object and optionally receive a callback for each change as the user interacts with the Spell Check dialog box

\item {} 
Count the words in a text buffer that are contained in each of a set of dictionaries

\item {} 
Create a new custom user dictionary and add it to the list of available dictionaries

\end{itemize}




\section{Multimedia}
\label{\detokenize{Overview_Editing:multimedia}}
Multimedia objects can be included in the content of PDF documents, as well as in annotations. You can only manipulate multimedia objects and players using JavaScript; you cannot use a plug\sphinxhyphen{}in. Using JavaScript, you can perform the following tasks:
\begin{itemize}
\item {} 
Customize the settings, renditions, and events associated with media players

\item {} 
Access and control the properties for all monitors connected to the system

\item {} 
Add movie and sound clips

\item {} 
Add and edit renditions

\item {} 
Control rendition settings

\item {} 
Set multimedia preferences that apply throughout a document

\end{itemize}

For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide.}




\section{Printing PDF files}
\label{\detokenize{Overview_Editing:printing-pdf-files}}
Using the Acrobat SDK, you can control the way that Acrobat DC, Acrobat Reader, or your external application prints PDF files. Using any of the Acrobat DC technologies, you can customize the way that a PDF document is printed.

Since printing involves sending pages to an output device, there are many options that can affect print quality. JavaScript can be used to enhance and automate the use of these options in print production workflows. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide} .

With plug\sphinxhyphen{}ins, you can use methods to customize and control how a PDF file is printed from Acrobat DC or Acrobat Reader. Depending on the methods you use, a user interface may be invoked. For example, you can use a method to print a document to the current printer using the current print settings and job settings with no user interface. You can specify a page range, a PostScript version, and whether to shrink the pages to fit the printer. For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide} .

Using the IAC APIs, you can print a PDF file from an external application. For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} .




\section{Embedded fonts}
\label{\detokenize{Overview_Editing:embedded-fonts}}
Acrobat Distiller and the PDF Library add font embedding information to fonts that are embedded in PDF files. With the inclusion of this information, your code can determine how an embedded font can be used. These operations also may apply to code used with the PDF Library SDK.

Acrobat DC plug\sphinxhyphen{}in developers can remove and embed fonts in an existing PDF document. You can also use fonts that are already embedded in a PDF document for preview and printing, as well as editing. However, allowing editing using embedded fonts is not recommended, and in some cases it is impractical. For example, Chinese, Japanese and Korean (CJK) fonts potentially include thousands of glyphs, so applications must subset these fonts when embedding them in a PDF file. This precludes embedded CJK fonts from being used for editing by a plug\sphinxhyphen{}in.

PDF Library users can perform these operations using an existing PDF document, or they can create a PDF document from scratch that includes embedded fonts. Creating a document from scratch cannot be performed by a plug\sphinxhyphen{}in, but it can be done by using PDF Library calls from within a compiled application that includes the PDF Library.


\chapter{User Interface Modifications}
\label{\detokenize{Overview_UserInterface:user-interface-modifications}}\label{\detokenize{Overview_UserInterface::doc}}
This chapter describes how you can modify menus and toolbars in the Acrobat DC or Acrobat Reader user interface using the Acrobat SDK.




\section{Menu items and menus}
\label{\detokenize{Overview_UserInterface:menu-items-and-menus}}
You can use the Acrobat SDK to manipulate menu items, menus, and menu bars. For complete information on what functionality is available with each SDK technology, see the \sphinxhref{https://www.adobe.com/go/apireference}{Acrobat and PDF Library API Reference,} the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsapiref}{Acrobat JS API Reference} , or the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} .


\subsection{Menu items}
\label{\detokenize{Overview_UserInterface:menu-items}}
You can use a plug\sphinxhyphen{}in or JavaScript to add or remove menu items or submenus to or from an existing menu. With IAC OLE automation, you can remove a menu item but you cannot add one.

Menu items added by plug\sphinxhyphen{}ins can have shortcuts (keyboard accelerators). Acrobat DC and Acrobat Reader do not ensure that plug\sphinxhyphen{}ins add unique shortcuts, but it is possible for a plug\sphinxhyphen{}in to check which shortcuts are already in use before adding its own. The only way to ensure there are no shortcut conflicts is for all plug\sphinxhyphen{}ins to check for conflicts before adding their own shortcuts.

You are encouraged to have your plug\sphinxhyphen{}in add its menu items to the Tools menu. When it is launched, Acrobat DC or Acrobat Reader automatically adds this menu, as well as the About Plug\sphinxhyphen{}ins and Plug\sphinxhyphen{}in Help menus (see \sphinxhref{Overview\_UserInterface.html\#38030}{Plug\sphinxhyphen{}in help files}). After Acrobat DC or Acrobat Reader loads all plug\sphinxhyphen{}ins, it checks these three menus and removes any that are empty.

Adobe keeps a registry of plug\sphinxhyphen{}in menu item names to help avoid conflicts between plug\sphinxhyphen{}ins. For more information on registering and using plug\sphinxhyphen{}in prefixes, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide} .


\subsection{Menus}
\label{\detokenize{Overview_UserInterface:menus}}
You can create a new menu from a plug\sphinxhyphen{}in. However, you cannot create menus or add menus to menu bars using JavaScript or IAC.




\section{Toolbars}
\label{\detokenize{Overview_UserInterface:toolbars}}
You can use the Acrobat SDK to manipulate tool buttons and toolbars. For complete information on what functionality is available with each SDK technology, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} , the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsapiref}{Acrobat JS API Reference} , or the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} .


\subsection{Items on a toolbar}
\label{\detokenize{Overview_UserInterface:items-on-a-toolbar}}
You can add or remove buttons to the toolbar, although the size and resolution of the user’s monitor can limit the number of tool buttons that can be added.


\subsection{Toolbar creation}
\label{\detokenize{Overview_UserInterface:toolbar-creation}}
Plug\sphinxhyphen{}ins also can create new toolbars, called flyouts, that can be attached to buttons on the main toolbar. The selection tools, for example, are all on a flyout. Not all tool buttons are located on the main toolbar; some may be located on a flyout.

You cannot create a flyout with JavaScript or IAC.




\section{Customization of Acrobat Help}
\label{\detokenize{Overview_UserInterface:customization-of-acrobat-help}}
You can manipulate specific parts of the Acrobat DC Help system using a plug\sphinxhyphen{}in. There is no equivalent functionality from JavaScript or IAC.


\subsection{About dialog box and splash screen}
\label{\detokenize{Overview_UserInterface:about-dialog-box-and-splash-screen}}
Plug\sphinxhyphen{}ins can set values in the preferences file to prevent the Acrobat DC or Acrobat Reader About dialog box or splash screen from appearing before displaying the first document. These changes take effect the next time Acrobat DC or Acrobat Reader is launched.




\subsection{Plug\sphinxhyphen{}in help files}
\label{\detokenize{Overview_UserInterface:plug-in-help-files}}
The Help directory that accompanies Acrobat DC or Acrobat Reader provides a standard location for your plug\sphinxhyphen{}in help files. About Acrobat Plug\sphinxhyphen{}Ins is a standard menu item in the Help menu. This menu item contains a submenu. You are encouraged to have your plug\sphinxhyphen{}in add a menu item to the submenu to display its own About box.

You can place a help file either in the Help directory or in a subdirectory of the Help directory. If, for example, your plug\sphinxhyphen{}in is localized for Japanese, you can place the Japanese help file in its own subdirectory. For more information, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference.}


\chapter{Annotations and Online Collaboration}
\label{\detokenize{Overview_CustomWorkflows:annotations-and-online-collaboration}}\label{\detokenize{Overview_CustomWorkflows::doc}}
Acrobat DC 8.0 introduces the Shared Reviews feature, which you should use for most online collaboration processes. You cannot initiate a Shared Review using the Acrobat SDK. For information on Shared Reviews, see the Acrobat DC Help.




\section{About annotations}
\label{\detokenize{Overview_CustomWorkflows:about-annotations}}
An annotation associates an object such as a note, sound, or movie with a location on a page of a PDF document, or provides a way to interact with the user through the mouse and keyboard. PDF includes a wide variety of standard annotation types, described in detail in the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} .

Many of the standard annotation types can be displayed in either the open or the closed state. When closed, they appear on the page in some distinctive form depending on the specific annotation type, such as an icon, a box, or a rubber stamp. When the user activates the annotation by clicking it with the mouse, it exhibits its associated object, such as opening a pop\sphinxhyphen{}up window displaying a text note or playing a sound or a movie.

You can access and manipulate annotation data from both a plug\sphinxhyphen{}in and JavaScript. However, you can only create new annotation types using a plug\sphinxhyphen{}in or the IAC API; you cannot create new annotation types from JavaScript.


\subsection{Annotations and JavaScript}
\label{\detokenize{Overview_CustomWorkflows:annotations-and-javascript}}
You can set, modify, and access annotation information using JavaScript. However, you cannot create a new annotation type from JavaScript. To do this, you must use a plug\sphinxhyphen{}in or the IAC API.

Using JavaScript, you can perform the following tasks:
\begin{itemize}
\item {} 
Add note comments

\item {} 
Make text edits

\item {} 
Highlight, cross out, or underline text

\item {} 
Add or delete custom stamps

\item {} 
Add comments in a text box

\item {} 
Add attachments

\item {} 
Spell check in comments and forms

\item {} 
Add commenting preferences

\item {} 
Change colors, icons, and other comment properties

\end{itemize}


\subsection{Annotations with plug\sphinxhyphen{}ins or IAC}
\label{\detokenize{Overview_CustomWorkflows:annotations-with-plug-ins-or-iac}}
There is an abstract superclass for all annotations. Acrobat DC and Acrobat Reader have two built\sphinxhyphen{}in annotation classes. Plug\sphinxhyphen{}ins can add movie, widget (form field), and other annotation types. You can define new annotation subtypes by creating new annotation handlers. For more information, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} \sphinxstyleemphasis{.}

The IAC API has an object you can use to set, modify, and access annotation information from external applications. For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} .




\section{New annotation types}
\label{\detokenize{Overview_CustomWorkflows:new-annotation-types}}
PDF supports many standard annotation types. Your plug\sphinxhyphen{}in can create annotation types, including any data they need. For example, a custom annotation type might allow a user to draw (not just type) in an annotation, provide support for multiple fonts or text styles, or support annotations that can only be viewed by specific users.

Support for new annotation types can be added by defining and registering an annotation handler. The Acrobat DC Movie plug\sphinxhyphen{}in, for example, uses this to support video annotations.

To add a new annotation type, a plug\sphinxhyphen{}in must provide a set of callbacks, specify them in the appropriate structure, and register them. For more information, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} .


\chapter{XML and the Acrobat SDK}
\label{\detokenize{Overview_XML:xml-and-the-acrobat-sdk}}\label{\detokenize{Overview_XML::doc}}
The Adobe XML architecture offers enterprises a step\sphinxhyphen{}by\sphinxhyphen{}step migration from manual, paper\sphinxhyphen{}based workflows to streamlined, automated processes that accelerate the flow of business\sphinxhyphen{}critical information between employees, customers, and suppliers. This chapter summarizes the Acrobat DC XML support and features.




\section{Adobe XML architecture}
\label{\detokenize{Overview_XML:adobe-xml-architecture}}
The Adobe XML architecture leverages the capabilities of XML and PDF to support a variety of business applications, while offering connectivity to systems through a variety of industry\sphinxhyphen{}standard and Adobe technologies.




\subsection{XML forms model}
\label{\detokenize{Overview_XML:xml-forms-model}}
The Adobe XML forms model uses a Document Object Model (DOM) architecture to manage the components that comprise a form. These include the base template, the form itself, and the data contained within the form fields. In addition, all calculations, validations, and formatting are specified and managed within the DOM and XML processes. Static are supported by Acrobat DC. A static form presents a fixed set of text, graphics, and field areas at all times.


\subsection{XML templates}
\label{\detokenize{Overview_XML:xml-templates}}
JavaScript defines an object that supports interactive form architectures. In this context, a template is a named page within a PDF document that provides a convenient format to automatically generate and manipulate a large number of form fields. These pages contain visibility settings, and can be used to spawn new pages containing identical sets of form controls to those defined within the template.


\subsection{Extensible Metadata Platform}
\label{\detokenize{Overview_XML:extensible-metadata-platform}}
Adobe’s Extensible Metadata Platform (XMP) is a labeling technology that allows you to embed metadata into the file itself. With XMP, desktop applications and back\sphinxhyphen{}end publishing systems use a common method for capturing, sharing, and leveraging metadata. For more information, see \sphinxhref{Overview\_Metadata.html\#62568}{Metadata, Accessibility, and PDF Layers}.




\section{SOAP and web services}
\label{\detokenize{Overview_XML:soap-and-web-services}}
Acrobat DC supports SOAP 1.1 and 1.2 to enable PDF forms to communicate with web services. This makes it possible to include both SOAP header and body information, send binary data more efficiently, use document/literal encoding, and facilitate authenticated or encrypted communications. It also provides the ability to locate network services using DNS Service Discovery (DNS\sphinxhyphen{}SD). All of this enables the integration of PDF files into existing workflows by binding Adobe XML forms to schemas, databases, and web services. These workflows include the ability to share comments remotely or invoke web services through form field actions.

If the exact URL for a given service is not known, but it is available locally because it has been published using DNS Service Discovery, Acrobat DC provides JavaScript methods to locate the service on the network and bind to it for communications.

A SOAP\sphinxhyphen{}based collaboration server can be used to share comments remotely using a web\sphinxhyphen{}based comment repository. Through the DNS Service Discovery support, it is possible to enable dynamic discovery of collaboration servers, initiation workflows, and RSS feeds that can provide customized user interfaces, using XML, directly inside of Acrobat DC.

In addition, it is possible to deploy web\sphinxhyphen{}based JavaScript code that always maintain the most updated information and processes, and to connect to those scripts using form field actions that invoke web services.

For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide} .




\section{Conversion of PDF documents to XML format}
\label{\detokenize{Overview_XML:conversion-of-pdf-documents-to-xml-format}}
Because XML representation is the basis for the exchange of information with web services and enterprise infrastructures, it is often useful to convert your PDF documents into XML format. It is a straightforward process to do this using JavaScript. For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide} .

Alternatively, you can use the SaveAsXML plug\sphinxhyphen{}in, which extends the Save As Type choices in the Save As dialog box to allow a Tagged PDF document to be saved in a number of XML, HTML, or similar text\sphinxhyphen{}based formats. The plug\sphinxhyphen{}in uses mapping tables to control the conversion process for the SaveAsXML feature. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide} .




\section{XML\sphinxhyphen{}based information}
\label{\detokenize{Overview_XML:xml-based-information}}
JavaScript provides support for XML\sphinxhyphen{}based information generated within workflows. For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide} .


\chapter{Forms and the Acrobat SDK}
\label{\detokenize{Overview_Forms:forms-and-the-acrobat-sdk}}\label{\detokenize{Overview_Forms::doc}}
You can use the Acrobat SDK to extend the functionality of forms. Your form design can have dynamically changing features such as the current date, as well as convenience options such as automatic generation of e\sphinxhyphen{}mail messages. It can even have a dynamically changing appearance and layout that is responsive to user interactions.

Acroforms can be used to retrieve form data using JavaScript or using the Forms API with plug\sphinxhyphen{}ins and external applications. With Acrobat DC forms, you can author form fields and retrieve data from those form fields. For Acrobat Reader, the Forms plug\sphinxhyphen{}in does not allow form authoring, but allows users to fill in data and print Acrobat DC forms. The Acrobat Reader Forms plug\sphinxhyphen{}in also does not allow users to save data to the local hard disk. Both Acrobat DC and Acrobat Reader allow web designers to send data from the form back to a web server. For new forms development, use XML forms instead.


\section{Workflows for forms}
\label{\detokenize{Overview_Forms:workflows-for-forms}}
There are three basic workflows for forms:
\begin{itemize}
\item {} 
Forms are filled in on the screen and then printed out. They are then returned by traditional methods such as fax or postal mail.

\item {} 
Forms contain a Submit button that enables the sending of an email message with an attached data file that contains only the form data.

\item {} 
Forms submit form data to a web server much like forms on the Internet. The user must be online to submit the information.

\end{itemize}




\section{About XML forms}
\label{\detokenize{Overview_Forms:about-xml-forms}}
For XML forms, properties and methods available only from JavaScript allow you to access specific objects. You cannot access these objects from a plug\sphinxhyphen{}in or external application.

\sphinxstylestrong{Form population} — You can populate forms from a database or using a standards\sphinxhyphen{}based network protocol such as SOAP. XML forms are particularly well suited for populating forms from an external database. For more information, see \sphinxhref{Overview\_XML.html\#40748}{SOAP and web services}.

\sphinxstylestrong{Web\sphinxhyphen{}ready forms} — XML forms can be used in workflows that require the exchange of information over the web. You can create forms that run in web browsers, and can submit and retrieve information between the client and server by making a Submit button available in the form. The button can perform tasks similar to those of HTML scripting macros.

\sphinxstylestrong{Data collection} — You can save your form data in pure XML format or save your forms in the XML Data Package format (XDP). The XDP format allow you to package units of PDF content within a surrounding XML container, and is thus considered an XML\sphinxhyphen{}based companion to PDF. The advantage of this format is that XML parsers provide direct access to the XML form\sphinxhyphen{}data subassembly of the PDF document.

Using JavaScript, form data can be saved in either FDF or XFDF format in a separate file that can subsequently be used in the next step within a workflow. This approach minimizes the file size to just the amount needed to store your data, thus decreasing network traffic and processing time for the next step in the workflow.

Once you’ve collected PDF form data in FDF or XML format from multiple users, you can organize the form data into a comma\sphinxhyphen{}delimited spreadsheet file (CSV). After exporting the form data to a CSV file, you can work with the data in a spreadsheet application, such as Microsoft Excel. You can also save form data as a tab\sphinxhyphen{}delimited file. Tab\sphinxhyphen{}delimited files can be imported where required.

Data from various attachments can also be imported into an XML document and submitted to a server for processing.




\section{About Acrobat forms}
\label{\detokenize{Overview_Forms:about-acrobat-forms}}
For Acrobat DC forms, a rich set of APIs allows you to create and manipulate form fields, and to retrieve form data using JavaScript, a plug\sphinxhyphen{}in, or an external application. Though you can manipulate form fields and form data from a plug\sphinxhyphen{}in, it is much quicker to develop Acrobat DC forms using JavaScript. Using the Acrobat SDK, you can perform the following tasks:
\begin{itemize}
\item {} 
Create Adobe PDF forms from scratch or from a template

\item {} 
Add or remove form fields

\item {} 
Set form field properties

\item {} 
Make forms web\sphinxhyphen{}ready

\item {} 
Extract and export form data

\item {} 
Make forms accessible

\end{itemize}

You can extend the functionality of Acrobat DC forms with JavaScript. For example, you can use JavaScript to do the following tasks:
\begin{itemize}
\item {} 
Automate formatting, calculations, and data validation

\item {} 
Develop customized actions assigned to user events

\item {} 
Interact with databases and web services

\end{itemize}


\subsection{Forms API}
\label{\detokenize{Overview_Forms:forms-api}}
The Forms plug\sphinxhyphen{}in for Acrobat DC allows plug\sphinxhyphen{}in developers to author Acrobat DC form fields.

For Acrobat Reader, the Forms plug\sphinxhyphen{}in does not allow form authoring, but allows users to fill in data and print Acrobat DC forms. In general, the Acrobat Reader Forms plug\sphinxhyphen{}in does not allow users to save data to the local hard disk. However, if the PDF document has additional usage rights, then it may be able to save the document or perform other functions. For more information, see \sphinxhref{Overview\_UsageRights.html\#88629}{Rights\sphinxhyphen{}Enabled PDF Documents and Security}.

Both Acrobat DC and Acrobat Reader allow web designers to send data from the form back to a web server.


\subsection{OLE automation}
\label{\detokenize{Overview_Forms:ole-automation}}
The Acrobat DC Forms plug\sphinxhyphen{}in works as an automation server on Windows. There is no equivalent support on Mac OS. OLE automation is particularly useful for creating custom forms from an external application. Methods and properties are provided that allow you to programmatically associate actions and JavaScript with form fields. You can also add document\sphinxhyphen{}level JavaScript. For more information, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} .


\chapter{Metadata, Accessibility, and PDF Layers}
\label{\detokenize{Overview_Metadata:metadata-accessibility-and-pdf-layers}}\label{\detokenize{Overview_Metadata::doc}}

\section{Metadata}
\label{\detokenize{Overview_Metadata:metadata}}
A PDF document can include general information such as the document’s title, author, and creation and modification dates. Such global information about the document itself (as opposed to its content or structure) is called metadata, and is intended to assist in cataloguing and searching for documents in external databases.

Metadata properties and values are represented in the World Wide Web Consortium’s Resource Definition Format (RDF), which is a standard metadata format based on XML. The set of standard metadata items is organized into schemas, each of which represents a set of properties from a particular application or industry standard. The schemas, as well as the physical representation, are defined by Adobe’s Extensible Metadata Platform (XMP). For more information, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} .




\subsection{Extensible Metadata Platform (XMP)}
\label{\detokenize{Overview_Metadata:extensible-metadata-platform-xmp}}
Adobe’s Extensible Metadata Platform (XMP) is a labeling technology that allows you to embed metadata into the file itself. With XMP, desktop applications and back\sphinxhyphen{}end publishing systems gain a common method for capturing, sharing, and leveraging this valuable metadata — opening the door for more efficient job processing, workflow automation, and rights management, among many other possibilities.

You can use JavaScript to access the XMP metadata embedded in a PDF document, and you can search metadata by using JavaScript or a plug\sphinxhyphen{}in.

Plug\sphinxhyphen{}ins can also get or set XMP metadata. Furthermore, you can get or set the XMP metadata associated with an internal PDF dictionary or stream. For more information, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} .

Acrobat Distiller also supports embedding of XMP metadata in PDF files.




\subsection{Adobe XMP Toolkit}
\label{\detokenize{Overview_Metadata:adobe-xmp-toolkit}}
The XMP Toolkit is designed to help applications handle XMP operations such as the creation and manipulation of metadata. The toolkit makes it easier for developers to support XMP metadata, and helps to standardize how the data is represented and interchanged. The XMP Toolkit can be licensed, royalty\sphinxhyphen{}free, from Adobe.


\section{Accessibility}
\label{\detokenize{Overview_Metadata:accessibility}}
Acrobat DC and the Acrobat SDK provide extensive support for accessibility of documents to visually\sphinxhyphen{}impaired users. To enable proper vocalization, either through a screen reader or by some more direct invocation of a text\sphinxhyphen{}to\sphinxhyphen{}speech engine, PDF supports the following features:
\begin{itemize}
\item {} 
Specifying the natural language used for text in a PDF document—for example, as English or Spanish

\item {} 
Providing textual descriptions for images or other items that do not translate naturally into text, or replacement text for content that does translate into text but is represented in a nonstandard way (such as with a ligature or illuminated character)

\item {} 
Specifying the expansion of abbreviations or acronyms

\end{itemize}

The core of this support lies in the ability to determine the logical order of content in a PDF document, independently of the content’s appearance or layout, through logical structure and tagged PDF documents. Tagged PDF documents are created using the Acrobat Professional DC user interface or using the Acrobat SDK.

If a PDF document is untagged, you can convert it to a tagged PDF document using Acrobat Professional DC. Acrobat DC Standard provides only minimal support for tagging and no way to review or repair accessibility problems.

An accessible application can extract the content of a document for presentation to a user who is disabled by traversing the structure hierarchy and presenting the contents of each node. For this reason, producers of PDF files must ensure that all information in a document is reachable through the structure hierarchy.

For more information on accessibility support in PDF files, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} . For more information on implementing accessibility support, see the Acrobat DC Help and the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide} .


\section{PDF layers}
\label{\detokenize{Overview_Metadata:pdf-layers}}
Adobe PDF layers are components of content that can occupy the same physical space as other components. Multiple components may be visible or invisible depending on their settings, and may be used to support the display, navigation, and printing of layered PDF content by various applications.

Using the Acrobat SDK, you can display, navigate and print layered PDF documents.

Acrobat DC supports the display, navigation, and printing of layered Adobe PDF content output by applications such as Adobe InDesign®, AutoCAD, and Microsoft Visio. PDF layers are supported through the usage of PDF Optional Content Group (OCG) objects. Optional content refers to content in a PDF document that can be selectively viewed or hidden.

Note the following:
\begin{itemize}
\item {} 
You can rename and merge layers, change the properties of layers, and add actions to layers. You can also lock layers to prevent them from being hidden.

\item {} 
You can control the display of layers using the default and initial state settings. For example, if your document contains a copyright notice, you can easily hide the layer whenever the document is displayed onscreen but ensure that the layer always prints.

\item {} 
Acrobat DC does not allow you to author layers that change visibility according to the zoom level, but it does support this capability from other authoring applications.

\item {} 
To direct users to a custom view using a particular layer set, you can add bookmarks to a PDF document that contains layers. Use this technique to highlight a portion of a layer that is especially important. You can add links so that users can click on a visible or invisible link to navigate to or zoom in on a layer.

\item {} 
To create layers while exporting InDesign CS or later documents to PDF, make sure that Compatibility is set to the latest Acrobat DC version and that Create Acrobat Layers is selected in the Export PDF dialog box.

\end{itemize}




\subsection{Creation of layered PDF files}
\label{\detokenize{Overview_Metadata:creation-of-layered-pdf-files}}
When creating PDFs, several engineering applications, including Microsoft Visio and AutoCad, automatically generate the necessary ProcSets to create layered PDF documents.

You create layered PDF documents with the ProcSet used to build Optional Content (OC) into PDF through Acrobat Distiller.

Third\sphinxhyphen{}party developers must insert OC ProcSet information into the PostScript stream. For more information, see \sphinxhref{Overview\_PDFCreation.html\#43214}{Creating PDF files from an authoring application} and the \sphinxhref{http://www.adobe.com/go/distiller}{Acrobat Distiller API Reference} .




\subsection{What you can do with layers}
\label{\detokenize{Overview_Metadata:what-you-can-do-with-layers}}
Since information can be stored in different layers of a PDF document, navigational controls can be customized within different layers, whose visibility settings may be dynamically customized so that they are tied to context and user interaction. For example, if the user selects a given option, a set of navigational links belonging to a corresponding optional content group can be shown.

Using JavaScript, you can determine the order in which layers are displayed in the user interface. You can also use JavaScript to perform the following tasks:
\begin{itemize}
\item {} 
Merge layers in a PDF document

\item {} 
Flatten layers in a PDF document

\item {} 
Combine PDF layered documents

\end{itemize}

For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide} .

For plug\sphinxhyphen{}ins, you use an object to represent an optional\sphinxhyphen{}content group. This corresponds to a PDF dictionary representing a collection of graphic objects that can be made visible or invisible. Any graphic content of the PDF can be made optional, including page contents, XObjects, and annotations. From a plug\sphinxhyphen{}in, you can perform the following tasks:
\begin{itemize}
\item {} 
Create an OCG

\item {} 
Get and set the current state of an OCG

\item {} 
Get and set the initial OCG state

\item {} 
Get and set document configurations

\end{itemize}

For more information, see the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} .


\chapter{Searching and Indexing}
\label{\detokenize{Overview_Searching:searching-and-indexing}}\label{\detokenize{Overview_Searching::doc}}
With Acrobat DC and the Acrobat SDK, you can use the Search plug\sphinxhyphen{}in to locate an occurrence of a word in document content, metadata, attachments or other objects. You can use the Catalog plug\sphinxhyphen{}in to create a full\sphinxhyphen{}text index of a PDF document or document collection. This chapter summarizes these plug\sphinxhyphen{}ins.




\section{Search plug\sphinxhyphen{}in}
\label{\detokenize{Overview_Searching:search-plug-in}}
With Acrobat DC, Adobe provides a full\sphinxhyphen{}text search system. Using the Acrobat DC search system, you can perform the following tasks:
\begin{itemize}
\item {} 
Initiate a search with options. You can pass query expressions and search settings (for example, whole words only, word stemming, case sensitive, and so forth) to the Acrobat DC search plug\sphinxhyphen{}in and initiate the search. Search results will be presented to the user.

\item {} 
Control the list of indexes to search. The search interface allows searches to be performed on one or more of the available indexes. You can control the list of active indexes.

\end{itemize}

The Acrobat DC Search plug\sphinxhyphen{}in allows users to perform text searches in PDF documents. It adds menus, menu items, toolbar buttons, and a Search panel to Acrobat DC or Acrobat Reader.

You can communicate with the Search plug\sphinxhyphen{}in through its plug\sphinxhyphen{}in API, IAC (DDE or Apple events) or JavaScript. You can perform all search options from each of these development environments.

The Acrobat DC Search plug\sphinxhyphen{}in provided with Acrobat DC is a true Acrobat DC plug\sphinxhyphen{}in. You can remove it from the system by simply removing it from the Plug\sphinxhyphen{}ins directory and restarting Acrobat DC.




\section{Indexes and the Catalog plug\sphinxhyphen{}in}
\label{\detokenize{Overview_Searching:indexes-and-the-catalog-plug-in}}
You can use the Acrobat SDK to create a full\sphinxhyphen{}text index of a set of PDF documents. A full\sphinxhyphen{}text index is a searchable database of all the text in the documents. After building an index, you can use search the entire library quickly. You can build and manipulate indexes from a plug\sphinxhyphen{}in, through JavaScript, or from an external application using IAC (DDE or Apple events) calls.

For indexing PDF files, Acrobat DC provides text extraction APIs. Text extraction also supplies position information that can be used to highlight search hits in the original PDF file. The text extraction tools are provided as calls in the plug\sphinxhyphen{}in API on Windows and Mac OS. You can extract ASCII text from a PDF file using a plug\sphinxhyphen{}in or using JavaScript. You can also save the PDF document as text or rich text.

Acrobat DC Catalog is a plug\sphinxhyphen{}in that allows you to create a full\sphinxhyphen{}text index of a set of PDF documents. The Catalog plug\sphinxhyphen{}in has an HFT consisting of several methods that plug\sphinxhyphen{}in developers can import and use. In addition, Catalog supports DDE, and broadcasts several Windows messages.

For more information, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide} , \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} , and the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide} .


\chapter{Frequently Asked Questions}
\label{\detokenize{apxDevFAQ:frequently-asked-questions}}\label{\detokenize{apxDevFAQ::doc}}

\section{Forms}
\label{\detokenize{apxDevFAQ:forms}}

\subsection{What are the requirements for using Acrobat forms?}
\label{\detokenize{apxDevFAQ:what-are-the-requirements-for-using-acrobat-forms}}
You can create and fill in Acrobat forms in PDF files, and submit or import form data. These forms are typically used for viewing or printing information, filling in information, selecting options, digitally signing documents, and exchanging information with databases. Note that Reader users can fill in and submit forms. Once a user fills out an Acrobat form, the data can be submitted to a server for processing. Data can be exported from a PDF form into Forms Data Format (FDF). Data can be imported into a PDF form if it is in FDF, XFDF, XML, or TXT format. Acrobat forms support the following formats: FDF, XFDF, tab\sphinxhyphen{}delimited text, and XML.

Every FDF file contains a reference to a PDF file for which the data is intended, designated with the \sphinxcode{\sphinxupquote{/F}} key inside the FDF file (unless the FDF file is for the same PDF from which you submitted your data). When Acrobat or Acrobat Reader receives an FDF file, it opens the corresponding PDF file, and fills the form fields with the data from the FDF file. If the PDF file is referenced by a URL (for example, \sphinxurl{http://example.com/file.pdf}), the FDF file must be sent to the server in response to a \sphinxcode{\sphinxupquote{submit}} action from a PDF form. For more information about the FDF format, which is based on PDF, see the \sphinxhref{https://www.adobe.com/go/pdfreference}{PDF Reference} .

Acrobat plug\sphinxhyphen{}ins can programmatically import FDF data into a PDF file from a local file system using the HFT made available by the Forms plug\sphinxhyphen{}in. OLE automation can be used to programmatically add, modify, or delete form fields, import or export FDF data, execute scripts written in JavaScript, and much more. For more information, see the \sphinxhref{http://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference.}




\subsection{What is the FDF Toolkit?}
\label{\detokenize{apxDevFAQ:what-is-the-fdf-toolkit}}
The FDF (Forms Data Format) Toolkit is a thread\sphinxhyphen{}safe API for writing a server application that generates FDF data or parses FDF data from a form created by the Acrobat Forms plug\sphinxhyphen{}in. If you need to parse FDF files submitted from a PDF form, or generate FDF files to be submitted to a PDF form, you can use the FDF Toolkit. The FDF Toolkit supports COM on Windows, C and Perl on Windows, Solaris™, AIX® or Linux®, and Java VMs compatible with versions 1.2 or later.

For detailed information, see the documentation included with the FDF Toolkit.




\section{PDF documents}
\label{\detokenize{apxDevFAQ:pdf-documents}}

\subsection{What ActiveX solutions are available?}
\label{\detokenize{apxDevFAQ:what-activex-solutions-are-available}}
The PDF browser control automation object, described in the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} , supports the loading and display of PDF documents as ActiveX documents, and its interface is available in both Acrobat and Acrobat Reader.


\subsection{Visual Basic .NET and Visual C\# .NET}
\label{\detokenize{apxDevFAQ:visual-basic-net-and-visual-c-net}}

\subsubsection{How can I use Visual Basic .NET or Visual C\# .NET?}
\label{\detokenize{apxDevFAQ:how-can-i-use-visual-basic-net-or-visual-c-net}}
The Windows version of Acrobat is an OLE automation server. In order to use the OLE objects made available by Acrobat, you must have the full Acrobat product installed on your system and the \sphinxcode{\sphinxupquote{Acrobat.tlb}} file included in the project references for your Visual Basic project. This allows you to use the Visual Studio 2005 object browser to browse the OLE objects.

For Acrobat versions 5.0 and later, it is possible to access the JavaScript object model in Acrobat through the OLE automation \sphinxcode{\sphinxupquote{JSObject}} interface. See the \sphinxcode{\sphinxupquote{JSObjectAccess}} sample. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} .


\subsubsection{What resources are available for Visual Basic .NET or Visual C\# .NET?}
\label{\detokenize{apxDevFAQ:what-resources-are-available-for-visual-basic-net-or-visual-c-net}}
The \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} describes the objects and methods available in these languages, as well as guidelines for usage. These documents (as well as the API) were designed with C programming in mind, and programming with the API requires some familiarity with C concepts such as \sphinxcode{\sphinxupquote{enum}} .

Besides the object browser, the best resources for programming in these languages are the sample projects. The samples demonstrate use of the Acrobat OLE objects and contain comments describing the parameters for the more complicated methods. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_samplesguide}{Acrobat SDK Samples Guide} .

The \sphinxcode{\sphinxupquote{Iac.bas}} file in the InterAppCommunicationSupportHeaders folder contains the Visual Basic counterparts to the C \sphinxcode{\sphinxupquote{\#define}} statements and enumerations passed to many of the API methods.


\subsection{What API methods are available to modify PDF documents?}
\label{\detokenize{apxDevFAQ:what-api-methods-are-available-to-modify-pdf-documents}}
Modifying the page contents of a PDF file is primarily accomplished using the Acrobat core API.

Using the Acrobat core API greatly simplifies modifying and creating PDF page contents. To demonstrate this, there are several snippets available from the \sphinxcode{\sphinxupquote{SnippetRunner}} sample plug\sphinxhyphen{}in that show you how to add data to the contents of a page, while ensuring that the PDF file is still readable after modification. To attempt to do this without using the core API would be significantly more difficult and could result in an unreadable PDF file.

Acrobat’s automation interfaces are limited mainly to what a user can do through the user interface and cannot modify the contents of a page.

For more information on the Acrobat core API, see \sphinxhref{http://www.adobe.com/go/acrobatsdk\_pluginguide}{Acrobat Plugin Developer Guide} and the \sphinxhref{https://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference} .


\subsection{Can I modify PDFs without a C programming background?}
\label{\detokenize{apxDevFAQ:can-i-modify-pdfs-without-a-c-programming-background}}
You can make some modifications to PDF files through JavaScript for Acrobat. See the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_jsdevguide}{Acrobat JavaScript Developer Guide} .




\subsection{How can I extract text?}
\label{\detokenize{apxDevFAQ:how-can-i-extract-text}}
You can extract text with the Acrobat SDK in two ways:
\begin{itemize}
\item {} 
Use the Acrobat core API

\item {} 
Use the Acrobat automation API

\end{itemize}

Through the core API, you can extract ASCII text from a PDF file using Acrobat and a plug\sphinxhyphen{}in developed in C or C++. The \sphinxcode{\sphinxupquote{TextExtraction}} and \sphinxcode{\sphinxupquote{WordFinder}} sample plug\sphinxhyphen{}ins demonstrate text extraction and can be used as starting points for your own plug\sphinxhyphen{}in. \sphinxcode{\sphinxupquote{AVConversion}} methods also can be used to save PDF as text or rich text. In addition, the \sphinxcode{\sphinxupquote{SDKTextExtraction}} sample in the first level of the SaveAsXML directory provides a good starting point for creating richer extraction tables. For more information, see the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_samplesguide}{Acrobat SDK Samples Guide} .




\subsection{How can I display a PDF in an external application window?}
\label{\detokenize{apxDevFAQ:how-can-i-display-a-pdf-in-an-external-application-window}}
There are several ways to have the Acrobat program display a PDF file in an external application’s window. Acrobat must be installed on the system to view a PDF file in your own application’s window.

There is no best way that we suggest to display PDF files in your application. Examine the following list for the most appropriate method for your situation. For more documentation, see \sphinxhref{http://www.adobe.com/go/acrobat\_developer}{IAC Developer Guide} .




\subsection{Using Acrobat to view PDFs in your own application}
\label{\detokenize{apxDevFAQ:using-acrobat-to-view-pdfs-in-your-own-application}}
Windows only:
\begin{itemize}
\item {} 
OLE automation, using the \sphinxcode{\sphinxupquote{OpenInWindowEx}} command. This displays a live view of the PDF file in the OLE application window.

\end{itemize}

For samples, see the Visual Basic and C++ \sphinxcode{\sphinxupquote{ActiveView}} applications.
\begin{itemize}
\item {} 
OLE automation, using the \sphinxcode{\sphinxupquote{DrawEx}} command. This displays a bitmap of the current page in the OLE application window.

\end{itemize}

For samples, see the Visual Basic and C++ \sphinxcode{\sphinxupquote{StaticView}} applications.
\begin{itemize}
\item {} 
Copy to the clipboard. This copies a PDF image to the clipboard without requiring an \sphinxcode{\sphinxupquote{hWnd}} or \sphinxcode{\sphinxupquote{hDC}} using OLE automation.

\item {} 
If you are using simplified browser controls in your application, you may treat the PDF document as an ActiveX document by using the \sphinxcode{\sphinxupquote{AcroPDF}} object’s \sphinxcode{\sphinxupquote{LoadFile}} method. This automation interface is available in both Acrobat and Acrobat Reader.

\end{itemize}

Mac OS only:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{AcroAppleEvents}} sample application demonstrates rendering a PDF file into another application’s window (see \sphinxcode{\sphinxupquote{DrawIntoWindowCommand}} for details).

\end{itemize}

Windows and Mac OS:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{ExternalWindow}} sample plug\sphinxhyphen{}in demonstrates a live view of the PDF file in a window created by the plug\sphinxhyphen{}in. You can extend this to display PDF files in an external application window.

\end{itemize}


\subsection{Are multibyte font PDF documents supported by the Acrobat SDK?}
\label{\detokenize{apxDevFAQ:are-multibyte-font-pdf-documents-supported-by-the-acrobat-sdk}}
Acrobat allows the creation, modification, and use of PDF files containing multibyte fonts.


\subsection{How are security and encryption provided in PDFs?}
\label{\detokenize{apxDevFAQ:how-are-security-and-encryption-provided-in-pdfs}}
Adobe provides password\sphinxhyphen{}based and certificate\sphinxhyphen{}based encryption schemes with Acrobat. In the password\sphinxhyphen{}based scheme, Acrobat queries the user for a password before a file is opened. The authorization procedure to open a file or to set an owner password can be modified by creating a custom security handler.




\section{Full\sphinxhyphen{}text search}
\label{\detokenize{apxDevFAQ:full-text-search}}

\subsection{What tools are available with Acrobat for full\sphinxhyphen{}text search?}
\label{\detokenize{apxDevFAQ:what-tools-are-available-with-acrobat-for-full-text-search}}
Adobe provides a full\sphinxhyphen{}text search system, known as the Acrobat Search Plug\sphinxhyphen{}in, based on third\sphinxhyphen{}party technology. However, this does not preclude other search systems from integrating with Acrobat. The Acrobat search system was created using only public API and IAC calls, and you can easily remove it from Acrobat and replace it with another search technology. For more information, see the ` <\sphinxurl{http://www.adobe.com/go/acrobatsdk\_iacguide}>`\_\_ \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} \sphinxstyleemphasis{.}

The Acrobat interface can be extended with new menus and toolbar icons to allow tight integration with your search plug\sphinxhyphen{}in and Acrobat. For example, buttons to invoke a search and to find the next or previous occurrences can be added to the toolbar.

For samples of adding menu items and toolbar buttons, see the related snippets in the \sphinxcode{\sphinxupquote{SnippetRunner}} sample plug\sphinxhyphen{}in.




\subsection{What tools are available for extracting and highlighting text?}
\label{\detokenize{apxDevFAQ:what-tools-are-available-for-extracting-and-highlighting-text}}
For indexing and searching PDF files directly, Acrobat provides support through IAC and plug\sphinxhyphen{}in calls. For indexing PDF files, Acrobat provides text extraction APIs. For further information on extracting text from PDF, see \sphinxhref{Faq.html\#63126}{How can I extract text?}


\subsection{How do I communicate with the Acrobat Search plug\sphinxhyphen{}in?}
\label{\detokenize{apxDevFAQ:how-do-i-communicate-with-the-acrobat-search-plug-in}}
You can communicate with the Search plug\sphinxhyphen{}in via its plug\sphinxhyphen{}in API or via IAC (DDE or Apple events). Using either of these methods, you can control the Acrobat Search plug\sphinxhyphen{}in in the following ways:
\begin{itemize}
\item {} 
Control the list of indexes to search.

\end{itemize}

The search interface allows for searches to be performed on one or more of the available indexes. You can control the list of active indexes.
\begin{itemize}
\item {} 
Initiate a search with options.

\end{itemize}

You can pass query expressions and search settings to the Acrobat search plug\sphinxhyphen{}in and initiate the search, and the results will be presented to the user.

For an example, see the \sphinxcode{\sphinxupquote{SearchPDF}} Visual Basic application. For documentation, see the \sphinxhref{http://www.adobe.com/go/pdflibrary}{Acrobat and PDF Library API Reference.}


\subsection{How do I create custom DocInfo fields for searching?}
\label{\detokenize{apxDevFAQ:how-do-i-create-custom-docinfo-fields-for-searching}}
The Catalog feature is used to create a search index; its API is available to third parties via the Catalog plug\sphinxhyphen{}in provided with the Acrobat SDK. See the \sphinxhref{https://www.adobe.com/devnet/pdf/library.html}{Acrobat and PDF Library API Reference} and the \sphinxhref{http://www.adobe.com/go/acrobatsdk\_iacguide}{Interapplication Communication Developer Guide} for more information.

Once you have built the search index, you must create the custom \sphinxcode{\sphinxupquote{DocInfo}} fields, which can be used to search document metadata. You can accomplish this task with either the Acrobat core API or using interapplication communication. See theadobefor more information.

At this point you may submit custom queries to the Acrobat Search plug\sphinxhyphen{}in to search by the custom fields, as demonstrated by the \sphinxcode{\sphinxupquote{SearchQuery}} sample plug\sphinxhyphen{}in. You can include your custom \sphinxcode{\sphinxupquote{DocInfo}} fields in the search by specifying them in the \sphinxcode{\sphinxupquote{sortSpec}} parameter of the \sphinxcode{\sphinxupquote{SearchExecuteQuery}} method.




\section{How do I use the Windows command line?}
\label{\detokenize{apxDevFAQ:how-do-i-use-the-windows-command-line}}
You can display and print a PDF file with Acrobat and Acrobat Reader from the command line. These commands are unsupported, but have worked for some developers. There is no documentation for these commands other than what is listed below.

\begin{sphinxadmonition}{note}{Note:}
All examples below use Acrobat Reader, but apply to Acrobat as well. If you are using Acrobat, substitute \sphinxcode{\sphinxupquote{Acrobat.exe}} for \sphinxcode{\sphinxupquote{AcroRd32.exe}} on the command line.
\end{sphinxadmonition}

\sphinxstyleemphasis{AcroRd32.exe} \sphinxstyleemphasis{pathname} — Start Acrobat Reader and display the file. The full path must be provided.

This command can accept the following options.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Option
&\sphinxstyletheadfamily 
Meaning
\\
\hline
/n
&
Start a separate instance of Acrobat or Acrobat Reader, even if one is currently open.
\\
\hline
/s
&
Suppress the splash screen.
\\
\hline
/o
&
Suppress the open file dialog box.
\\
\hline
/h
&
Start Acrobat or Acrobat Reader in a minimized window.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstyleemphasis{AcroRd32.exe /p} \sphinxstyleemphasis{pathname} — Start Acrobat Reader and display the Print dialog box.

\sphinxstyleemphasis{AcroRd32.exe /t path} \sphinxstyleemphasis{“printername” “drivername” “portname”} — Start Acrobat Reader and print a file while suppressing the Print dialog box. The path must be fully specified.

The four parameters of the \sphinxcode{\sphinxupquote{/t}} option evaluate to \sphinxcode{\sphinxupquote{path}} , \sphinxcode{\sphinxupquote{printername}} , \sphinxcode{\sphinxupquote{drivername}} , and \sphinxcode{\sphinxupquote{portname}} (all strings).

\sphinxstyleemphasis{printername} — The name of your printer.

\sphinxstyleemphasis{drivername} — Your printer driver’s name, as it appears in your printer’s properties.

\sphinxstyleemphasis{portname} — The printer’s port. \sphinxcode{\sphinxupquote{portname}} cannot contain any “/” characters; if it does, output is routed to the default port for that printer.


\section{How can I customize the Acrobat installer?}
\label{\detokenize{apxDevFAQ:how-can-i-customize-the-acrobat-installer}}
Adobe provides various ways in which you can deploy Acrobat products to a large number of systems.

You can find documentation about enterprise installation, including information about tools for customization and installation as well as guidelines for extending enterprise applications, in the \sphinxhref{https://www.adobe.com/go/acrobatetk}{Enterprise Toolkit} .



\renewcommand{\indexname}{Index}
\printindex
\end{document}